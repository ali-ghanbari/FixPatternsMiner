diff --git a/rundeckapp/grails-app/services/rundeck/ProjectManagerService.groovy b/rundeckapp/grails-app/services/rundeck/ProjectManagerService.groovy
deleted file mode 100644
index df3c0d7..0000000
--- a/rundeckapp/grails-app/services/rundeck/ProjectManagerService.groovy
+++ /dev/null
@@ -1,483 +0,0 @@
-package rundeck
-
-import com.codahale.metrics.Gauge
-import com.codahale.metrics.MetricRegistry
-import com.dtolabs.rundeck.core.common.Framework
-import com.dtolabs.rundeck.core.common.IRundeckProject
-import com.dtolabs.rundeck.core.common.ProjectManager
-import com.dtolabs.rundeck.core.common.ProjectNodeSupport
-import com.dtolabs.rundeck.core.storage.ResourceMeta
-import com.dtolabs.rundeck.core.storage.StorageTree
-import com.dtolabs.rundeck.core.storage.StorageUtil
-import com.dtolabs.rundeck.core.utils.IPropertyLookup
-import com.dtolabs.rundeck.core.utils.PropertyLookup
-import com.dtolabs.rundeck.server.projects.RundeckProject
-import com.google.common.cache.CacheBuilder
-import com.google.common.cache.CacheLoader
-import com.google.common.cache.LoadingCache
-import com.google.common.util.concurrent.Futures
-import com.google.common.util.concurrent.ListenableFuture
-import com.google.common.util.concurrent.ListenableFutureTask
-import grails.transaction.Transactional
-import org.apache.commons.fileupload.util.Streams
-import org.rundeck.storage.api.Resource
-import org.rundeck.storage.data.DataUtil
-import org.springframework.beans.factory.InitializingBean
-import org.springframework.context.ApplicationContext
-import org.springframework.context.ApplicationContextAware
-import rundeck.services.FrameworkService
-
-import java.util.concurrent.Callable
-import java.util.concurrent.ExecutorService
-import java.util.concurrent.Executors
-import java.util.concurrent.TimeUnit
-
-@Transactional
-class ProjectManagerService implements ProjectManager, ApplicationContextAware, InitializingBean {
-    public static final String ETC_PROJECT_PROPERTIES_PATH = "/etc/project.properties"
-    def FrameworkService frameworkService
-    private StorageTree rundeckConfigStorageTree
-    ApplicationContext applicationContext
-    def grailsApplication
-    def metricService
-
-    /**
-     * Load on demand due to cyclical spring dependency
-     * @return
-     */
-    private StorageTree getStorage() {
-        if (null == rundeckConfigStorageTree) {
-            rundeckConfigStorageTree = applicationContext.getBean("rundeckConfigStorageTree", StorageTree)
-        }
-        return rundeckConfigStorageTree
-    }
-    public void setStorage(StorageTree tree){
-        rundeckConfigStorageTree=tree
-    }
-
-    @Override
-    Collection<IRundeckProject> listFrameworkProjects() {
-        return Project.findAll().collect {
-            getFrameworkProject(it.name)
-        }
-    }
-
-    @Override
-    IRundeckProject getFrameworkProject(final String name) {
-        if (!existsFrameworkProject(name)) {
-            throw new IllegalArgumentException("Project does not exist: " + name)
-        }
-        def result = projectCache.get(name)
-        if (!result) {
-            throw new IllegalArgumentException("Project does not exist: " + name)
-        }
-        return result
-    }
-
-    @Override
-    boolean existsFrameworkProject(final String project) {
-        return Project.findByName(project) ? true : false
-    }
-
-    @Override
-    IRundeckProject createFrameworkProject(final String projectName) {
-        return createFrameworkProject(projectName, new Properties())
-    }
-    /**
-     * Scheduled executor for retries
-     */
-    private ExecutorService executor = Executors.newFixedThreadPool(2)
-
-    //basic creation, created via spec string in afterPropertiesSet()
-    private LoadingCache<String, IRundeckProject> projectCache =
-            CacheBuilder.newBuilder()
-                        .expireAfterAccess(10, TimeUnit.MINUTES)
-                        .refreshAfterWrite(1, TimeUnit.MINUTES)
-                        .build(
-                    new CacheLoader<String, IRundeckProject>() {
-                        public IRundeckProject load(String key) {
-                            return loadProject(key);
-                        }
-                    }
-            );
-
-    @Override
-    void afterPropertiesSet() throws Exception {
-        def spec = grailsApplication.config.rundeck?.projectManagerService?.projectCache?.spec ?:
-                "expireAfterAccess=10m,refreshAfterWrite=1m"
-
-        log.debug("projectCache: creating from spec: ${spec}")
-
-        projectCache = CacheBuilder.from(spec)
-                                   .recordStats()
-                                   .build(
-                new CacheLoader<String, IRundeckProject>() {
-                    public IRundeckProject load(String key) {
-                        return loadProject(key);
-                    }
-
-                    @Override
-                    ListenableFuture<IRundeckProject> reload(final String key, final IRundeckProject oldValue)
-                            throws Exception
-                    {
-                        if (needsReload(oldValue)) {
-                            ListenableFutureTask<IRundeckProject> task = ListenableFutureTask.create(
-                                    new Callable<IRundeckProject>() {
-                                        public IRundeckProject call() {
-                                            return loadProject(key);
-                                        }
-                                    }
-                            );
-                            executor.execute(task);
-                            return task;
-                        } else {
-                            return Futures.immediateFuture(oldValue)
-                        }
-                    }
-                }
-        )
-        MetricRegistry registry = metricService?.getMetricRegistry()
-        registry?.register(
-                MetricRegistry.name(this.class.name + ".projectCache", "hitCount"),
-                new Gauge<Long>() {
-                    @Override
-                    Long getValue() {
-                        projectCache.stats().hitCount()
-                    }
-                }
-        )
-
-        registry?.register(
-                MetricRegistry.name(this.class.name + ".projectCache", "evictionCount"),
-                new Gauge<Long>() {
-                    @Override
-                    Long getValue() {
-                        projectCache.stats().evictionCount()
-                    }
-                }
-        )
-        registry?.register(
-                MetricRegistry.name(this.class.name + ".projectCache", "missCount"),
-                new Gauge<Long>() {
-                    @Override
-                    Long getValue() {
-                        projectCache.stats().missCount()
-                    }
-                }
-        )
-        registry?.register(
-                MetricRegistry.name(this.class.name + ".projectCache", "loadExceptionCount"),
-                new Gauge<Long>() {
-                    @Override
-                    Long getValue() {
-                        projectCache.stats().loadExceptionCount()
-                    }
-                }
-        )
-        registry?.register(
-                MetricRegistry.name(this.class.name + ".projectCache", "hitRate"),
-                new Gauge<Double>() {
-                    @Override
-                    Double getValue() {
-                        projectCache.stats().hitRate()
-                    }
-                }
-        )
-    }
-
-    boolean existsProjectFileResource(String projectName, String path) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        return getStorage().hasResource(storagePath)
-    }
-    Resource<ResourceMeta> getProjectFileResource(String projectName, String path) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        if (!getStorage().hasResource(storagePath)) {
-            return null
-        }
-        getStorage().getResource(storagePath)
-    }
-    long readProjectFileResource(String projectName, String path, OutputStream output) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        def resource = getStorage().getResource(storagePath)
-        Streams.copy(resource.contents.inputStream,output,true)
-    }
-    /**
-     * Update existing resource, fails if it does not exist
-     * @param projectName project
-     * @param path path
-     * @param input stream
-     * @param meta metadata
-     * @return resource
-     */
-    Resource<ResourceMeta> updateProjectFileResource(String projectName, String path, InputStream input, Map<String,String> meta) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        getStorage().
-                updateResource(storagePath, DataUtil.withStream(input, meta, StorageUtil.factory()))
-    }
-    /**
-     * Create new resource, fails if it exists
-     * @param projectName project
-     * @param path path
-     * @param input stream
-     * @param meta metadata
-     * @return resource
-     */
-    Resource<ResourceMeta> createProjectFileResource(String projectName, String path, InputStream input, Map<String,String> meta) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        getStorage().
-                createResource(storagePath, DataUtil.withStream(input, meta, StorageUtil.factory()))
-    }
-    /**
-     * Write to a resource, create if it does not exist
-     * @param projectName project
-     * @param path path
-     * @param input stream
-     * @param meta metadata
-     * @return resource
-     */
-    Resource<ResourceMeta> writeProjectFileResource(String projectName, String path, InputStream input, Map<String,String> meta) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        if (!getStorage().hasResource(storagePath)) {
-            createProjectFileResource(projectName, path, input, meta)
-        }else{
-            updateProjectFileResource(projectName, path, input, meta)
-        }
-    }
-    /**
-     * delete a resource
-     * @param projectName project
-     * @param path path
-     * @return true if file was deleted or does not exist
-     */
-    boolean deleteProjectFileResource(String projectName, String path) {
-        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
-        if (!getStorage().hasResource(storagePath)) {
-            return true
-        }else{
-            return getStorage().deleteResource(storagePath)
-        }
-    }
-
-    Date getProjectConfigLastModified(String projectName) {
-        def resource = getProjectFileResource(projectName, ETC_PROJECT_PROPERTIES_PATH)
-        if(null==resource){
-            return null
-        }
-
-        resource.getContents().modificationTime
-    }
-
-    private Map loadProjectConfigResource(String projectName) {
-        def resource = getProjectFileResource(projectName,ETC_PROJECT_PROPERTIES_PATH)
-        if (null==resource) {
-            return [:]
-        }
-        //load as properties file
-        def properties = new Properties()
-        try {
-            properties.load(resource.contents.inputStream)
-        } catch (IOException e) {
-            log.error("Failed loading project properties from storage: ${resource.path}: " + e.message, e)
-        }
-
-        return [
-                config      : properties,
-                lastModified: resource.contents.modificationTime,
-                creationTime: resource.contents.creationTime
-        ]
-    }
-
-    private Map storeProjectConfig(String projectName, Properties properties) {
-        def storagePath = ETC_PROJECT_PROPERTIES_PATH
-        def baos = new ByteArrayOutputStream()
-        properties.store(baos, "project config " + projectName)
-        def bais = new ByteArrayInputStream(baos.toByteArray())
-
-        def metadata = [:]
-        def resource = writeProjectFileResource(projectName, storagePath, bais, metadata)
-
-        projectCache.invalidate(projectName)
-        return [
-                config      : properties,
-                lastModified: resource.contents.modificationTime,
-                creationTime: resource.contents.creationTime
-        ]
-    }
-
-    private void deleteProjectConfig(String projectName) {
-        if (!deleteProjectFileResource(projectName,ETC_PROJECT_PROPERTIES_PATH)) {
-            throw new IllegalArgumentException("Project config does not exist: " + projectName)
-        }
-        //TODO: recursively delete storage path
-        projectCache.invalidate(projectName)
-    }
-
-    private IPropertyLookup createProjectPropertyLookup(String projectName, Properties config) {
-        final Properties ownProps = new Properties();
-        ownProps.setProperty("project.name", projectName);
-        def create = PropertyLookup.create(
-                createDirectProjectPropertyLookup(projectName,config),
-                frameworkService.getRundeckFramework().propertyLookup
-        )
-
-        create.expand()
-        return create
-    }
-    private IPropertyLookup createDirectProjectPropertyLookup(String projectName, Properties config) {
-        final Properties ownProps = new Properties();
-        ownProps.setProperty("project.name", projectName);
-        ownProps.putAll(config)
-        def create = PropertyLookup.create(ownProps)
-        create.expand()
-        return create
-    }
-
-    @Override
-    IRundeckProject createFrameworkProject(final String projectName, final Properties properties) {
-        Project found = Project.findByName(projectName)
-        if (!found) {
-            def project = new Project(name: projectName)
-            project.save()
-        }
-        def res = storeProjectConfig(projectName, properties)
-        return new RundeckProject(
-                projectName,
-                createProjectPropertyLookup(projectName, res.config),
-                createDirectProjectPropertyLookup(projectName, res.config),
-                this,
-                res.lastModified
-        )
-    }
-
-    @Override
-    void removeFrameworkProject(final String projectName) {
-        Project found = Project.findByName(projectName)
-        if (!found) {
-            throw new IllegalArgumentException("project does not exist: " + projectName)
-        }
-        found.delete(flush: true)
-        deleteProjectConfig(projectName)
-    }
-
-    @Override
-    IRundeckProject createFrameworkProjectStrict(final String projectName, final Properties properties) {
-        Project found = Project.findByName(projectName)
-        if (found) {
-            throw new IllegalArgumentException("project exists: " + projectName)
-        }
-        return createFrameworkProject(projectName, properties)
-    }
-
-
-    void mergeProjectProperties(
-            final RundeckProject project,
-            final Properties properties,
-            final Set<String> removePrefixes
-    )
-    {
-        def resource=mergeProjectProperties(project.name,properties,removePrefixes)
-        project.lookup = createProjectPropertyLookup(project.name, resource.config ?: new Properties())
-        project.projectLookup = createDirectProjectPropertyLookup(project.name, resource.config ?: new Properties())
-        project.lastModifiedTime = resource.lastModified
-    }
-
-    Map mergeProjectProperties(
-            final String projectName,
-            final Properties properties,
-            final Set<String> removePrefixes
-    )
-    {
-        Project found = Project.findByName(projectName)
-        if (!found) {
-            throw new IllegalArgumentException("project does not exist: " + projectName)
-        }
-        def res = loadProjectConfigResource(projectName)
-        def oldprops = res.config
-        Properties newprops = mergeProperties(removePrefixes, oldprops, properties)
-        Map newres=storeProjectConfig(projectName, newprops)
-        projectCache.invalidate(projectName)
-        newres
-    }
-
-    /**
-     * Merge input properties with old properties, and remove any old properties with any of the given prefixes
-     * @param removePrefixes prefix set
-     * @param oldprops old properties
-     * @param inProps input properties
-     * @return merged properties
-     */
-    static Properties mergeProperties(Set<String> removePrefixes, Properties oldprops, Properties inProps) {
-        def newprops = new Properties()
-        if (removePrefixes) {
-            oldprops.propertyNames().each { String k ->
-                if (!removePrefixes.find { k.startsWith(it) }) {
-                    newprops.put(k, oldprops.getProperty(k))
-                }
-            }
-        }else{
-            newprops.putAll(oldprops)
-        }
-        newprops.putAll(inProps)
-        newprops
-    }
-
-    void setProjectProperties(final RundeckProject project, final Properties properties) {
-        def resource=setProjectProperties(project.name,properties)
-        project.lookup = createProjectPropertyLookup(project.name, resource.config ?: new Properties())
-        project.projectLookup = createDirectProjectPropertyLookup(project.name, resource.config ?: new Properties())
-        project.lastModifiedTime = resource.lastModified
-    }
-    Map setProjectProperties(final String projectName, final Properties properties) {
-        Project found = Project.findByName(projectName)
-        if (!found) {
-            throw new IllegalArgumentException("project does not exist: " + projectName)
-        }
-        Map resource=storeProjectConfig(projectName, properties)
-        projectCache.invalidate(projectName)
-        resource
-    }
-
-    /**
-     * Load the project config and node support
-     * @param project
-     * @return
-     */
-    IRundeckProject loadProject(final String project) {
-        if (!existsFrameworkProject(project)) {
-            throw new IllegalArgumentException("Project does not exist: " + project)
-        }
-        def resource = loadProjectConfigResource(project)
-        def rdproject = new RundeckProject(
-                project,
-                createProjectPropertyLookup(project, resource.config ?: new Properties()),
-                createDirectProjectPropertyLookup(project, resource.config ?: new Properties()),
-                this,
-                resource.lastModified
-        )
-
-        def framework = frameworkService.getRundeckFramework()
-        def nodes = new ProjectNodeSupport(
-                rdproject,
-                framework.getResourceFormatGeneratorService(),
-                framework.getResourceModelSourceService()
-        )
-        rdproject.projectNodes = nodes
-        return rdproject
-    }
-
-    boolean needsReload(IRundeckProject project) {
-        Project rdproject = Project.findByName(project.name)
-        boolean needsReload = rdproject == null ||
-                project.configLastModifiedTime == null ||
-                getProjectConfigLastModified(project.name) > project.configLastModifiedTime
-        needsReload
-    }
-
-    /**
-     * @return specific nodes resources file path for the project, based on the framework.nodes.file.name property
-     */
-    public String getNodesResourceFilePath(IRundeckProject project) {
-        ProjectNodeSupport.getNodesResourceFilePath(project, frameworkService.getRundeckFramework())
-    }
-
-}
diff --git a/rundeckapp/grails-app/services/rundeck/services/ProjectManagerService.groovy b/rundeckapp/grails-app/services/rundeck/services/ProjectManagerService.groovy
new file mode 100644
index 0000000..014bd67
--- /dev/null
+++ b/rundeckapp/grails-app/services/rundeck/services/ProjectManagerService.groovy
@@ -0,0 +1,484 @@
+package rundeck.services
+
+import com.codahale.metrics.Gauge
+import com.codahale.metrics.MetricRegistry
+import com.dtolabs.rundeck.core.common.Framework
+import com.dtolabs.rundeck.core.common.IRundeckProject
+import com.dtolabs.rundeck.core.common.ProjectManager
+import com.dtolabs.rundeck.core.common.ProjectNodeSupport
+import com.dtolabs.rundeck.core.storage.ResourceMeta
+import com.dtolabs.rundeck.core.storage.StorageTree
+import com.dtolabs.rundeck.core.storage.StorageUtil
+import com.dtolabs.rundeck.core.utils.IPropertyLookup
+import com.dtolabs.rundeck.core.utils.PropertyLookup
+import com.dtolabs.rundeck.server.projects.RundeckProject
+import com.google.common.cache.CacheBuilder
+import com.google.common.cache.CacheLoader
+import com.google.common.cache.LoadingCache
+import com.google.common.util.concurrent.Futures
+import com.google.common.util.concurrent.ListenableFuture
+import com.google.common.util.concurrent.ListenableFutureTask
+import grails.transaction.Transactional
+import org.apache.commons.fileupload.util.Streams
+import org.rundeck.storage.api.Resource
+import org.rundeck.storage.data.DataUtil
+import org.springframework.beans.factory.InitializingBean
+import org.springframework.context.ApplicationContext
+import org.springframework.context.ApplicationContextAware
+import rundeck.Project
+import rundeck.services.FrameworkService
+
+import java.util.concurrent.Callable
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.Executors
+import java.util.concurrent.TimeUnit
+
+@Transactional
+class ProjectManagerService implements ProjectManager, ApplicationContextAware, InitializingBean {
+    public static final String ETC_PROJECT_PROPERTIES_PATH = "/etc/project.properties"
+    def FrameworkService frameworkService
+    private StorageTree rundeckConfigStorageTree
+    ApplicationContext applicationContext
+    def grailsApplication
+    def metricService
+
+    /**
+     * Load on demand due to cyclical spring dependency
+     * @return
+     */
+    private StorageTree getStorage() {
+        if (null == rundeckConfigStorageTree) {
+            rundeckConfigStorageTree = applicationContext.getBean("rundeckConfigStorageTree", StorageTree)
+        }
+        return rundeckConfigStorageTree
+    }
+    public void setStorage(StorageTree tree){
+        rundeckConfigStorageTree=tree
+    }
+
+    @Override
+    Collection<IRundeckProject> listFrameworkProjects() {
+        return Project.findAll().collect {
+            getFrameworkProject(it.name)
+        }
+    }
+
+    @Override
+    IRundeckProject getFrameworkProject(final String name) {
+        if (!existsFrameworkProject(name)) {
+            throw new IllegalArgumentException("Project does not exist: " + name)
+        }
+        def result = projectCache.get(name)
+        if (!result) {
+            throw new IllegalArgumentException("Project does not exist: " + name)
+        }
+        return result
+    }
+
+    @Override
+    boolean existsFrameworkProject(final String project) {
+        return Project.findByName(project) ? true : false
+    }
+
+    @Override
+    IRundeckProject createFrameworkProject(final String projectName) {
+        return createFrameworkProject(projectName, new Properties())
+    }
+    /**
+     * Scheduled executor for retries
+     */
+    private ExecutorService executor = Executors.newFixedThreadPool(2)
+
+    //basic creation, created via spec string in afterPropertiesSet()
+    private LoadingCache<String, IRundeckProject> projectCache =
+            CacheBuilder.newBuilder()
+                        .expireAfterAccess(10, TimeUnit.MINUTES)
+                        .refreshAfterWrite(1, TimeUnit.MINUTES)
+                        .build(
+                    new CacheLoader<String, IRundeckProject>() {
+                        public IRundeckProject load(String key) {
+                            return loadProject(key);
+                        }
+                    }
+            );
+
+    @Override
+    void afterPropertiesSet() throws Exception {
+        def spec = grailsApplication.config.rundeck?.projectManagerService?.projectCache?.spec ?:
+                "expireAfterAccess=10m,refreshAfterWrite=1m"
+
+        log.debug("projectCache: creating from spec: ${spec}")
+
+        projectCache = CacheBuilder.from(spec)
+                                   .recordStats()
+                                   .build(
+                new CacheLoader<String, IRundeckProject>() {
+                    public IRundeckProject load(String key) {
+                        return loadProject(key);
+                    }
+
+                    @Override
+                    ListenableFuture<IRundeckProject> reload(final String key, final IRundeckProject oldValue)
+                            throws Exception
+                    {
+                        if (needsReload(oldValue)) {
+                            ListenableFutureTask<IRundeckProject> task = ListenableFutureTask.create(
+                                    new Callable<IRundeckProject>() {
+                                        public IRundeckProject call() {
+                                            return loadProject(key);
+                                        }
+                                    }
+                            );
+                            executor.execute(task);
+                            return task;
+                        } else {
+                            return Futures.immediateFuture(oldValue)
+                        }
+                    }
+                }
+        )
+        MetricRegistry registry = metricService?.getMetricRegistry()
+        registry?.register(
+                MetricRegistry.name(this.class.name + ".projectCache", "hitCount"),
+                new Gauge<Long>() {
+                    @Override
+                    Long getValue() {
+                        projectCache.stats().hitCount()
+                    }
+                }
+        )
+
+        registry?.register(
+                MetricRegistry.name(this.class.name + ".projectCache", "evictionCount"),
+                new Gauge<Long>() {
+                    @Override
+                    Long getValue() {
+                        projectCache.stats().evictionCount()
+                    }
+                }
+        )
+        registry?.register(
+                MetricRegistry.name(this.class.name + ".projectCache", "missCount"),
+                new Gauge<Long>() {
+                    @Override
+                    Long getValue() {
+                        projectCache.stats().missCount()
+                    }
+                }
+        )
+        registry?.register(
+                MetricRegistry.name(this.class.name + ".projectCache", "loadExceptionCount"),
+                new Gauge<Long>() {
+                    @Override
+                    Long getValue() {
+                        projectCache.stats().loadExceptionCount()
+                    }
+                }
+        )
+        registry?.register(
+                MetricRegistry.name(this.class.name + ".projectCache", "hitRate"),
+                new Gauge<Double>() {
+                    @Override
+                    Double getValue() {
+                        projectCache.stats().hitRate()
+                    }
+                }
+        )
+    }
+
+    boolean existsProjectFileResource(String projectName, String path) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        return getStorage().hasResource(storagePath)
+    }
+    Resource<ResourceMeta> getProjectFileResource(String projectName, String path) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        if (!getStorage().hasResource(storagePath)) {
+            return null
+        }
+        getStorage().getResource(storagePath)
+    }
+    long readProjectFileResource(String projectName, String path, OutputStream output) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        def resource = getStorage().getResource(storagePath)
+        Streams.copy(resource.contents.inputStream,output,true)
+    }
+    /**
+     * Update existing resource, fails if it does not exist
+     * @param projectName project
+     * @param path path
+     * @param input stream
+     * @param meta metadata
+     * @return resource
+     */
+    Resource<ResourceMeta> updateProjectFileResource(String projectName, String path, InputStream input, Map<String,String> meta) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        getStorage().
+                updateResource(storagePath, DataUtil.withStream(input, meta, StorageUtil.factory()))
+    }
+    /**
+     * Create new resource, fails if it exists
+     * @param projectName project
+     * @param path path
+     * @param input stream
+     * @param meta metadata
+     * @return resource
+     */
+    Resource<ResourceMeta> createProjectFileResource(String projectName, String path, InputStream input, Map<String,String> meta) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        getStorage().
+                createResource(storagePath, DataUtil.withStream(input, meta, StorageUtil.factory()))
+    }
+    /**
+     * Write to a resource, create if it does not exist
+     * @param projectName project
+     * @param path path
+     * @param input stream
+     * @param meta metadata
+     * @return resource
+     */
+    Resource<ResourceMeta> writeProjectFileResource(String projectName, String path, InputStream input, Map<String,String> meta) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        if (!getStorage().hasResource(storagePath)) {
+            createProjectFileResource(projectName, path, input, meta)
+        }else{
+            updateProjectFileResource(projectName, path, input, meta)
+        }
+    }
+    /**
+     * delete a resource
+     * @param projectName project
+     * @param path path
+     * @return true if file was deleted or does not exist
+     */
+    boolean deleteProjectFileResource(String projectName, String path) {
+        def storagePath = "projects/" + projectName + (path.startsWith("/")?path:"/${path}")
+        if (!getStorage().hasResource(storagePath)) {
+            return true
+        }else{
+            return getStorage().deleteResource(storagePath)
+        }
+    }
+
+    Date getProjectConfigLastModified(String projectName) {
+        def resource = getProjectFileResource(projectName, ETC_PROJECT_PROPERTIES_PATH)
+        if(null==resource){
+            return null
+        }
+
+        resource.getContents().modificationTime
+    }
+
+    private Map loadProjectConfigResource(String projectName) {
+        def resource = getProjectFileResource(projectName,ETC_PROJECT_PROPERTIES_PATH)
+        if (null==resource) {
+            return [:]
+        }
+        //load as properties file
+        def properties = new Properties()
+        try {
+            properties.load(resource.contents.inputStream)
+        } catch (IOException e) {
+            log.error("Failed loading project properties from storage: ${resource.path}: " + e.message, e)
+        }
+
+        return [
+                config      : properties,
+                lastModified: resource.contents.modificationTime,
+                creationTime: resource.contents.creationTime
+        ]
+    }
+
+    private Map storeProjectConfig(String projectName, Properties properties) {
+        def storagePath = ETC_PROJECT_PROPERTIES_PATH
+        def baos = new ByteArrayOutputStream()
+        properties.store(baos, "project config " + projectName)
+        def bais = new ByteArrayInputStream(baos.toByteArray())
+
+        def metadata = [:]
+        def resource = writeProjectFileResource(projectName, storagePath, bais, metadata)
+
+        projectCache.invalidate(projectName)
+        return [
+                config      : properties,
+                lastModified: resource.contents.modificationTime,
+                creationTime: resource.contents.creationTime
+        ]
+    }
+
+    private void deleteProjectConfig(String projectName) {
+        if (!deleteProjectFileResource(projectName,ETC_PROJECT_PROPERTIES_PATH)) {
+            throw new IllegalArgumentException("Project config does not exist: " + projectName)
+        }
+        //TODO: recursively delete storage path
+        projectCache.invalidate(projectName)
+    }
+
+    private IPropertyLookup createProjectPropertyLookup(String projectName, Properties config) {
+        final Properties ownProps = new Properties();
+        ownProps.setProperty("project.name", projectName);
+        def create = PropertyLookup.create(
+                createDirectProjectPropertyLookup(projectName,config),
+                frameworkService.getRundeckFramework().propertyLookup
+        )
+
+        create.expand()
+        return create
+    }
+    private IPropertyLookup createDirectProjectPropertyLookup(String projectName, Properties config) {
+        final Properties ownProps = new Properties();
+        ownProps.setProperty("project.name", projectName);
+        ownProps.putAll(config)
+        def create = PropertyLookup.create(ownProps)
+        create.expand()
+        return create
+    }
+
+    @Override
+    IRundeckProject createFrameworkProject(final String projectName, final Properties properties) {
+        Project found = Project.findByName(projectName)
+        if (!found) {
+            def project = new Project(name: projectName)
+            project.save()
+        }
+        def res = storeProjectConfig(projectName, properties)
+        return new RundeckProject(
+                projectName,
+                createProjectPropertyLookup(projectName, res.config),
+                createDirectProjectPropertyLookup(projectName, res.config),
+                this,
+                res.lastModified
+        )
+    }
+
+    @Override
+    void removeFrameworkProject(final String projectName) {
+        Project found = Project.findByName(projectName)
+        if (!found) {
+            throw new IllegalArgumentException("project does not exist: " + projectName)
+        }
+        found.delete(flush: true)
+        deleteProjectConfig(projectName)
+    }
+
+    @Override
+    IRundeckProject createFrameworkProjectStrict(final String projectName, final Properties properties) {
+        Project found = Project.findByName(projectName)
+        if (found) {
+            throw new IllegalArgumentException("project exists: " + projectName)
+        }
+        return createFrameworkProject(projectName, properties)
+    }
+
+
+    void mergeProjectProperties(
+            final RundeckProject project,
+            final Properties properties,
+            final Set<String> removePrefixes
+    )
+    {
+        def resource=mergeProjectProperties(project.name,properties,removePrefixes)
+        project.lookup = createProjectPropertyLookup(project.name, resource.config ?: new Properties())
+        project.projectLookup = createDirectProjectPropertyLookup(project.name, resource.config ?: new Properties())
+        project.lastModifiedTime = resource.lastModified
+    }
+
+    Map mergeProjectProperties(
+            final String projectName,
+            final Properties properties,
+            final Set<String> removePrefixes
+    )
+    {
+        Project found = Project.findByName(projectName)
+        if (!found) {
+            throw new IllegalArgumentException("project does not exist: " + projectName)
+        }
+        def res = loadProjectConfigResource(projectName)
+        def oldprops = res.config
+        Properties newprops = mergeProperties(removePrefixes, oldprops, properties)
+        Map newres=storeProjectConfig(projectName, newprops)
+        projectCache.invalidate(projectName)
+        newres
+    }
+
+    /**
+     * Merge input properties with old properties, and remove any old properties with any of the given prefixes
+     * @param removePrefixes prefix set
+     * @param oldprops old properties
+     * @param inProps input properties
+     * @return merged properties
+     */
+    static Properties mergeProperties(Set<String> removePrefixes, Properties oldprops, Properties inProps) {
+        def newprops = new Properties()
+        if (removePrefixes) {
+            oldprops.propertyNames().each { String k ->
+                if (!removePrefixes.find { k.startsWith(it) }) {
+                    newprops.put(k, oldprops.getProperty(k))
+                }
+            }
+        }else{
+            newprops.putAll(oldprops)
+        }
+        newprops.putAll(inProps)
+        newprops
+    }
+
+    void setProjectProperties(final RundeckProject project, final Properties properties) {
+        def resource=setProjectProperties(project.name,properties)
+        project.lookup = createProjectPropertyLookup(project.name, resource.config ?: new Properties())
+        project.projectLookup = createDirectProjectPropertyLookup(project.name, resource.config ?: new Properties())
+        project.lastModifiedTime = resource.lastModified
+    }
+    Map setProjectProperties(final String projectName, final Properties properties) {
+        Project found = Project.findByName(projectName)
+        if (!found) {
+            throw new IllegalArgumentException("project does not exist: " + projectName)
+        }
+        Map resource=storeProjectConfig(projectName, properties)
+        projectCache.invalidate(projectName)
+        resource
+    }
+
+    /**
+     * Load the project config and node support
+     * @param project
+     * @return
+     */
+    IRundeckProject loadProject(final String project) {
+        if (!existsFrameworkProject(project)) {
+            throw new IllegalArgumentException("Project does not exist: " + project)
+        }
+        def resource = loadProjectConfigResource(project)
+        def rdproject = new RundeckProject(
+                project,
+                createProjectPropertyLookup(project, resource.config ?: new Properties()),
+                createDirectProjectPropertyLookup(project, resource.config ?: new Properties()),
+                this,
+                resource.lastModified
+        )
+
+        def framework = frameworkService.getRundeckFramework()
+        def nodes = new ProjectNodeSupport(
+                rdproject,
+                framework.getResourceFormatGeneratorService(),
+                framework.getResourceModelSourceService()
+        )
+        rdproject.projectNodes = nodes
+        return rdproject
+    }
+
+    boolean needsReload(IRundeckProject project) {
+        Project rdproject = Project.findByName(project.name)
+        boolean needsReload = rdproject == null ||
+                project.configLastModifiedTime == null ||
+                getProjectConfigLastModified(project.name) > project.configLastModifiedTime
+        needsReload
+    }
+
+    /**
+     * @return specific nodes resources file path for the project, based on the framework.nodes.file.name property
+     */
+    public String getNodesResourceFilePath(IRundeckProject project) {
+        ProjectNodeSupport.getNodesResourceFilePath(project, frameworkService.getRundeckFramework())
+    }
+
+}
diff --git a/rundeckapp/src/java/com/dtolabs/rundeck/server/projects/RundeckProject.java b/rundeckapp/src/java/com/dtolabs/rundeck/server/projects/RundeckProject.java
index cae00ab..d35b39f 100644
--- a/rundeckapp/src/java/com/dtolabs/rundeck/server/projects/RundeckProject.java
+++ b/rundeckapp/src/java/com/dtolabs/rundeck/server/projects/RundeckProject.java
@@ -5 +5 @@
-import rundeck.ProjectManagerService;
+import rundeck.services.ProjectManagerService;
diff --git a/rundeckapp/test/unit/rundeck/ProjectManagerServiceSpec.groovy b/rundeckapp/test/unit/rundeck/ProjectManagerServiceSpec.groovy
deleted file mode 100644
index 23a6784..0000000
--- a/rundeckapp/test/unit/rundeck/ProjectManagerServiceSpec.groovy
+++ /dev/null
@@ -1,589 +0,0 @@
-package rundeck
-
-import com.dtolabs.rundeck.core.common.Framework
-import com.dtolabs.rundeck.core.storage.ResourceMeta
-import com.dtolabs.rundeck.core.storage.StorageTree
-import com.dtolabs.rundeck.core.utils.PropertyLookup
-import grails.test.mixin.Mock
-import grails.test.mixin.TestFor
-import org.rundeck.storage.api.PathUtil
-import org.rundeck.storage.api.Resource
-import org.rundeck.storage.api.StorageException
-import rundeck.services.FrameworkService
-import spock.lang.Specification
-
-/**
- * See the API for {@link grails.test.mixin.services.ServiceUnitTestMixin} for usage instructions
- */
-@TestFor(ProjectManagerService)
-@Mock([Project])
-class ProjectManagerServiceSpec extends Specification {
-
-    def setup() {
-    }
-
-    def cleanup() {
-    }
-
-    void "exists project does not exist"(){
-        when:
-        def result=service.existsFrameworkProject('test1')
-
-        then:
-        !result
-    }
-    void "exists project does exist"(){
-        setup:
-        def p = new Project(name:'test1')
-        p.save()
-
-        when:
-        def result=service.existsFrameworkProject('test1')
-
-        then:
-        result
-    }
-    void "get project does not exist"(){
-        when:
-        def result=service.getFrameworkProject('test1')
-
-        then:
-        IllegalArgumentException e=thrown()
-        e.message.contains('Project does not exist')
-    }
-    void "get project exists no props"(){
-        setup:
-        def p = new Project(name:'test1')
-        p.save()
-        service.storage=Stub(StorageTree){
-
-        }
-
-        def properties = new Properties()
-        properties.setProperty("fwkprop","fwkvalue")
-
-        service.frameworkService=Stub(FrameworkService){
-            getRundeckFramework() >> Stub(Framework){
-                getPropertyLookup() >> PropertyLookup.create(properties)
-            }
-        }
-        when:
-        def result=service.getFrameworkProject('test1')
-
-        then:
-        result!=null
-        'test1'==result.name
-        'fwkvalue'==result.getProperty('fwkprop')
-        'test1'==result.getProperty('project.name')
-        1==result.getProjectProperties().size()
-        'test1'==result.getProjectProperties().get('project.name')
-    }
-    void "get project exists with props"(){
-        setup:
-        def p = new Project(name:'test1')
-        p.save()
-        def modDate= new Date(123)
-
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/etc/project.properties") >> true
-            getResource("projects/test1/etc/project.properties") >> Stub(Resource){
-                getContents() >> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('projkey=projval'.bytes)
-                    getModificationTime() >> modDate
-                }
-            }
-        }
-
-        def properties = new Properties()
-        properties.setProperty("fwkprop","fwkvalue")
-
-        service.frameworkService=Stub(FrameworkService){
-            getRundeckFramework() >> Stub(Framework){
-                getPropertyLookup() >> PropertyLookup.create(properties)
-            }
-        }
-        when:
-        def result=service.getFrameworkProject('test1')
-
-        then:
-        result!=null
-        'test1'==result.name
-        'fwkvalue'==result.getProperty('fwkprop')
-        'test1'==result.getProperty('project.name')
-        'projval'==result.getProperty('projkey')
-        2==result.getProjectProperties().size()
-        'test1'==result.getProjectProperties().get('project.name')
-        'projval'==result.getProjectProperties().get('projkey')
-        modDate==result.getConfigLastModifiedTime()
-    }
-
-    void "create project with props"(){
-        setup:
-
-        def props = new Properties()
-        props['abc']='def'
-
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/etc/project.properties") >> false
-            createResource("projects/test1/etc/project.properties",{ResourceMeta rm->
-                def tprops=new Properties()
-                tprops.load(rm.inputStream)
-                rm.meta.size()==0 && tprops['abc']=='def'
-            }) >> Stub(Resource){
-                getContents()>> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
-                }
-            }
-        }
-
-        def properties = new Properties()
-        properties.setProperty("fwkprop","fwkvalue")
-
-        service.frameworkService=Stub(FrameworkService){
-            getRundeckFramework() >> Stub(Framework){
-                getPropertyLookup() >> PropertyLookup.create(properties)
-            }
-        }
-
-        when:
-
-        def result = service.createFrameworkProject('test1',props)
-
-        then:
-
-        result.name=='test1'
-        2==result.getProjectProperties().size()
-        'test1'==result.getProjectProperties().get('project.name')
-        'def'==result.getProjectProperties().get('abc')
-
-        null!=Project.findByName('test1')
-    }
-
-    void "create project strict already exists"(){
-        setup:
-        Project p = new Project(name:'test1').save()
-        def props = new Properties()
-        props['abc']='def'
-
-
-        when:
-
-        service.createFrameworkProjectStrict('test1',props)
-
-        then:
-
-        IllegalArgumentException e = thrown()
-        e.message.contains("project exists")
-    }
-
-    void "create project strict with props"(){
-        setup:
-
-        def props = new Properties()
-        props['abc']='def'
-
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/etc/project.properties") >> false
-            createResource("projects/test1/etc/project.properties",{ResourceMeta rm->
-                def tprops=new Properties()
-                tprops.load(rm.inputStream)
-                rm.meta.size()==0 && tprops['abc']=='def'
-            }) >> Stub(Resource){
-                getContents()>> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
-                }
-            }
-        }
-
-        def properties = new Properties()
-        properties.setProperty("fwkprop","fwkvalue")
-
-        service.frameworkService=Stub(FrameworkService){
-            getRundeckFramework() >> Stub(Framework){
-                getPropertyLookup() >> PropertyLookup.create(properties)
-            }
-        }
-
-        when:
-
-        def result = service.createFrameworkProjectStrict('test1',props)
-
-        then:
-
-        result.name=='test1'
-        2==result.getProjectProperties().size()
-        'test1'==result.getProjectProperties().get('project.name')
-        'def'==result.getProjectProperties().get('abc')
-
-        null!=Project.findByName('test1')
-    }
-
-    void "remove project does not exist"(){
-
-        when:
-
-        service.removeFrameworkProject('test1')
-
-        then:
-        IllegalArgumentException e = thrown()
-        e.message.contains('does not exist')
-    }
-
-    void "remove project does exist"(){
-        setup:
-        def p = new Project(name:'test1')
-        p.save()
-
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/etc/project.properties") >> true
-            deleteResource("projects/test1/etc/project.properties") >> true
-        }
-        when:
-
-        service.removeFrameworkProject('test1')
-
-        then:
-        null==Project.findByName('test1')
-
-    }
-
-    void "merge project properties internal"(){
-        setup:
-        Properties props1 = new Properties()
-        props1['def']='ghi'
-        new Project(name:'test1').save()
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/etc/project.properties") >> true
-            getResource("projects/test1/etc/project.properties") >> Stub(Resource){
-                getContents() >> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
-                }
-            }
-            updateResource("projects/test1/etc/project.properties",{ResourceMeta rm->
-                def tprops=new Properties()
-                tprops.load(rm.inputStream)
-                rm.meta.size()==0 && tprops['abc']=='def' && tprops['def']=='ghi'
-            }) >> Stub(Resource){
-                getContents()>> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('abc=def\ndef=ghi'.bytes)
-                }
-            }
-        }
-
-
-        when:
-        def res=service.mergeProjectProperties('test1',props1,[] as Set)
-
-        then:
-
-        res!=null
-        res.config.size()==2
-        'def'==res.config['abc']
-        'ghi'==res.config['def']
-    }
-    void "set project properties internal"(){
-        setup:
-        Properties props1 = new Properties()
-        props1['def']='ghi'
-        new Project(name:'test1').save()
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/etc/project.properties") >> true
-            getResource("projects/test1/etc/project.properties") >> Stub(Resource){
-                getContents() >> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
-                }
-            }
-            updateResource("projects/test1/etc/project.properties",{ResourceMeta rm->
-                def tprops=new Properties()
-                tprops.load(rm.inputStream)
-                rm.meta.size()==0 && tprops['abc']==null && tprops['def']=='ghi'
-            }) >> Stub(Resource){
-                getContents()>> Stub(ResourceMeta){
-                    getInputStream() >> new ByteArrayInputStream('def=ghi'.bytes)
-                }
-            }
-        }
-
-
-        when:
-        def res=service.setProjectProperties('test1',props1)
-
-        then:
-
-        res!=null
-        res.config.size()==1
-        null==res.config['abc']
-        'ghi'==res.config['def']
-    }
-
-    void "merge properties no conflict"() {
-        given:
-        Properties oldprops=new Properties()
-        oldprops.setProperty("abc","123")
-        oldprops.setProperty("def","456")
-        Properties newprops=new Properties()
-        newprops.setProperty("ghi","789")
-        Set<String> removePrefixes=[]
-
-        when:
-        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
-
-        then:
-        3==result.size()
-        "123"==result.getProperty("abc")
-        "456"==result.getProperty("def")
-        "789"==result.getProperty("ghi")
-
-    }
-
-    void "merge properties override"() {
-        given:
-        Properties oldprops=new Properties()
-        oldprops.setProperty("abc","123")
-        oldprops.setProperty("def","456")
-        Properties newprops=new Properties()
-        newprops.setProperty("abc","789")
-        Set<String> removePrefixes=[]
-
-        when:
-        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
-
-        then:
-        2==result.size()
-        "789"==result.getProperty("abc")
-        "456"==result.getProperty("def")
-
-    }
-
-    void "merge properties remove prefix"() {
-        given:
-        Properties oldprops=new Properties()
-        oldprops.setProperty("abc","123")
-        oldprops.setProperty("def","456")
-        Properties newprops=new Properties()
-        newprops.setProperty("ghi","789")
-        Set<String> removePrefixes=['de']
-
-        when:
-        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
-
-        then:
-        2==result.size()
-        "123"==result.getProperty("abc")
-        null==result.getProperty("def")
-        "789"==result.getProperty("ghi")
-
-    }
-
-    void "merge properties remove prefix multiple hits"() {
-        given:
-        Properties oldprops=new Properties()
-        oldprops.setProperty("abc","123")
-        oldprops.setProperty("def","456")
-        oldprops.setProperty("defleopard","money")
-        Properties newprops=new Properties()
-        newprops.setProperty("ghi","789")
-        Set<String> removePrefixes=['de']
-
-        when:
-        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
-
-        then:
-        2==result.size()
-        "123"==result.getProperty("abc")
-        null==result.getProperty("def")
-        null==result.getProperty("defleopard")
-        "789"==result.getProperty("ghi")
-    }
-
-    void "merge properties remove multiple prefixes multiple hits"() {
-        given:
-        Properties oldprops=new Properties()
-        oldprops.setProperty("abc","123")
-        oldprops.setProperty("abcdef","488")
-        oldprops.setProperty("def","456")
-        oldprops.setProperty("defleopard","money")
-        Properties newprops=new Properties()
-        newprops.setProperty("ghi","789")
-        Set<String> removePrefixes=['de','ab']
-
-        when:
-        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
-
-        then:
-        1==result.size()
-        null==result.getProperty("abc")
-        null==result.getProperty("abcdef")
-        null==result.getProperty("def")
-        null==result.getProperty("defleopard")
-        "789"==result.getProperty("ghi")
-    }
-
-    void "storage exists test"(){
-        given:
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/my-resource") >> true
-            hasResource("projects/test1/not-my-resource") >> false
-        }
-        expect:
-        service.existsProjectFileResource("test1","my-resource")
-        !service.existsProjectFileResource("test1","not-my-resource")
-    }
-    void "storage read test"(){
-        given:
-        def meta=Stub(ResourceMeta){
-            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
-        }
-        def resStub = Stub(Resource){
-            getContents()>> meta
-        }
-        service.storage=Stub(StorageTree){
-            getResource("projects/test1/my-resource") >> resStub
-        }
-
-        when:
-        def baos=new ByteArrayOutputStream()
-        def len=service.readProjectFileResource("test1","my-resource",baos)
-
-        then:
-        6==len
-        'abcdef'==baos.toString()
-    }
-    void "storage read does not exist"(){
-        given:
-
-        service.storage=Stub(StorageTree){
-            getResource("projects/test1/my-resource") >> {
-                throw StorageException.readException(PathUtil.asPath('projects/test1/my-resource'), "does not exist")
-            }
-        }
-
-        when:
-        def baos=new ByteArrayOutputStream()
-        def len=service.readProjectFileResource("test1","my-resource",baos)
-
-        then:
-        StorageException e = thrown()
-        e.message.contains('does not exist')
-    }
-    void "storage create test"(){
-        setup:
-        def meta=Stub(ResourceMeta){
-            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
-        }
-        def resStub = Stub(Resource){
-            getContents()>> meta
-        }
-        service.storage=Stub(StorageTree){
-            createResource("projects/test1/my-resource",{ResourceMeta rm->
-                rm.meta['a']=='b' && null!=rm.inputStream
-            }) >> resStub
-        }
-
-        when:
-        def result=service.createProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
-
-        then:
-        resStub==result
-    }
-    void "storage update test"(){
-        setup:
-        def meta=Stub(ResourceMeta){
-            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
-        }
-        def resStub = Stub(Resource){
-            getContents()>> meta
-        }
-        service.storage=Stub(StorageTree){
-            updateResource("projects/test1/my-resource",{ResourceMeta rm->
-                rm.meta['a']=='b' && null!=rm.inputStream
-            }) >> resStub
-        }
-
-        when:
-        def result=service.updateProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
-
-        then:
-        resStub==result
-    }
-    void "storage write test new resource"(){
-        given:
-        def meta=Stub(ResourceMeta){
-            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
-        }
-        def resStub = Stub(Resource){
-            getContents()>> meta
-        }
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/my-resource") >> false
-            createResource("projects/test1/my-resource",{ResourceMeta rm->
-                rm.meta['a']=='b' && null!=rm.inputStream
-            }) >> resStub
-        }
-
-        when:
-        def result=service.writeProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
-
-        then:
-        resStub==result
-    }
-    void "storage write test existing resource"(){
-        given:
-        def meta=Stub(ResourceMeta){
-            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
-        }
-        def resStub = Stub(Resource){
-            getContents()>> meta
-        }
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/my-resource") >> true
-            updateResource("projects/test1/my-resource",{ResourceMeta rm->
-                rm.meta['a']=='b' && null!=rm.inputStream
-            }) >> resStub
-        }
-
-        when:
-        def result=service.writeProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
-
-        then:
-        resStub==result
-    }
-    void "storage delete test existing resource"(){
-        given:
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/my-resource") >> true
-            deleteResource("projects/test1/my-resource") >> true
-        }
-
-        when:
-        def result=service.deleteProjectFileResource("test1","my-resource")
-
-        then:
-        result
-    }
-    void "storage delete test missing resource"(){
-        given:
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/my-resource") >> false
-        }
-
-        when:
-        def result=service.deleteProjectFileResource("test1","my-resource")
-
-        then:
-        result
-    }
-    void "storage delete test existing resource fails"(){
-        given:
-        service.storage=Stub(StorageTree){
-            hasResource("projects/test1/my-resource") >> true
-            deleteResource("projects/test1/my-resource") >> false
-        }
-
-        when:
-        def result=service.deleteProjectFileResource("test1","my-resource")
-
-        then:
-        !result
-    }
-}
diff --git a/rundeckapp/test/unit/rundeck/services/ProjectManagerServiceSpec.groovy b/rundeckapp/test/unit/rundeck/services/ProjectManagerServiceSpec.groovy
new file mode 100644
index 0000000..f6e302a
--- /dev/null
+++ b/rundeckapp/test/unit/rundeck/services/ProjectManagerServiceSpec.groovy
@@ -0,0 +1,591 @@
+package rundeck.services
+
+import com.dtolabs.rundeck.core.common.Framework
+import com.dtolabs.rundeck.core.storage.ResourceMeta
+import com.dtolabs.rundeck.core.storage.StorageTree
+import com.dtolabs.rundeck.core.utils.PropertyLookup
+import grails.test.mixin.Mock
+import grails.test.mixin.TestFor
+import org.rundeck.storage.api.PathUtil
+import org.rundeck.storage.api.Resource
+import org.rundeck.storage.api.StorageException
+import rundeck.Project
+import rundeck.services.FrameworkService
+import rundeck.services.ProjectManagerService
+import spock.lang.Specification
+
+/**
+ * See the API for {@link grails.test.mixin.services.ServiceUnitTestMixin} for usage instructions
+ */
+@TestFor(ProjectManagerService)
+@Mock([Project])
+class ProjectManagerServiceSpec extends Specification {
+
+    def setup() {
+    }
+
+    def cleanup() {
+    }
+
+    void "exists project does not exist"(){
+        when:
+        def result=service.existsFrameworkProject('test1')
+
+        then:
+        !result
+    }
+    void "exists project does exist"(){
+        setup:
+        def p = new Project(name:'test1')
+        p.save()
+
+        when:
+        def result=service.existsFrameworkProject('test1')
+
+        then:
+        result
+    }
+    void "get project does not exist"(){
+        when:
+        def result=service.getFrameworkProject('test1')
+
+        then:
+        IllegalArgumentException e=thrown()
+        e.message.contains('Project does not exist')
+    }
+    void "get project exists no props"(){
+        setup:
+        def p = new Project(name:'test1')
+        p.save()
+        service.storage=Stub(StorageTree){
+
+        }
+
+        def properties = new Properties()
+        properties.setProperty("fwkprop","fwkvalue")
+
+        service.frameworkService=Stub(FrameworkService){
+            getRundeckFramework() >> Stub(Framework){
+                getPropertyLookup() >> PropertyLookup.create(properties)
+            }
+        }
+        when:
+        def result=service.getFrameworkProject('test1')
+
+        then:
+        result!=null
+        'test1'==result.name
+        'fwkvalue'==result.getProperty('fwkprop')
+        'test1'==result.getProperty('project.name')
+        1==result.getProjectProperties().size()
+        'test1'==result.getProjectProperties().get('project.name')
+    }
+    void "get project exists with props"(){
+        setup:
+        def p = new Project(name:'test1')
+        p.save()
+        def modDate= new Date(123)
+
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/etc/project.properties") >> true
+            getResource("projects/test1/etc/project.properties") >> Stub(Resource){
+                getContents() >> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('projkey=projval'.bytes)
+                    getModificationTime() >> modDate
+                }
+            }
+        }
+
+        def properties = new Properties()
+        properties.setProperty("fwkprop","fwkvalue")
+
+        service.frameworkService=Stub(FrameworkService){
+            getRundeckFramework() >> Stub(Framework){
+                getPropertyLookup() >> PropertyLookup.create(properties)
+            }
+        }
+        when:
+        def result=service.getFrameworkProject('test1')
+
+        then:
+        result!=null
+        'test1'==result.name
+        'fwkvalue'==result.getProperty('fwkprop')
+        'test1'==result.getProperty('project.name')
+        'projval'==result.getProperty('projkey')
+        2==result.getProjectProperties().size()
+        'test1'==result.getProjectProperties().get('project.name')
+        'projval'==result.getProjectProperties().get('projkey')
+        modDate==result.getConfigLastModifiedTime()
+    }
+
+    void "create project with props"(){
+        setup:
+
+        def props = new Properties()
+        props['abc']='def'
+
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/etc/project.properties") >> false
+            createResource("projects/test1/etc/project.properties",{ResourceMeta rm->
+                def tprops=new Properties()
+                tprops.load(rm.inputStream)
+                rm.meta.size()==0 && tprops['abc']=='def'
+            }) >> Stub(Resource){
+                getContents()>> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
+                }
+            }
+        }
+
+        def properties = new Properties()
+        properties.setProperty("fwkprop","fwkvalue")
+
+        service.frameworkService=Stub(FrameworkService){
+            getRundeckFramework() >> Stub(Framework){
+                getPropertyLookup() >> PropertyLookup.create(properties)
+            }
+        }
+
+        when:
+
+        def result = service.createFrameworkProject('test1',props)
+
+        then:
+
+        result.name=='test1'
+        2==result.getProjectProperties().size()
+        'test1'==result.getProjectProperties().get('project.name')
+        'def'==result.getProjectProperties().get('abc')
+
+        null!=Project.findByName('test1')
+    }
+
+    void "create project strict already exists"(){
+        setup:
+        Project p = new Project(name:'test1').save()
+        def props = new Properties()
+        props['abc']='def'
+
+
+        when:
+
+        service.createFrameworkProjectStrict('test1',props)
+
+        then:
+
+        IllegalArgumentException e = thrown()
+        e.message.contains("project exists")
+    }
+
+    void "create project strict with props"(){
+        setup:
+
+        def props = new Properties()
+        props['abc']='def'
+
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/etc/project.properties") >> false
+            createResource("projects/test1/etc/project.properties",{ResourceMeta rm->
+                def tprops=new Properties()
+                tprops.load(rm.inputStream)
+                rm.meta.size()==0 && tprops['abc']=='def'
+            }) >> Stub(Resource){
+                getContents()>> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
+                }
+            }
+        }
+
+        def properties = new Properties()
+        properties.setProperty("fwkprop","fwkvalue")
+
+        service.frameworkService=Stub(FrameworkService){
+            getRundeckFramework() >> Stub(Framework){
+                getPropertyLookup() >> PropertyLookup.create(properties)
+            }
+        }
+
+        when:
+
+        def result = service.createFrameworkProjectStrict('test1',props)
+
+        then:
+
+        result.name=='test1'
+        2==result.getProjectProperties().size()
+        'test1'==result.getProjectProperties().get('project.name')
+        'def'==result.getProjectProperties().get('abc')
+
+        null!=Project.findByName('test1')
+    }
+
+    void "remove project does not exist"(){
+
+        when:
+
+        service.removeFrameworkProject('test1')
+
+        then:
+        IllegalArgumentException e = thrown()
+        e.message.contains('does not exist')
+    }
+
+    void "remove project does exist"(){
+        setup:
+        def p = new Project(name:'test1')
+        p.save()
+
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/etc/project.properties") >> true
+            deleteResource("projects/test1/etc/project.properties") >> true
+        }
+        when:
+
+        service.removeFrameworkProject('test1')
+
+        then:
+        null==Project.findByName('test1')
+
+    }
+
+    void "merge project properties internal"(){
+        setup:
+        Properties props1 = new Properties()
+        props1['def']='ghi'
+        new Project(name:'test1').save()
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/etc/project.properties") >> true
+            getResource("projects/test1/etc/project.properties") >> Stub(Resource){
+                getContents() >> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
+                }
+            }
+            updateResource("projects/test1/etc/project.properties",{ResourceMeta rm->
+                def tprops=new Properties()
+                tprops.load(rm.inputStream)
+                rm.meta.size()==0 && tprops['abc']=='def' && tprops['def']=='ghi'
+            }) >> Stub(Resource){
+                getContents()>> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('abc=def\ndef=ghi'.bytes)
+                }
+            }
+        }
+
+
+        when:
+        def res=service.mergeProjectProperties('test1',props1,[] as Set)
+
+        then:
+
+        res!=null
+        res.config.size()==2
+        'def'==res.config['abc']
+        'ghi'==res.config['def']
+    }
+    void "set project properties internal"(){
+        setup:
+        Properties props1 = new Properties()
+        props1['def']='ghi'
+        new Project(name:'test1').save()
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/etc/project.properties") >> true
+            getResource("projects/test1/etc/project.properties") >> Stub(Resource){
+                getContents() >> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('abc=def'.bytes)
+                }
+            }
+            updateResource("projects/test1/etc/project.properties",{ResourceMeta rm->
+                def tprops=new Properties()
+                tprops.load(rm.inputStream)
+                rm.meta.size()==0 && tprops['abc']==null && tprops['def']=='ghi'
+            }) >> Stub(Resource){
+                getContents()>> Stub(ResourceMeta){
+                    getInputStream() >> new ByteArrayInputStream('def=ghi'.bytes)
+                }
+            }
+        }
+
+
+        when:
+        def res=service.setProjectProperties('test1',props1)
+
+        then:
+
+        res!=null
+        res.config.size()==1
+        null==res.config['abc']
+        'ghi'==res.config['def']
+    }
+
+    void "merge properties no conflict"() {
+        given:
+        Properties oldprops=new Properties()
+        oldprops.setProperty("abc","123")
+        oldprops.setProperty("def","456")
+        Properties newprops=new Properties()
+        newprops.setProperty("ghi","789")
+        Set<String> removePrefixes=[]
+
+        when:
+        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
+
+        then:
+        3==result.size()
+        "123"==result.getProperty("abc")
+        "456"==result.getProperty("def")
+        "789"==result.getProperty("ghi")
+
+    }
+
+    void "merge properties override"() {
+        given:
+        Properties oldprops=new Properties()
+        oldprops.setProperty("abc","123")
+        oldprops.setProperty("def","456")
+        Properties newprops=new Properties()
+        newprops.setProperty("abc","789")
+        Set<String> removePrefixes=[]
+
+        when:
+        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
+
+        then:
+        2==result.size()
+        "789"==result.getProperty("abc")
+        "456"==result.getProperty("def")
+
+    }
+
+    void "merge properties remove prefix"() {
+        given:
+        Properties oldprops=new Properties()
+        oldprops.setProperty("abc","123")
+        oldprops.setProperty("def","456")
+        Properties newprops=new Properties()
+        newprops.setProperty("ghi","789")
+        Set<String> removePrefixes=['de']
+
+        when:
+        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
+
+        then:
+        2==result.size()
+        "123"==result.getProperty("abc")
+        null==result.getProperty("def")
+        "789"==result.getProperty("ghi")
+
+    }
+
+    void "merge properties remove prefix multiple hits"() {
+        given:
+        Properties oldprops=new Properties()
+        oldprops.setProperty("abc","123")
+        oldprops.setProperty("def","456")
+        oldprops.setProperty("defleopard","money")
+        Properties newprops=new Properties()
+        newprops.setProperty("ghi","789")
+        Set<String> removePrefixes=['de']
+
+        when:
+        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
+
+        then:
+        2==result.size()
+        "123"==result.getProperty("abc")
+        null==result.getProperty("def")
+        null==result.getProperty("defleopard")
+        "789"==result.getProperty("ghi")
+    }
+
+    void "merge properties remove multiple prefixes multiple hits"() {
+        given:
+        Properties oldprops=new Properties()
+        oldprops.setProperty("abc","123")
+        oldprops.setProperty("abcdef","488")
+        oldprops.setProperty("def","456")
+        oldprops.setProperty("defleopard","money")
+        Properties newprops=new Properties()
+        newprops.setProperty("ghi","789")
+        Set<String> removePrefixes=['de','ab']
+
+        when:
+        Properties result=ProjectManagerService.mergeProperties(removePrefixes,oldprops,newprops)
+
+        then:
+        1==result.size()
+        null==result.getProperty("abc")
+        null==result.getProperty("abcdef")
+        null==result.getProperty("def")
+        null==result.getProperty("defleopard")
+        "789"==result.getProperty("ghi")
+    }
+
+    void "storage exists test"(){
+        given:
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/my-resource") >> true
+            hasResource("projects/test1/not-my-resource") >> false
+        }
+        expect:
+        service.existsProjectFileResource("test1","my-resource")
+        !service.existsProjectFileResource("test1","not-my-resource")
+    }
+    void "storage read test"(){
+        given:
+        def meta=Stub(ResourceMeta){
+            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
+        }
+        def resStub = Stub(Resource){
+            getContents()>> meta
+        }
+        service.storage=Stub(StorageTree){
+            getResource("projects/test1/my-resource") >> resStub
+        }
+
+        when:
+        def baos=new ByteArrayOutputStream()
+        def len=service.readProjectFileResource("test1","my-resource",baos)
+
+        then:
+        6==len
+        'abcdef'==baos.toString()
+    }
+    void "storage read does not exist"(){
+        given:
+
+        service.storage=Stub(StorageTree){
+            getResource("projects/test1/my-resource") >> {
+                throw StorageException.readException(PathUtil.asPath('projects/test1/my-resource'), "does not exist")
+            }
+        }
+
+        when:
+        def baos=new ByteArrayOutputStream()
+        def len=service.readProjectFileResource("test1","my-resource",baos)
+
+        then:
+        StorageException e = thrown()
+        e.message.contains('does not exist')
+    }
+    void "storage create test"(){
+        setup:
+        def meta=Stub(ResourceMeta){
+            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
+        }
+        def resStub = Stub(Resource){
+            getContents()>> meta
+        }
+        service.storage=Stub(StorageTree){
+            createResource("projects/test1/my-resource",{ResourceMeta rm->
+                rm.meta['a']=='b' && null!=rm.inputStream
+            }) >> resStub
+        }
+
+        when:
+        def result=service.createProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
+
+        then:
+        resStub==result
+    }
+    void "storage update test"(){
+        setup:
+        def meta=Stub(ResourceMeta){
+            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
+        }
+        def resStub = Stub(Resource){
+            getContents()>> meta
+        }
+        service.storage=Stub(StorageTree){
+            updateResource("projects/test1/my-resource",{ResourceMeta rm->
+                rm.meta['a']=='b' && null!=rm.inputStream
+            }) >> resStub
+        }
+
+        when:
+        def result=service.updateProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
+
+        then:
+        resStub==result
+    }
+    void "storage write test new resource"(){
+        given:
+        def meta=Stub(ResourceMeta){
+            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
+        }
+        def resStub = Stub(Resource){
+            getContents()>> meta
+        }
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/my-resource") >> false
+            createResource("projects/test1/my-resource",{ResourceMeta rm->
+                rm.meta['a']=='b' && null!=rm.inputStream
+            }) >> resStub
+        }
+
+        when:
+        def result=service.writeProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
+
+        then:
+        resStub==result
+    }
+    void "storage write test existing resource"(){
+        given:
+        def meta=Stub(ResourceMeta){
+            getInputStream() >> new ByteArrayInputStream('abcdef'.bytes)
+        }
+        def resStub = Stub(Resource){
+            getContents()>> meta
+        }
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/my-resource") >> true
+            updateResource("projects/test1/my-resource",{ResourceMeta rm->
+                rm.meta['a']=='b' && null!=rm.inputStream
+            }) >> resStub
+        }
+
+        when:
+        def result=service.writeProjectFileResource("test1","my-resource",new ByteArrayInputStream('abcdef'.bytes),[a:'b'])
+
+        then:
+        resStub==result
+    }
+    void "storage delete test existing resource"(){
+        given:
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/my-resource") >> true
+            deleteResource("projects/test1/my-resource") >> true
+        }
+
+        when:
+        def result=service.deleteProjectFileResource("test1","my-resource")
+
+        then:
+        result
+    }
+    void "storage delete test missing resource"(){
+        given:
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/my-resource") >> false
+        }
+
+        when:
+        def result=service.deleteProjectFileResource("test1","my-resource")
+
+        then:
+        result
+    }
+    void "storage delete test existing resource fails"(){
+        given:
+        service.storage=Stub(StorageTree){
+            hasResource("projects/test1/my-resource") >> true
+            deleteResource("projects/test1/my-resource") >> false
+        }
+
+        when:
+        def result=service.deleteProjectFileResource("test1","my-resource")
+
+        then:
+        !result
+    }
+}

