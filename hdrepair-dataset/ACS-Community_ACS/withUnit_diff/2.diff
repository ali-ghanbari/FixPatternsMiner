diff --git a/LGPL/CommonSoftware/jmanager/src/com/cosylab/acs/maci/manager/ManagerImpl.java b/LGPL/CommonSoftware/jmanager/src/com/cosylab/acs/maci/manager/ManagerImpl.java
index 5f9a90a..3ab5a25 100755
--- a/LGPL/CommonSoftware/jmanager/src/com/cosylab/acs/maci/manager/ManagerImpl.java
+++ b/LGPL/CommonSoftware/jmanager/src/com/cosylab/acs/maci/manager/ManagerImpl.java
@@ -410 +410 @@
-					taskToRun = tasks.pollLast();
+					taskToRun = tasks.pollFirst();
diff --git a/LGPL/CommonSoftware/jmanager/test/com/cosylab/acs/maci/test/ManagerImplTest.java b/LGPL/CommonSoftware/jmanager/test/com/cosylab/acs/maci/test/ManagerImplTest.java
index cefbb45..97102e2 100755
--- a/LGPL/CommonSoftware/jmanager/test/com/cosylab/acs/maci/test/ManagerImplTest.java
+++ b/LGPL/CommonSoftware/jmanager/test/com/cosylab/acs/maci/test/ManagerImplTest.java
@@ -15,0 +16 @@
+import java.util.concurrent.atomic.AtomicLong;
@@ -40,0 +42 @@
+import com.cosylab.acs.maci.RemoteException;
@@ -4230,0 +4233,86 @@
+	
+	// first two callback blocks
+	// this means that third should not happen before first two
+	// and all calls should be done from the same thread
+	public void testBadAdministratorNotifications()
+	{
+		try
+		{
+			final long BLOCK_TIMEOUT_MS = 3000;
+			
+			TestAdministrator admin = new TestAdministrator("admin", true) {
+				
+				private AtomicInteger counter = new AtomicInteger(0);
+				private AtomicLong threadId = new AtomicLong(-1);
+				
+				public void clientLoggedIn(ClientInfo info, long timeStamp, long executionId) {
+					
+					// same as last thread check (transitive)
+					long thisThreadId = Thread.currentThread().getId();	// positive
+					long previousId = threadId.getAndSet(thisThreadId);
+					if (previousId != thisThreadId && previousId >= 0)
+						fail("notification called from other thread");
+					
+					// only first two block for a while
+					if (counter.incrementAndGet() < 3)
+					{
+						try {
+							Thread.sleep(BLOCK_TIMEOUT_MS);
+						} catch (InterruptedException e) {
+							// noop
+						}
+					}
+					super.clientLoggedIn(info, timeStamp, executionId);
+				}				
+			};
+			ClientInfo adminInfo = manager.login(admin);
+			assertNotNull(adminInfo);
+
+			// now we login 3 clients
+			Client client1 = new TestClient("client1");
+			Client client2 = new TestClient("client2");
+			Client client3 = new TestClient("client3");
+
+			// even if admin is blocking, this should not block this
+			// notification are async (not a SyncAdmin)
+			
+			long startTS = System.currentTimeMillis();
+			
+			ClientInfo clientInfo1 = manager.login(client1);
+			assertNotNull(clientInfo1);
+
+			ClientInfo clientInfo2 = manager.login(client2);
+			assertNotNull(clientInfo2);
+
+			ClientInfo clientInfo3 = manager.login(client3);
+			assertNotNull(clientInfo3);
+
+			long stopTS = System.currentTimeMillis();
+			assertTrue((stopTS-startTS) < BLOCK_TIMEOUT_MS);
+
+			ArrayList notifications = admin.getClientLoggedInNotifications();
+			synchronized (notifications) {
+				int count = 0;
+				while (notifications.size() < 3)
+				{
+					// wait max up to 3*BLOCK_TIMEOUT_MS (must be careful about spurious wakeups)
+					if ((System.currentTimeMillis()-stopTS) > 3*BLOCK_TIMEOUT_MS)
+					{
+						fail("expected 3 notifications, got " + notifications.size());
+					}
+					try {
+						notifications.wait(3*BLOCK_TIMEOUT_MS);
+					} catch (InterruptedException e) { /* noop */ }
+				}
+				
+				assertEquals(3, notifications.size());
+				assertEquals(clientInfo1, notifications.get(0));
+				assertEquals(clientInfo2, notifications.get(1));
+				assertEquals(clientInfo3, notifications.get(2));
+			}
+			
+		} catch (AcsJNoPermissionEx e) {
+			fail("No permission");
+		}
+	}
+	
diff --git a/LGPL/CommonSoftware/jmanager/test/ref/doAllTests.ref b/LGPL/CommonSoftware/jmanager/test/ref/doAllTests.ref
index 51bf645..b8ec68e 100644
--- a/LGPL/CommonSoftware/jmanager/test/ref/doAllTests.ref
+++ b/LGPL/CommonSoftware/jmanager/test/ref/doAllTests.ref
@@ -115 +115 @@
-1 - OK (41 tests)
+1 - OK (42 tests)

