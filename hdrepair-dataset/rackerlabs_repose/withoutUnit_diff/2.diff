diff --git a/repose-aggregator/components/filters/filter-bundle/pom.xml b/repose-aggregator/components/filters/filter-bundle/pom.xml
index c63d355..d31ca4d 100644
--- a/repose-aggregator/components/filters/filter-bundle/pom.xml
+++ b/repose-aggregator/components/filters/filter-bundle/pom.xml
@@ -133,0 +134,5 @@
+
+        <dependency>
+            <groupId>com.rackspace.papi.components</groupId>
+            <artifactId>rackspace-identity-basic-auth</artifactId>
+        </dependency>
@@ -244,0 +250,5 @@
+
+                        <jarModule>
+                            <groupId>com.rackspace.papi.components</groupId>
+                            <artifactId>rackspace-identity-basic-auth</artifactId>
+                        </jarModule>
diff --git a/repose-aggregator/components/filters/filter-bundle/src/main/application/WEB-INF/web-fragment.xml b/repose-aggregator/components/filters/filter-bundle/src/main/application/WEB-INF/web-fragment.xml
index acddab2..8176fa4 100644
--- a/repose-aggregator/components/filters/filter-bundle/src/main/application/WEB-INF/web-fragment.xml
+++ b/repose-aggregator/components/filters/filter-bundle/src/main/application/WEB-INF/web-fragment.xml
@@ -118,0 +119,5 @@
+
+    <filter>
+        <filter-name>rackspace-identity-basic-auth</filter-name>
+        <filter-class>com.rackspace.papi.components.rackspace.identity.basicauth.RackspaceIdentityBasicAuthFilter</filter-class>
+    </filter>
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/main/resources/META-INF/config/schema/openstack-identity-v3.xsd b/repose-aggregator/components/filters/openstack-identity-v3/src/main/resources/META-INF/config/schema/openstack-identity-v3.xsd
index 9c622d4..be96557 100644
--- a/repose-aggregator/components/filters/openstack-identity-v3/src/main/resources/META-INF/config/schema/openstack-identity-v3.xsd
+++ b/repose-aggregator/components/filters/openstack-identity-v3/src/main/resources/META-INF/config/schema/openstack-identity-v3.xsd
@@ -23,0 +24,3 @@
+            <xs:element name="validate-project-id-in-uri" type="ValidateProjectID" minOccurs="0" maxOccurs="1"/>
+            <xs:element name="roles-which-bypass-project-id-check" type="IgnoreProjectIDRoles" minOccurs="0"
+                        maxOccurs="1"/>
@@ -186,0 +190,38 @@
+
+    <xs:complexType name="ValidateProjectID">
+        <xs:annotation>
+            <xs:documentation>
+                <html:p>
+                    If this element is present, the OpenStack Identity V3 filter will attempt to match the project ID
+                    parsed from the URI against the set of project IDs in the token provided by the Identity service.
+                </html:p>
+            </xs:documentation>
+        </xs:annotation>
+
+        <xs:attribute name="regex" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    <html:p>
+                        This attribute represents a regular expression which will be used to parse the project ID
+                        out of the uri. A capture group should be present around the portion of the regex which matches
+                        the project ID.
+                    </html:p>
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="IgnoreProjectIDRoles">
+        <xs:annotation>
+            <xs:documentation>
+                <html:p>
+                    A list of roles to bypass the project id check.
+                    Users with any of the roles specified will not be required to have a project id.
+                </html:p>
+            </xs:documentation>
+        </xs:annotation>
+
+        <xs:sequence>
+            <xs:element name="role" type="xs:string" minOccurs="1" maxOccurs="unbounded"/>
+        </xs:sequence>
+    </xs:complexType>
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3Handler.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3Handler.scala
index f1b7aad..6dd635a 100644
--- a/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3Handler.scala
+++ b/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3Handler.scala
@@ -18,0 +19 @@
+import scala.util.matching.Regex
@@ -29,0 +31,2 @@
+  private val projectIdUriRegex = Option(identityConfig.getValidateProjectIdInUri).map(_.getRegex.r)
+  private val bypassProjectIdCheckRoles = Option(identityConfig.getRolesWhichBypassProjectIdCheck).map(_.getRole.asScala.toList)
@@ -40,0 +44 @@
+    // Check if the request URI is whitelisted and pass it along if so
@@ -45 +49 @@
-      val requestHeaderManager = filterDirector.requestHeaderManager()
+      val requestHeaderManager = filterDirector.requestHeaderManager
@@ -51,2 +55,5 @@
-      var authSuccess = false
-      authenticate(request) match {
+      // Track whether or not a failure has occurred so that we can stop checking the request after we know it is bad
+      var failureInValidation = false
+
+      // Attempt to validate the request token with the Identity service
+      val token = authenticate(request) match {
@@ -54,41 +61 @@
-          authSuccess = true
-
-          requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_TOKEN_EXPIRES, tokenObject.expires_at)
-          requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_AUTHORIZATION.toString, OpenStackIdentityV3Headers.X_AUTH_PROXY) // TODO: Add the project ID if verified (not in-scope)
-          tokenObject.user.name.map(requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_USER_NAME.toString, _))
-          tokenObject.roles.map { roles =>
-            requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_ROLES, roles.map(_.name) mkString ",")
-          }
-          tokenObject.user.id.map { id =>
-            requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_USER_ID.toString, id)
-            requestHeaderManager.appendHeader(PowerApiHeader.USER.toString, id, 1.0)
-          }
-          tokenObject.project.map { project =>
-            project.id.map(requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_PROJECT_ID.toString, _))
-            project.name.map(requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_PROJECT_NAME.toString, _))
-          }
-          if (forwardCatalog) {
-            tokenObject.catalog.map(catalog => requestHeaderManager.putHeader(PowerApiHeader.X_CATALOG.toString, base64Encode(catalog.toJson.compactPrint)))
-          }
-          if (forwardGroups) {
-            tokenObject.user.id map { userId: String =>
-              identityAPI.getGroups(userId) map { groupsList: List[Group] =>
-                groupsList map { group: Group =>
-                  requestHeaderManager.appendHeader(PowerApiHeader.GROUPS.toString, group.name + ";q=1.0")
-                }
-              }
-            } orElse {
-              LOG.warn("The X-PP-Groups header could not be populated. The user ID was not present in the token retrieved from Keystone.")
-              None
-            }
-          }
-          // TODO: Set X-Impersonator-Name, need to check response for impersonator (out of scope)
-          // TODO: Set X-Impersonator-Id, same as above
-          // TODO: Set X-Default-Region, may require another API call? Doesn't seem to be returned in a token
-
-          if (isAuthorized(tokenObject)) {
-            filterDirector.setFilterAction(FilterAction.PASS)
-          } else {
-            filterDirector.setFilterAction(FilterAction.RETURN)
-            filterDirector.setResponseStatus(HttpStatusCode.FORBIDDEN)
-          }
+          Some(tokenObject)
@@ -95,0 +63 @@
+          failureInValidation = true
@@ -97,0 +66 @@
+          None
@@ -98,0 +68 @@
+          failureInValidation = true
@@ -99,0 +70 @@
+          None
@@ -101,0 +73,66 @@
+      // Attempt to check the project ID if configured to do so
+      if (!failureInValidation && !isProjectIdValid(request.getRequestURI, token.get)) {
+        failureInValidation = true
+        filterDirector.responseHeaderManager.putHeader(OpenStackIdentityV3Headers.WWW_AUTHENTICATE, "Keystone uri=" + identityServiceUri)
+        filterDirector.setFilterAction(FilterAction.RETURN)
+        filterDirector.setResponseStatus(HttpStatusCode.UNAUTHORIZED)
+      }
+
+      // Attempt to authorize the token against a configured endpoint
+      if (!failureInValidation && !isAuthorized(token.get)) {
+        failureInValidation = true
+        filterDirector.setFilterAction(FilterAction.RETURN)
+        filterDirector.setResponseStatus(HttpStatusCode.FORBIDDEN)
+      }
+
+      // Attempt to fetch groups if configured to do so
+      val userGroups = if (!failureInValidation && forwardGroups) {
+        token.get.user.id map { userId =>
+          identityAPI.getGroups(userId) match {
+            case Success(groupsList) =>
+              groupsList.map(_.name)
+            case Failure(e) =>
+              failureInValidation = true
+              LOG.error(e.getMessage)
+              List[String]()
+          }
+        } getOrElse {
+          failureInValidation = true
+          LOG.warn("The X-PP-Groups header could not be populated. The user ID was not present in the token retrieved from Keystone.")
+          List[String]()
+        }
+      } else {
+        List[String]()
+      }
+
+      // If all validation succeeds, pass the request and set headers
+      if (!failureInValidation) {
+        filterDirector.setFilterAction(FilterAction.PASS)
+        
+        // Set the appropriate headers
+        requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_TOKEN_EXPIRES, token.get.expires_at)
+        requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_AUTHORIZATION.toString, OpenStackIdentityV3Headers.X_AUTH_PROXY) // TODO: Add the project ID if verified
+        token.get.user.name.map(requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_USER_NAME.toString, _))
+        token.get.roles.map { roles =>
+          requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_ROLES, roles.map(_.name) mkString ",")
+        }
+        token.get.user.id.map { id =>
+          requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_USER_ID.toString, id)
+          requestHeaderManager.appendHeader(PowerApiHeader.USER.toString, id, 1.0)
+        }
+        token.get.project.map { project =>
+          project.id.map(requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_PROJECT_ID.toString, _))
+          project.name.map(requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_PROJECT_NAME.toString, _))
+        }
+        if (forwardCatalog) {
+          token.get.catalog.map(catalog => requestHeaderManager.putHeader(PowerApiHeader.X_CATALOG.toString, base64Encode(catalog.toJson.compactPrint)))
+        }
+        if (forwardGroups) {
+          userGroups.foreach(group => requestHeaderManager.appendHeader(PowerApiHeader.GROUPS.toString, group + ";q=1.0"))
+        }
+        // TODO: Set X-Impersonator-Name, need to check response for impersonator (out of scope)
+        // TODO: Set X-Impersonator-Id, same as above
+        // TODO: Set X-Default-Region
+      }
+
+      // Forward potentially unauthorized requests if configured to do so, or denote authorized requests
@@ -103 +140 @@
-        if (authSuccess) {
+        if (!failureInValidation) {
@@ -108 +145 @@
-          requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_AUTHORIZATION, OpenStackIdentityV3Headers.X_AUTH_PROXY) // TODO: Add the project ID if verified (not in-scope)
+          requestHeaderManager.putHeader(OpenStackIdentityV3Headers.X_AUTHORIZATION, OpenStackIdentityV3Headers.X_AUTH_PROXY) // TODO: Add the project ID if verified
@@ -189 +226,2 @@
-  private def hasIgnoreEnabledRole(ignoreProjectRoles: List[String], userRoles: List[Role]): Boolean = true
+  private def hasIgnoreEnabledRole(ignoreProjectRoles: List[String], userRoles: List[String]): Boolean =
+    userRoles.exists(userRole => ignoreProjectRoles.exists(ignoreRole => ignoreRole.equals(userRole)))
@@ -191 +229,44 @@
-  private def matchesProject(projectFromUri: String, roles: List[Role]): Boolean = true
+  private def isProjectIdValid(requestUri: String, token: AuthenticateResponse): Boolean = {
+    projectIdUriRegex match {
+      case Some(regex) =>
+        // Check whether or not this user should bypass project ID validation
+        val userRoles = token.roles.getOrElse(List[Role]()).map(_.name)
+        val bypassProjectIdCheck = hasIgnoreEnabledRole(bypassProjectIdCheckRoles.getOrElse(List[String]()), userRoles)
+
+        if (bypassProjectIdCheck) {
+          true
+        } else {
+          // Extract the project ID from the URI
+          val extractedProjectId = extractProjectIdFromUri(regex, requestUri)
+
+          // Bind the default project ID, if available
+          val defaultProjectId = token.project.map(_.id).getOrElse(None)
+
+          // Attempt to match the extracted project ID against the project IDs in the token
+          extractedProjectId match {
+            case Some(projectId) => projectMatches(projectId, defaultProjectId, token.roles.getOrElse(List[Role]()))
+            case None => false
+          }
+        }
+      case None => true
+    }
+  }
+
+  private def extractProjectIdFromUri(projectIdRegex: Regex, uri: String): Option[String] =
+    projectIdRegex.findFirstMatchIn(uri).map(regexMatch => regexMatch.group(1))
+
+  private def projectMatches(projectFromUri: String, defaultProjectId: Option[String], roles: List[Role]): Boolean = {
+    val defaultIdMatches = defaultProjectId.exists(_.equals(projectFromUri))
+    val keystoneRolesIdMatches = roles.exists(role =>
+      role.project_id.exists(rolePID =>
+        rolePID.equals(projectFromUri)
+      )
+    )
+    val raxRolesIdMatches = roles.exists(role =>
+      role.rax_project_id.exists(rolePID =>
+        rolePID.equals(projectFromUri)
+      )
+    )
+
+    defaultIdMatches || keystoneRolesIdMatches || raxRolesIdMatches
+  }
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/json/spray/IdentityJsonProtocol.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/json/spray/IdentityJsonProtocol.scala
index c6a3d7a..b1d1a75 100644
--- a/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/json/spray/IdentityJsonProtocol.scala
+++ b/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/json/spray/IdentityJsonProtocol.scala
@@ -18 +18 @@
-  implicit val roleFormat = jsonFormat5(Role)
+  implicit val roleFormat = jsonFormat(Role, "id", "name", "project_id", "RAX-AUTH:projectId", "domain_id", "description")
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/objects/OpenStackIdentityV3Objects.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/objects/OpenStackIdentityV3Objects.scala
index a03567f..8b34530 100644
--- a/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/objects/OpenStackIdentityV3Objects.scala
+++ b/repose-aggregator/components/filters/openstack-identity-v3/src/main/scala/com/rackspace/papi/components/openstack/identity/v3/objects/OpenStackIdentityV3Objects.scala
@@ -51,0 +52 @@
+                rax_project_id: Option[String] = None,
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com.rackspace.papi.components.openstack.identity.v3/OpenStackIdentityV3HandlerFactoryTest.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com.rackspace.papi.components.openstack.identity.v3/OpenStackIdentityV3HandlerFactoryTest.scala
deleted file mode 100644
index 3acf975..0000000
--- a/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com.rackspace.papi.components.openstack.identity.v3/OpenStackIdentityV3HandlerFactoryTest.scala
+++ /dev/null
@@ -1,51 +0,0 @@
-package com.rackspace.papi.components.openstack.identity.v3
-
-import com.rackspace.papi.components.openstack.identity.v3.config.{OpenstackIdentityService, OpenstackIdentityV3Config}
-import com.rackspace.papi.service.datastore.DatastoreService
-import com.rackspace.papi.service.serviceclient.akka.AkkaServiceClient
-import org.junit.runner.RunWith
-import org.mockito.Mockito.when
-import org.scalatest.junit.JUnitRunner
-import org.scalatest.mock.MockitoSugar
-import org.scalatest.{BeforeAndAfter, FunSpec, Matchers}
-
-@RunWith(classOf[JUnitRunner])
-class OpenStackIdentityV3HandlerFactoryTest extends FunSpec with BeforeAndAfter with Matchers with MockitoSugar {
-
-  var handlerFactory: OpenStackIdentityV3HandlerFactory = _
-
-  val mockAkkaServiceClient = mock[AkkaServiceClient]
-  val mockDatastoreService = mock[DatastoreService]
-
-  before {
-    when(mockDatastoreService.getDefaultDatastore).thenReturn(null)
-
-    handlerFactory = new OpenStackIdentityV3HandlerFactory(mockAkkaServiceClient, mockDatastoreService)
-  }
-
-  describe("buildHandler") {
-    it("should return an OpenStack Identity v3 handler") {
-      val identityService = new OpenstackIdentityService()
-      identityService.setUri("")
-
-      val config = new OpenstackIdentityV3Config()
-      config.setOpenstackIdentityService(identityService)
-      config.setTokenCacheTimeout(0)
-      config.setGroupsCacheTimeout(0)
-      config.setCacheOffset(0)
-      config.setForwardUnauthorizedRequests(false)
-
-      handlerFactory.configurationUpdated(config)
-      handlerFactory.buildHandler shouldBe a[OpenStackIdentityV3Handler]
-    }
-  }
-
-  describe("getListeners") {
-    it("should return a map of listeners one of which listens to the OpenStack Identity configuration file") {
-      val listeners = handlerFactory.getListeners
-
-      listeners should have size 1
-      listeners should contain key classOf[OpenstackIdentityV3Config]
-    }
-  }
-}
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com.rackspace.papi.components.openstack.identity.v3/OpenStackIdentityV3HandlerTest.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com.rackspace.papi.components.openstack.identity.v3/OpenStackIdentityV3HandlerTest.scala
deleted file mode 100644
index 623f794..0000000
--- a/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com.rackspace.papi.components.openstack.identity.v3/OpenStackIdentityV3HandlerTest.scala
+++ /dev/null
@@ -1,249 +0,0 @@
-package com.rackspace.papi.components.openstack.identity.v3
-
-import com.mockrunner.mock.web.{MockHttpServletRequest, MockHttpServletResponse}
-import com.rackspace.papi.commons.util.http.header.HeaderName
-import com.rackspace.papi.commons.util.http.{CommonHttpHeader, HttpStatusCode}
-import com.rackspace.papi.commons.util.servlet.http.{MutableHttpServletResponse, ReadableHttpServletResponse}
-import com.rackspace.papi.components.openstack.identity.v3.config.{OpenstackIdentityService, OpenstackIdentityV3Config, ServiceEndpoint, WhiteList}
-import com.rackspace.papi.components.openstack.identity.v3.objects._
-import com.rackspace.papi.components.openstack.identity.v3.utilities._
-import com.rackspace.papi.filter.logic.{FilterAction, FilterDirector, HeaderManager}
-import org.junit.runner.RunWith
-import org.mockito.Mockito.{verify, when}
-import org.scalatest.junit.JUnitRunner
-import org.scalatest.mock.MockitoSugar
-import org.scalatest.{BeforeAndAfter, FunSpec, Matchers, PrivateMethodTester}
-
-import scala.util.{Failure, Try}
-
-@RunWith(classOf[JUnitRunner])
-class OpenStackIdentityV3HandlerTest extends FunSpec with BeforeAndAfter with Matchers with PrivateMethodTester with MockitoSugar {
-
-  var identityV3Handler: OpenStackIdentityV3Handler = _
-  var identityConfig: OpenstackIdentityV3Config = _
-  var identityAPI: OpenStackIdentityV3API = _
-
-  before {
-    identityConfig = new OpenstackIdentityV3Config()
-    identityConfig.setOpenstackIdentityService(new OpenstackIdentityService())
-    identityConfig.getOpenstackIdentityService.setUsername("user")
-    identityConfig.getOpenstackIdentityService.setPassword("password")
-    identityConfig.getOpenstackIdentityService.setUri("http://test-uri.com")
-    identityConfig.setServiceEndpoint(new ServiceEndpoint())
-    identityConfig.getServiceEndpoint.setUrl("http://www.notreallyawebsite.com")
-    identityAPI = mock[OpenStackIdentityV3API]
-
-    identityV3Handler = new OpenStackIdentityV3Handler(identityConfig, identityAPI)
-  }
-
-  describe("handleRequest") {
-    val mockServletResponse = mock[ReadableHttpServletResponse]
-
-    it("should pass filter if uri is in the whitelist") {
-      val whiteList = new WhiteList()
-      whiteList.getUriPattern.add("/test1")
-      whiteList.getUriPattern.add("/test2")
-      identityConfig.setWhiteList(whiteList)
-
-      val mockRequest = new MockHttpServletRequest()
-      mockRequest.setRequestURI("/test1")
-
-      identityV3Handler.handleRequest(mockRequest, mockServletResponse).getFilterAction should be theSameInstanceAs FilterAction.PASS
-    }
-
-    it("should attempt validation if uri isn't in the whitelist") {
-      val whiteList = new WhiteList()
-      whiteList.getUriPattern.add("/test1")
-      whiteList.getUriPattern.add("/test2")
-      identityConfig.setWhiteList(whiteList)
-
-      val mockRequest = new MockHttpServletRequest()
-      mockRequest.setRequestURI("/test3")
-
-      identityV3Handler.handleRequest(mockRequest, mockServletResponse).getFilterAction should be theSameInstanceAs FilterAction.RETURN
-      identityV3Handler.handleRequest(mockRequest, mockServletResponse).getResponseStatus should be theSameInstanceAs HttpStatusCode.UNAUTHORIZED
-    }
-  }
-
-  describe("handleResponse") {
-    // TODO: Get this to work, or make it a system level test
-    ignore("should set the appropriate response status") {
-      val mockServletRequest = new MockHttpServletRequest()
-      val mockServletResponse = new MockHttpServletResponse()
-
-      val responseStatus = "response-status-key"
-      val responseWwwAuthenticate = "response-www-authenticate"
-      val resultStatus = "result-status"
-      val resultWwwAuthenticate = "result-www-authenticate"
-
-      List(
-        Map(
-          responseStatus -> HttpStatusCode.OK,
-          resultStatus -> HttpStatusCode.OK
-        ),
-        Map(
-          responseStatus -> HttpStatusCode.FORBIDDEN,
-          responseWwwAuthenticate -> OpenStackIdentityV3Headers.X_DELEGATED,
-          resultStatus -> HttpStatusCode.FORBIDDEN,
-          resultWwwAuthenticate -> "Keystone uri=http://test-uri.com"
-        ),
-        Map(
-          responseStatus -> HttpStatusCode.UNAUTHORIZED,
-          responseWwwAuthenticate -> OpenStackIdentityV3Headers.X_DELEGATED,
-          resultStatus -> HttpStatusCode.FORBIDDEN,
-          resultWwwAuthenticate -> "Keystone uri=http://test-uri.com"
-        ),
-        Map(
-          responseStatus -> HttpStatusCode.UNAUTHORIZED,
-          resultStatus -> HttpStatusCode.INTERNAL_SERVER_ERROR
-        ),
-        Map(
-          responseStatus -> HttpStatusCode.NOT_IMPLEMENTED,
-          responseWwwAuthenticate -> OpenStackIdentityV3Headers.X_DELEGATED,
-          resultStatus -> HttpStatusCode.INTERNAL_SERVER_ERROR
-        ),
-        Map(
-          responseStatus -> HttpStatusCode.NOT_IMPLEMENTED,
-          resultStatus -> HttpStatusCode.NOT_IMPLEMENTED
-        )
-      ).map { parameterMap =>
-        mockServletResponse.setStatus(parameterMap.get(responseStatus).get.asInstanceOf[HttpStatusCode].intValue)
-        if (parameterMap.get(responseWwwAuthenticate).isDefined) {
-          mockServletResponse.addHeader(CommonHttpHeader.WWW_AUTHENTICATE.toString, parameterMap.get(responseWwwAuthenticate).get.asInstanceOf[String])
-        }
-
-        val responseFilterDirector = identityV3Handler.handleResponse(mockServletRequest, MutableHttpServletResponse.wrap(mockServletRequest, mockServletResponse))
-
-        responseFilterDirector.getResponseStatus shouldBe parameterMap.get(resultStatus).get
-        if (parameterMap.get(resultWwwAuthenticate).isDefined) {
-          responseFilterDirector.responseHeaderManager().headersToAdd().get(HeaderName.wrap(CommonHttpHeader.WWW_AUTHENTICATE.toString)) should contain(parameterMap.get(resultWwwAuthenticate).get)
-        }
-      }
-    }
-  }
-
-  describe("authenticate") {
-    val authenticate = PrivateMethod[Try[AuthenticateResponse]]('authenticate)
-
-    it("should return a Failure when the x-subject-token header is not present") {
-      val mockRequest = new MockHttpServletRequest()
-
-      identityV3Handler invokePrivate authenticate(mockRequest) shouldBe a[Failure[_]]
-      an[InvalidSubjectTokenException] should be thrownBy identityV3Handler.invokePrivate(authenticate(mockRequest)).get
-    }
-  }
-
-  describe("writeProjectHeader") {
-    val writeProjectHeader = PrivateMethod[Unit]('writeProjectHeader)
-    val filterDirector = mock[FilterDirector]
-    val headerManager = mock[HeaderManager]
-    when(filterDirector.requestHeaderManager()).thenReturn(headerManager)
-    val roles = List(Role(null, null, Option("12345"), null, null), Role(null, null, Option("67890"), null, null))
-
-    it("should only provide the url project when the flag says to not write all") {
-      identityV3Handler invokePrivate writeProjectHeader("abcde", roles, false, filterDirector)
-      verify(headerManager).appendHeader(org.mockito.Matchers.eq("X-PROJECT-ID"), org.mockito.Matchers.eq("abcde"))
-    }
-
-    it("should provide all the projects when the flag says to write all") {
-      identityV3Handler invokePrivate writeProjectHeader("abcde", roles, true, filterDirector)
-      verify(headerManager).appendHeader(org.mockito.Matchers.eq("X-PROJECT-ID"), org.mockito.Matchers.eq("12345"), org.mockito.Matchers.eq("67890"), org.mockito.Matchers.eq("abcde"))
-    }
-  }
-
-  describe("containsRequiredEndpoint") {
-    val containsRequiredEndpoint = PrivateMethod[Boolean]('containsRequiredEndpoint)
-
-    it("should return true when there is an endpoint that matches the url") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")),
-        Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")
-      ) should be(true)
-    }
-
-    it("should return false when there isn't an endpoint that matches the url") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, None, None, "http://www.banana.com")),
-        Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")
-      ) should be(false)
-    }
-
-    it("Should return true when the url matches and region does") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, null, Option("DFW"), "http://www.notreallyawebsite.com")),
-        Endpoint(null, None, None, Option("DFW"), "http://www.notreallyawebsite.com")
-      ) should be(true)
-    }
-
-    it("Should return false when the url matches and region doesn't") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")),
-        Endpoint(null, None, None, Option("DFW"), "http://www.notreallyawebsite.com")
-      ) should be(false)
-    }
-
-    it("Should return true when the url matches and name does") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("foo"), None, Option("DFW"), "http://www.notreallyawebsite.com")),
-        Endpoint(null, Option("foo"), None, None, "http://www.notreallyawebsite.com")
-      ) should be(true)
-    }
-
-    it("Should return false when the url matches and name doesn't") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("bar"), null, None, "http://www.notreallyawebsite.com")),
-        Endpoint(null, Option("foo"), None, None, "http://www.notreallyawebsite.com")
-      ) should be(false)
-    }
-
-    it("Should return true when the url matches and interface does") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("foo"), Option("foo"), Option("DFW"), "http://www.notreallyawebsite.com")),
-        Endpoint(null, None, Option("foo"), None, "http://www.notreallyawebsite.com")
-      ) should be(true)
-    }
-
-    it("Should return false when the url matches and interface doesn't") {
-      identityV3Handler invokePrivate containsRequiredEndpoint(
-        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("bar"), None, None, "http://www.notreallyawebsite.com")),
-        Endpoint(null, None, Option("foo"), None, "http://www.notreallyawebsite.com")
-      ) should be(false)
-    }
-  }
-
-  describe("authorize") {
-    val isAuthorized = PrivateMethod[Boolean]('isAuthorized)
-
-    it("should return true when not configured to check endpoints") {
-      val config = new OpenstackIdentityV3Config()
-      config.setOpenstackIdentityService(new OpenstackIdentityService())
-      config.getOpenstackIdentityService.setUri("")
-
-      val handler = new OpenStackIdentityV3Handler(config, identityAPI)
-
-      handler invokePrivate isAuthorized(AuthenticateResponse(null, null, null, null, null, null, null, null)) should be(true)
-    }
-
-    it("should return true when configured and the endpoint is present") {
-      val catalog = List(ServiceForAuthenticationResponse(List(Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")), null, null))
-      val authToken = AuthenticateResponse(null, null, null, null, null, Option(catalog), null, null)
-
-      identityV3Handler invokePrivate isAuthorized(authToken) should be(true)
-    }
-
-    it("should return false when configured and the endpoint is not present") {
-      val catalog = List(ServiceForAuthenticationResponse(List(Endpoint(null, None, None, None, "http://www.woot.com")), null, null))
-      val authToken = AuthenticateResponse(null, null, null, null, null, Option(catalog), null, null)
-
-      identityV3Handler invokePrivate isAuthorized(authToken) should be(false)
-    }
-  }
-
-  describe("base64Encode") {
-    val base64Encode = PrivateMethod[String]('base64Encode)
-
-    it("should return a base64 encoded string") {
-      identityV3Handler invokePrivate base64Encode("{\"endpoints\":[\"endpoint\":{\"id\":\"test-id\",\"url\":\"http://test-url.com/test\"}]}") should fullyMatch regex "eyJlbmRwb2ludHMiOlsiZW5kcG9pbnQiOnsiaWQiOiJ0ZXN0LWlkIiwidXJsIjoiaHR0cDovL3Rlc3QtdXJsLmNvbS90ZXN0In1dfQ=="
-    }
-  }
-}
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3HandlerFactoryTest.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3HandlerFactoryTest.scala
new file mode 100644
index 0000000..3acf975
--- /dev/null
+++ b/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3HandlerFactoryTest.scala
@@ -0,0 +1,51 @@
+package com.rackspace.papi.components.openstack.identity.v3
+
+import com.rackspace.papi.components.openstack.identity.v3.config.{OpenstackIdentityService, OpenstackIdentityV3Config}
+import com.rackspace.papi.service.datastore.DatastoreService
+import com.rackspace.papi.service.serviceclient.akka.AkkaServiceClient
+import org.junit.runner.RunWith
+import org.mockito.Mockito.when
+import org.scalatest.junit.JUnitRunner
+import org.scalatest.mock.MockitoSugar
+import org.scalatest.{BeforeAndAfter, FunSpec, Matchers}
+
+@RunWith(classOf[JUnitRunner])
+class OpenStackIdentityV3HandlerFactoryTest extends FunSpec with BeforeAndAfter with Matchers with MockitoSugar {
+
+  var handlerFactory: OpenStackIdentityV3HandlerFactory = _
+
+  val mockAkkaServiceClient = mock[AkkaServiceClient]
+  val mockDatastoreService = mock[DatastoreService]
+
+  before {
+    when(mockDatastoreService.getDefaultDatastore).thenReturn(null)
+
+    handlerFactory = new OpenStackIdentityV3HandlerFactory(mockAkkaServiceClient, mockDatastoreService)
+  }
+
+  describe("buildHandler") {
+    it("should return an OpenStack Identity v3 handler") {
+      val identityService = new OpenstackIdentityService()
+      identityService.setUri("")
+
+      val config = new OpenstackIdentityV3Config()
+      config.setOpenstackIdentityService(identityService)
+      config.setTokenCacheTimeout(0)
+      config.setGroupsCacheTimeout(0)
+      config.setCacheOffset(0)
+      config.setForwardUnauthorizedRequests(false)
+
+      handlerFactory.configurationUpdated(config)
+      handlerFactory.buildHandler shouldBe a[OpenStackIdentityV3Handler]
+    }
+  }
+
+  describe("getListeners") {
+    it("should return a map of listeners one of which listens to the OpenStack Identity configuration file") {
+      val listeners = handlerFactory.getListeners
+
+      listeners should have size 1
+      listeners should contain key classOf[OpenstackIdentityV3Config]
+    }
+  }
+}
diff --git a/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3HandlerTest.scala b/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3HandlerTest.scala
new file mode 100644
index 0000000..85935ff
--- /dev/null
+++ b/repose-aggregator/components/filters/openstack-identity-v3/src/test/scala/com/rackspace/papi/components/openstack/identity/v3/OpenStackIdentityV3HandlerTest.scala
@@ -0,0 +1,327 @@
+package com.rackspace.papi.components.openstack.identity.v3
+
+import com.mockrunner.mock.web.{MockHttpServletRequest, MockHttpServletResponse}
+import com.rackspace.papi.commons.util.http.header.HeaderName
+import com.rackspace.papi.commons.util.http.{CommonHttpHeader, HttpStatusCode}
+import com.rackspace.papi.commons.util.servlet.http.{MutableHttpServletResponse, ReadableHttpServletResponse}
+import com.rackspace.papi.components.openstack.identity.v3.config._
+import com.rackspace.papi.components.openstack.identity.v3.objects._
+import com.rackspace.papi.components.openstack.identity.v3.utilities._
+import com.rackspace.papi.filter.logic.{FilterAction, FilterDirector, HeaderManager}
+import org.junit.runner.RunWith
+import org.mockito.Mockito.{verify, when}
+import org.scalatest.junit.JUnitRunner
+import org.scalatest.mock.MockitoSugar
+import org.scalatest.{BeforeAndAfter, FunSpec, Matchers, PrivateMethodTester}
+
+import scala.util.{Failure, Try}
+
+@RunWith(classOf[JUnitRunner])
+class OpenStackIdentityV3HandlerTest extends FunSpec with BeforeAndAfter with Matchers with PrivateMethodTester with MockitoSugar {
+
+  var identityV3Handler: OpenStackIdentityV3Handler = _
+  var identityConfig: OpenstackIdentityV3Config = _
+  var identityAPI: OpenStackIdentityV3API = _
+
+  before {
+    identityConfig = new OpenstackIdentityV3Config()
+    identityConfig.setOpenstackIdentityService(new OpenstackIdentityService())
+    identityConfig.getOpenstackIdentityService.setUsername("user")
+    identityConfig.getOpenstackIdentityService.setPassword("password")
+    identityConfig.getOpenstackIdentityService.setUri("http://test-uri.com")
+    identityConfig.setServiceEndpoint(new ServiceEndpoint())
+    identityConfig.getServiceEndpoint.setUrl("http://www.notreallyawebsite.com")
+    identityConfig.setValidateProjectIdInUri(new ValidateProjectID())
+    identityConfig.getValidateProjectIdInUri.setRegex("""/foo/(\d+)""")
+    identityConfig.setRolesWhichBypassProjectIdCheck(new IgnoreProjectIDRoles())
+    identityConfig.getRolesWhichBypassProjectIdCheck.getRole.add("admin")
+    identityAPI = mock[OpenStackIdentityV3API]
+
+    identityV3Handler = new OpenStackIdentityV3Handler(identityConfig, identityAPI)
+  }
+
+  describe("handleRequest") {
+    val mockServletResponse = mock[ReadableHttpServletResponse]
+
+    it("should pass filter if uri is in the whitelist") {
+      val whiteList = new WhiteList()
+      whiteList.getUriPattern.add("/test1")
+      whiteList.getUriPattern.add("/test2")
+      identityConfig.setWhiteList(whiteList)
+
+      val mockRequest = new MockHttpServletRequest()
+      mockRequest.setRequestURI("/test1")
+
+      identityV3Handler.handleRequest(mockRequest, mockServletResponse).getFilterAction equals FilterAction.PASS
+    }
+
+    it("should attempt validation if uri isn't in the whitelist") {
+      val whiteList = new WhiteList()
+      whiteList.getUriPattern.add("/test1")
+      whiteList.getUriPattern.add("/test2")
+      identityConfig.setWhiteList(whiteList)
+
+      val mockRequest = new MockHttpServletRequest()
+      mockRequest.setRequestURI("/test3")
+
+      identityV3Handler.handleRequest(mockRequest, mockServletResponse).getFilterAction equals FilterAction.RETURN
+      identityV3Handler.handleRequest(mockRequest, mockServletResponse).getResponseStatus equals HttpStatusCode.UNAUTHORIZED
+    }
+  }
+
+  describe("handleResponse") {
+    // TODO: Get this to work, or make it a system level test
+    ignore("should set the appropriate response status") {
+      val mockServletRequest = new MockHttpServletRequest()
+      val mockServletResponse = new MockHttpServletResponse()
+
+      val responseStatus = "response-status-key"
+      val responseWwwAuthenticate = "response-www-authenticate"
+      val resultStatus = "result-status"
+      val resultWwwAuthenticate = "result-www-authenticate"
+
+      List(
+        Map(
+          responseStatus -> HttpStatusCode.OK,
+          resultStatus -> HttpStatusCode.OK
+        ),
+        Map(
+          responseStatus -> HttpStatusCode.FORBIDDEN,
+          responseWwwAuthenticate -> OpenStackIdentityV3Headers.X_DELEGATED,
+          resultStatus -> HttpStatusCode.FORBIDDEN,
+          resultWwwAuthenticate -> "Keystone uri=http://test-uri.com"
+        ),
+        Map(
+          responseStatus -> HttpStatusCode.UNAUTHORIZED,
+          responseWwwAuthenticate -> OpenStackIdentityV3Headers.X_DELEGATED,
+          resultStatus -> HttpStatusCode.FORBIDDEN,
+          resultWwwAuthenticate -> "Keystone uri=http://test-uri.com"
+        ),
+        Map(
+          responseStatus -> HttpStatusCode.UNAUTHORIZED,
+          resultStatus -> HttpStatusCode.INTERNAL_SERVER_ERROR
+        ),
+        Map(
+          responseStatus -> HttpStatusCode.NOT_IMPLEMENTED,
+          responseWwwAuthenticate -> OpenStackIdentityV3Headers.X_DELEGATED,
+          resultStatus -> HttpStatusCode.INTERNAL_SERVER_ERROR
+        ),
+        Map(
+          responseStatus -> HttpStatusCode.NOT_IMPLEMENTED,
+          resultStatus -> HttpStatusCode.NOT_IMPLEMENTED
+        )
+      ).map { parameterMap =>
+        mockServletResponse.setStatus(parameterMap.get(responseStatus).get.asInstanceOf[HttpStatusCode].intValue)
+        if (parameterMap.get(responseWwwAuthenticate).isDefined) {
+          mockServletResponse.addHeader(CommonHttpHeader.WWW_AUTHENTICATE.toString, parameterMap.get(responseWwwAuthenticate).get.asInstanceOf[String])
+        }
+
+        val responseFilterDirector = identityV3Handler.handleResponse(mockServletRequest, MutableHttpServletResponse.wrap(mockServletRequest, mockServletResponse))
+
+        responseFilterDirector.getResponseStatus shouldBe parameterMap.get(resultStatus).get
+        if (parameterMap.get(resultWwwAuthenticate).isDefined) {
+          responseFilterDirector.responseHeaderManager().headersToAdd().get(HeaderName.wrap(CommonHttpHeader.WWW_AUTHENTICATE.toString)) should contain(parameterMap.get(resultWwwAuthenticate).get)
+        }
+      }
+    }
+  }
+
+  describe("authenticate") {
+    val authenticate = PrivateMethod[Try[AuthenticateResponse]]('authenticate)
+
+    it("should return a Failure when the x-subject-token header is not present") {
+      val mockRequest = new MockHttpServletRequest()
+
+      identityV3Handler invokePrivate authenticate(mockRequest) shouldBe a[Failure[_]]
+      an[InvalidSubjectTokenException] should be thrownBy identityV3Handler.invokePrivate(authenticate(mockRequest)).get
+    }
+  }
+
+  describe("writeProjectHeader") {
+    val writeProjectHeader = PrivateMethod[Unit]('writeProjectHeader)
+    val filterDirector = mock[FilterDirector]
+    val headerManager = mock[HeaderManager]
+    when(filterDirector.requestHeaderManager()).thenReturn(headerManager)
+    val roles = List(Role(null, null, Option("12345"), null, null), Role(null, null, Option("67890"), null, null))
+
+    it("should only provide the url project when the flag says to not write all") {
+      identityV3Handler invokePrivate writeProjectHeader("abcde", roles, false, filterDirector)
+      verify(headerManager).appendHeader(org.mockito.Matchers.eq("X-PROJECT-ID"), org.mockito.Matchers.eq("abcde"))
+    }
+
+    it("should provide all the projects when the flag says to write all") {
+      identityV3Handler invokePrivate writeProjectHeader("abcde", roles, true, filterDirector)
+      verify(headerManager).appendHeader(org.mockito.Matchers.eq("X-PROJECT-ID"), org.mockito.Matchers.eq("12345"), org.mockito.Matchers.eq("67890"), org.mockito.Matchers.eq("abcde"))
+    }
+  }
+
+  describe("containsRequiredEndpoint") {
+    val containsRequiredEndpoint = PrivateMethod[Boolean]('containsRequiredEndpoint)
+
+    it("should return true when there is an endpoint that matches the url") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")),
+        Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")
+      ) should be(true)
+    }
+
+    it("should return false when there isn't an endpoint that matches the url") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, None, None, "http://www.banana.com")),
+        Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")
+      ) should be(false)
+    }
+
+    it("Should return true when the url matches and region does") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, null, Option("DFW"), "http://www.notreallyawebsite.com")),
+        Endpoint(null, None, None, Option("DFW"), "http://www.notreallyawebsite.com")
+      ) should be(true)
+    }
+
+    it("Should return false when the url matches and region doesn't") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")),
+        Endpoint(null, None, None, Option("DFW"), "http://www.notreallyawebsite.com")
+      ) should be(false)
+    }
+
+    it("Should return true when the url matches and name does") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("foo"), None, Option("DFW"), "http://www.notreallyawebsite.com")),
+        Endpoint(null, Option("foo"), None, None, "http://www.notreallyawebsite.com")
+      ) should be(true)
+    }
+
+    it("Should return false when the url matches and name doesn't") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("bar"), null, None, "http://www.notreallyawebsite.com")),
+        Endpoint(null, Option("foo"), None, None, "http://www.notreallyawebsite.com")
+      ) should be(false)
+    }
+
+    it("Should return true when the url matches and interface does") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("foo"), Option("foo"), Option("DFW"), "http://www.notreallyawebsite.com")),
+        Endpoint(null, None, Option("foo"), None, "http://www.notreallyawebsite.com")
+      ) should be(true)
+    }
+
+    it("Should return false when the url matches and interface doesn't") {
+      identityV3Handler invokePrivate containsRequiredEndpoint(
+        List(Endpoint(null, None, None, None, "http://www.woot.com"), Endpoint(null, Option("bar"), None, None, "http://www.notreallyawebsite.com")),
+        Endpoint(null, None, Option("foo"), None, "http://www.notreallyawebsite.com")
+      ) should be(false)
+    }
+  }
+
+  describe("isAuthorized") {
+    val isAuthorized = PrivateMethod[Boolean]('isAuthorized)
+
+    it("should return true when not configured to check endpoints") {
+      val config = new OpenstackIdentityV3Config()
+      config.setOpenstackIdentityService(new OpenstackIdentityService())
+      config.getOpenstackIdentityService.setUri("")
+
+      val handler = new OpenStackIdentityV3Handler(config, identityAPI)
+
+      handler invokePrivate isAuthorized(AuthenticateResponse(null, null, null, null, null, null, null, null)) should be(true)
+    }
+
+    it("should return true when configured and the endpoint is present") {
+      val catalog = List(ServiceForAuthenticationResponse(List(Endpoint(null, None, None, None, "http://www.notreallyawebsite.com")), null, null))
+      val authToken = AuthenticateResponse(null, null, null, null, null, Option(catalog), null, null)
+
+      identityV3Handler invokePrivate isAuthorized(authToken) should be(true)
+    }
+
+    it("should return false when configured and the endpoint is not present") {
+      val catalog = List(ServiceForAuthenticationResponse(List(Endpoint(null, None, None, None, "http://www.woot.com")), null, null))
+      val authToken = AuthenticateResponse(null, null, null, null, null, Option(catalog), null, null)
+
+      identityV3Handler invokePrivate isAuthorized(authToken) should be(false)
+    }
+  }
+
+  describe("base64Encode") {
+    val base64Encode = PrivateMethod[String]('base64Encode)
+
+    it("should return a base64 encoded string") {
+      identityV3Handler invokePrivate base64Encode("{\"endpoints\":[\"endpoint\":{\"id\":\"test-id\",\"url\":\"http://test-url.com/test\"}]}") should fullyMatch regex "eyJlbmRwb2ludHMiOlsiZW5kcG9pbnQiOnsiaWQiOiJ0ZXN0LWlkIiwidXJsIjoiaHR0cDovL3Rlc3QtdXJsLmNvbS90ZXN0In1dfQ=="
+    }
+  }
+
+  describe("isProjectIdValid") {
+    val isProjectIdValid = PrivateMethod[Boolean]('isProjectIdValid)
+
+    it("should return true if no validate project id in uri config element is present") {
+      val config = new OpenstackIdentityV3Config()
+      config.setOpenstackIdentityService(new OpenstackIdentityService())
+      config.getOpenstackIdentityService.setUri("")
+
+      val handler = new OpenStackIdentityV3Handler(config, identityAPI)
+
+      handler invokePrivate isProjectIdValid("", AuthenticateResponse(null, null, null, null, null, null, null, null)) shouldBe true
+    }
+
+    it("should return true if the user had a role which bypasses validation") {
+      identityV3Handler invokePrivate isProjectIdValid("", AuthenticateResponse(null, null, null, None, None, None, Some(List(Role("12345", "admin"))), null)) shouldBe true
+    }
+
+    it("should return false if no a project ID could not be extracted from the URI") {
+      identityV3Handler invokePrivate isProjectIdValid("/foo/bar", AuthenticateResponse(null, null, null, None, None, None, None, null)) shouldBe false
+    }
+  }
+
+  describe("extractProjectIdFromUri") {
+    val extractProjectIdFromUri = PrivateMethod[Option[String]]('extractProjectIdFromUri)
+
+    it("should return None if the regex does not match") {
+      identityV3Handler invokePrivate extractProjectIdFromUri("""/foo/(\d+)""".r, "/bar/12345") shouldBe None
+    }
+
+    it("should return None if the regex does not contain a capture group") {
+      identityV3Handler invokePrivate extractProjectIdFromUri("""/foo/\d+""".r, "/bar/12345") shouldBe None
+    }
+
+    it("should return Some(projectId) if the regex matches and a capture group is present") {
+      val projectId = identityV3Handler invokePrivate extractProjectIdFromUri("""/foo/(\d+)""".r, "/foo/12345")
+      projectId shouldBe a[Some[_]]
+      projectId.get shouldEqual "12345"
+    }
+  }
+
+  describe("projectMatches") {
+    val projectMatches = PrivateMethod[Boolean]('projectMatches)
+
+    it("should return false if no project IDs match") {
+      identityV3Handler invokePrivate projectMatches("12345", Some("09876"), List(Role("id", "name", Some("09876")))) shouldBe false
+    }
+
+    it("should return true if the default project ID matches") {
+      identityV3Handler invokePrivate projectMatches("12345", Some("12345"), List(Role("id", "name", Some("09876")))) shouldBe true
+    }
+
+    it("should return true if a role project ID matches") {
+      identityV3Handler invokePrivate projectMatches("12345", Some("09876"), List(Role("id", "name", Some("12345")))) shouldBe true
+    }
+  }
+
+  describe("hasIgnoreEnabledRole") {
+    val hasIgnoreEnabledRole = PrivateMethod[Boolean]('hasIgnoreEnabledRole)
+
+    it("should return false if the user does not have a role which is in the bypass roles list") {
+      val ignoreRoles = List("a", "b", "c")
+      val userRoles = List("d", "e")
+
+      identityV3Handler invokePrivate hasIgnoreEnabledRole(ignoreRoles, userRoles) shouldBe false
+    }
+
+    it("should return true if the user does have a role which is in the bypass roles list") {
+      val ignoreRoles = List("a", "b", "c")
+      val userRoles = List("a", "e")
+
+      identityV3Handler invokePrivate hasIgnoreEnabledRole(ignoreRoles, userRoles) shouldBe true
+    }
+  }
+}
diff --git a/repose-aggregator/components/filters/pom.xml b/repose-aggregator/components/filters/pom.xml
index 035a603..6d506bb 100644
--- a/repose-aggregator/components/filters/pom.xml
+++ b/repose-aggregator/components/filters/pom.xml
@@ -37,0 +38 @@
+        <module>rackspace-identity-basic-auth</module>
@@ -244,0 +246,6 @@
+
+            <dependency>
+                <groupId>com.rackspace.papi.components</groupId>
+                <artifactId>rackspace-identity-basic-auth</artifactId>
+                <version>${project.version}</version>
+            </dependency>
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/pom.xml b/repose-aggregator/components/filters/rackspace-identity-basic-auth/pom.xml
new file mode 100644
index 0000000..371808c
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/pom.xml
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>com.rackspace.papi.components</groupId>
+        <artifactId>filters-support</artifactId>
+        <version>6.1.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>rackspace-identity-basic-auth</artifactId>
+
+    <name>Repose Components - Rackspace Identity Basic Auth</name>
+    <description>
+        This filter translates user requests from Basic Auth to the Rackspace Identity.
+    </description>
+
+    <packaging>jar</packaging>
+
+    <properties>
+        <sonar.jacoco.itReportPath>${project.basedir}/../../../target/jacoco-it.exec</sonar.jacoco.itReportPath>
+    </properties>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.scalatest</groupId>
+            <artifactId>scalatest_2.10</artifactId>
+        </dependency>
+
+        <!-- Mockrunner for mock HttpServletRequest -->
+        <dependency>
+            <groupId>com.mockrunner</groupId>
+            <artifactId>mockrunner-servlet</artifactId>
+            <version>1.0.0</version>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- These three are required because of our coupling between filters and core -->
+        <dependency>
+            <groupId>com.rackspace.papi.core</groupId>
+            <artifactId>core-lib</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.rackspace.papi.commons</groupId>
+            <artifactId>configuration</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.rackspace.papi.commons</groupId>
+            <artifactId>utilities</artifactId>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <!-- The plugin that gets Scala running -->
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+            </plugin>
+
+            <!-- The plugin that cleans up our XSD to conform to XML 1.0 -->
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>xml-maven-plugin</artifactId>
+                <configuration>
+                    <transformationSets>
+                        <transformationSet>
+                            <dir>src/main/resources/META-INF/config/schema</dir>
+                            <stylesheet>../xsl/remove-1.1-elements.xsl</stylesheet>
+                            <outputDir>${project.build.directory}/generated-resources/xml/xslt/config</outputDir>
+                        </transformationSet>
+                    </transformationSets>
+                </configuration>
+            </plugin>
+
+            <!-- The plugin that compiles and binds our clean XSD to a Java object -->
+            <plugin>
+                <groupId>org.jvnet.jaxb2.maven2</groupId>
+                <artifactId>maven-jaxb2-plugin</artifactId>
+                <configuration>
+                    <specVersion>2.2</specVersion>
+                    <schemaDirectory>${project.build.directory}/generated-resources/xml/xslt</schemaDirectory>
+
+                    <schemaIncludes>
+                        <include>**/*.xsd</include>
+                    </schemaIncludes>
+                    <bindingIncludes>
+                        <include>**/*.xjb</include>
+                    </bindingIncludes>
+
+                    <strict>true</strict>
+                    <verbose>false</verbose>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+</project>
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/examples/rackspace-identity-basic-auth.cfg.xml b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/examples/rackspace-identity-basic-auth.cfg.xml
new file mode 100644
index 0000000..1139ae6
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/examples/rackspace-identity-basic-auth.cfg.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<rackspace-identity-basic-auth
+        xmlns="http://docs.openrepose.org/rackspace-identity-basic-auth/v1.0"
+        rackspace-identity-service-uri="http://identity.example.com:8080/v2.0/tokens"
+        token-cache-timeout-millis="600000"/>
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/schema/bindings.xjb b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/schema/bindings.xjb
new file mode 100644
index 0000000..86da7bc
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/schema/bindings.xjb
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<bindings xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+          version="2.0"
+          xmlns="http://java.sun.com/xml/ns/jaxb"
+          xsi:schemaLocation="http://java.sun.com/xml/ns/jaxb http://java.sun.com/xml/ns/jaxb/bindingschema_2_0.xsd"
+          schemaLocation="rackspace-identity-basic-auth.xsd">
+
+    <schemaBindings>
+        <package name="com.rackspace.papi.components.rackspace.identity.basicauth.config"/>
+    </schemaBindings>
+</bindings>
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/schema/rackspace-identity-basic-auth.xsd b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/schema/rackspace-identity-basic-auth.xsd
new file mode 100644
index 0000000..909d38d
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/resources/META-INF/config/schema/rackspace-identity-basic-auth.xsd
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
+           xmlns:html="http://www.w3.org/1999/xhtml"
+           xmlns="http://docs.openrepose.org/rackspace-identity-basic-auth/v1.0"
+           targetNamespace="http://docs.openrepose.org/rackspace-identity-basic-auth/v1.0"
+           elementFormDefault="qualified"
+           attributeFormDefault="unqualified">
+
+    <!-- Elements -->
+    <xs:element name="rackspace-identity-basic-auth" type="RackspaceIdentityBasicAuthConfig"/>
+
+    <!-- Types -->
+    <xs:complexType name="RackspaceIdentityBasicAuthConfig">
+        <xs:annotation>
+            <xs:documentation>
+                <html:p>The root config type for the Rackspace Identity Basic Auth filter configuration file.</html:p>
+            </xs:documentation>
+        </xs:annotation>
+
+        <xs:attribute name="rackspace-identity-service-uri" type="xs:anyURI" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    <html:p>The target Rackspace Identity endpoint URI for credential requests including host, port, and path to service.</html:p>
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="token-cache-timeout-millis" type="ZeroOrPositiveInteger" use="optional" default="600000">
+            <xs:annotation>
+                <xs:documentation>
+                    <html:p>Time in milliseconds to cache auth token. The default is 10 minutes. A value of Zero (0) is disabled.</html:p>
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:simpleType name="ZeroOrPositiveInteger">
+        <xs:restriction base="xs:int">
+            <xs:minInclusive value="0"/>
+        </xs:restriction>
+    </xs:simpleType>
+</xs:schema>
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/BasicAuthUtils.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/BasicAuthUtils.scala
new file mode 100644
index 0000000..230f487
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/BasicAuthUtils.scala
@@ -0,0 +1,31 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import org.apache.commons.codec.binary.Base64
+
+import scala.collection.JavaConverters
+
+object BasicAuthUtils {
+  /**
+   * Returns a tuple of the (username, API Key) retrieved from an HTTP Basic authentication header (Authorization) that
+   * has already been stripped of the "Basic " auth method identifier.
+   * @param decoded the cleaned header value to be decoded and split
+   * @return a tuple of the (username, API Key)
+   */
+  def extractCredentials(authValue: String): (String, String) = {
+    val decodedString = new String(Base64.decodeBase64(authValue))
+    val username = decodedString.split(":").head
+    val password = decodedString.replace(s"$username:", "")
+    (username, password)
+  }
+
+  /**
+   * Returns an Iterator of the Authentication header values that match the desired auth method.
+   * @param optionHeaders the Authentication header values to search
+   * @param method the auth method to search for
+   * @return an Iterator of the Authentication header values that match the desired auth method
+   */
+  def getBasicAuthHeaders(headers: java.util.Enumeration[String], method: String): Iterator[String] = {
+      import scala.collection.JavaConverters._
+      headers.asScala.filter(_.toUpperCase.startsWith(method.toUpperCase()))
+  }
+}
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthFilter.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthFilter.scala
new file mode 100644
index 0000000..589ca27
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthFilter.scala
@@ -0,0 +1,46 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import java.net.URL
+import javax.servlet._
+
+import com.rackspace.papi.commons.config.manager.UpdateListener
+import com.rackspace.papi.components.rackspace.identity.basicauth.config.RackspaceIdentityBasicAuthConfig
+import com.rackspace.papi.filter.FilterConfigHelper
+import com.rackspace.papi.filter.logic.impl.FilterLogicHandlerDelegate
+import com.rackspace.papi.service.config.ConfigurationService
+import com.rackspace.papi.service.context.ServletContextHelper
+import org.slf4j.LoggerFactory
+
+class RackspaceIdentityBasicAuthFilter extends Filter {
+  private final val LOG = LoggerFactory.getLogger(classOf[RackspaceIdentityBasicAuthFilter])
+  private final val DEFAULT_CONFIG = "rackspace-identity-basic-auth.cfg.xml"
+
+  private var config: String = _
+  private var handlerFactory: RackspaceIdentityBasicAuthHandlerFactory = _
+  private var configurationService: ConfigurationService = _
+
+  override def init(filterConfig: FilterConfig) {
+    config = new FilterConfigHelper(filterConfig).getFilterConfig(DEFAULT_CONFIG)
+    LOG.info("Initializing filter using config " + config)
+    val powerApiContext = ServletContextHelper.getInstance(filterConfig.getServletContext).getPowerApiContext
+    configurationService = powerApiContext.configurationService
+    handlerFactory = new RackspaceIdentityBasicAuthHandlerFactory(powerApiContext.akkaServiceClientService, powerApiContext.datastoreService)
+    val xsdURL: URL = getClass.getResource("/META-INF/config/schema/rackspace-identity-basic-auth.xsd")
+    configurationService.subscribeTo(
+      filterConfig.getFilterName,
+      config,
+      xsdURL,
+      handlerFactory.asInstanceOf[UpdateListener[RackspaceIdentityBasicAuthConfig]],
+      classOf[RackspaceIdentityBasicAuthConfig]
+    )
+    LOG.warn("WARNING: This filter cannot be used alone, it requires an AuthFilter after it.")
+  }
+
+  override def doFilter(servletRequest: ServletRequest, servletResponse: ServletResponse, filterChain: FilterChain) {
+    new FilterLogicHandlerDelegate(servletRequest, servletResponse, filterChain).doFilter(handlerFactory.newHandler)
+  }
+
+  override def destroy() {
+    configurationService.unsubscribeFrom(config, handlerFactory)
+  }
+}
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandler.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandler.scala
new file mode 100644
index 0000000..26c9e33
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandler.scala
@@ -0,0 +1,127 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import java.util.concurrent.TimeUnit
+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}
+import javax.ws.rs.core.{HttpHeaders, MediaType}
+
+import com.rackspace.papi.commons.util.servlet.http.ReadableHttpServletResponse
+import com.rackspace.papi.components.rackspace.identity.basicauth.config.RackspaceIdentityBasicAuthConfig
+import com.rackspace.papi.filter.logic.common.AbstractFilterLogicHandler
+import com.rackspace.papi.filter.logic.impl.FilterDirectorImpl
+import com.rackspace.papi.filter.logic.{FilterAction, FilterDirector}
+import com.rackspace.papi.service.datastore.DatastoreService
+import com.rackspace.papi.service.serviceclient.akka.AkkaServiceClient
+import org.slf4j.LoggerFactory
+
+import scala.collection.JavaConverters._
+import scala.io.Source
+import scala.xml._
+
+class RackspaceIdentityBasicAuthHandler(basicAuthConfig: RackspaceIdentityBasicAuthConfig, akkaServiceClient: AkkaServiceClient, datastoreService: DatastoreService)
+  extends AbstractFilterLogicHandler {
+
+  private final val LOG = LoggerFactory.getLogger(classOf[RackspaceIdentityBasicAuthHandler])
+  private final val TOKEN_KEY_PREFIX = "TOKEN:"
+  private final val X_AUTH_TOKEN = "X-Auth-Token"
+  private val identityServiceUri = basicAuthConfig.getRackspaceIdentityServiceUri
+  private val tokenCacheTtlMillis = basicAuthConfig.getTokenCacheTimeoutMillis
+  private val datastore = datastoreService.getDefaultDatastore
+
+  override def handleRequest(httpServletRequest: HttpServletRequest, httpServletResponse: ReadableHttpServletResponse): FilterDirector = {
+    LOG.debug("Handling HTTP Request")
+    val filterDirector: FilterDirector = new FilterDirectorImpl()
+    // We need to process the Response unless a couple of specific conditions occur.
+    filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE)
+    if (!httpServletRequest.getHeaderNames.asScala.toList.contains(X_AUTH_TOKEN)) {
+      withEncodedCredentials(httpServletRequest) { encodedCredentials =>
+        Option(datastore.get(TOKEN_KEY_PREFIX + encodedCredentials)) match {
+          case Some(token) => {
+            val tokenString = token.toString()
+            filterDirector.requestHeaderManager().appendHeader(X_AUTH_TOKEN, tokenString)
+          }
+          case None => {
+            // request a token
+            getUserToken(encodedCredentials) match {
+              case (code, Some(token)) => {
+                val tokenStr = token.toString()
+                if (tokenCacheTtlMillis > 0) {
+                  datastore.put(TOKEN_KEY_PREFIX + encodedCredentials, tokenStr, tokenCacheTtlMillis, TimeUnit.MILLISECONDS)
+                }
+                filterDirector.requestHeaderManager().appendHeader(X_AUTH_TOKEN, tokenStr)
+              }
+              case (code, _) => {
+                if (code == HttpServletResponse.SC_UNAUTHORIZED) {
+                  filterDirector.setResponseStatusCode(HttpServletResponse.SC_UNAUTHORIZED) // (401)
+                  filterDirector.responseHeaderManager().appendHeader(HttpHeaders.WWW_AUTHENTICATE, "Basic realm=\"RAX-KEY\"")
+                  datastore.remove(TOKEN_KEY_PREFIX + encodedCredentials)
+                } else {
+                  filterDirector.setResponseStatusCode(HttpServletResponse.SC_INTERNAL_SERVER_ERROR) // (500)
+                }
+                filterDirector.setFilterAction(FilterAction.RETURN)
+              }
+            }
+          }
+        }
+      }
+    }
+    filterDirector
+  }
+
+  override def handleResponse(httpServletRequest: HttpServletRequest, httpServletResponse: ReadableHttpServletResponse): FilterDirector = {
+    LOG.debug("Handling HTTP Response. Incoming status code: " + httpServletResponse.getStatus())
+    val filterDirector: FilterDirector = new FilterDirectorImpl()
+    if (httpServletResponse.getStatus == HttpServletResponse.SC_UNAUTHORIZED ||
+      httpServletResponse.getStatus == HttpServletResponse.SC_FORBIDDEN) {
+      filterDirector.responseHeaderManager().appendHeader(HttpHeaders.WWW_AUTHENTICATE, "Basic realm=\"RAX-KEY\"")
+      withEncodedCredentials(httpServletRequest) { encodedCredentials =>
+        datastore.remove(TOKEN_KEY_PREFIX + encodedCredentials)
+      }
+    }
+    LOG.debug("Rackspace Identity Basic Auth Response. Outgoing status code: " + filterDirector.getResponseStatus.intValue)
+    filterDirector
+  }
+
+  private def withEncodedCredentials(request: HttpServletRequest)(f: String => Unit): Unit = {
+    Option(request.getHeaders(HttpHeaders.AUTHORIZATION)).map { authHeader =>
+      val authMethodBasicHeaders = BasicAuthUtils.getBasicAuthHeaders(authHeader, "Basic")
+      if (authMethodBasicHeaders.nonEmpty) {
+        val firstHeader = authMethodBasicHeaders.next()
+        f(firstHeader.replace("Basic ", ""))
+      }
+    }
+  }
+
+  private def getUserToken(authValue: String): (Int, Option[String]) = {
+    def createAuthRequest(encoded: String) = {
+      // Base64 Decode and split the userName/apiKey
+      val (userName, apiKey) = BasicAuthUtils.extractCredentials(authValue)
+      // Scala's standard XML syntax does not support the XML declaration w/o a lot of hoops
+      //<?xml version="1.0" encoding="UTF-8"?>
+      <auth xmlns="http://docs.openstack.org/identity/api/v2.0">
+        <apiKeyCredentials
+        xmlns="http://docs.rackspace.com/identity/api/ext/RAX-KSKEY/v1.0"
+        username={userName}
+        apiKey={apiKey}/>
+      </auth>
+    }
+    // Request a User Token based on the extracted User Name/API Key.
+    val authTokenResponse = Option(akkaServiceClient.post(authValue,
+      identityServiceUri,
+      Map[String, String]().asJava,
+      createAuthRequest(authValue).toString,
+      MediaType.APPLICATION_XML_TYPE))
+
+    authTokenResponse.map { tokenResponse =>
+      val statusCode = tokenResponse.getStatusCode
+      if (statusCode == HttpServletResponse.SC_OK) {
+        val xmlString = XML.loadString(Source.fromInputStream(tokenResponse.getData()).mkString)
+        val idString = (xmlString \\ "access" \ "token" \ "@id").text
+        (statusCode, Option(idString))
+      } else {
+        (statusCode, None)
+      }
+    } getOrElse {
+      (HttpServletResponse.SC_INTERNAL_SERVER_ERROR, None)
+    }
+  }
+}
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerFactory.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerFactory.scala
new file mode 100644
index 0000000..0e30d84
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/main/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerFactory.scala
@@ -0,0 +1,40 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import java.util
+
+import com.rackspace.papi.commons.config.manager.UpdateListener
+import com.rackspace.papi.components.rackspace.identity.basicauth.config.RackspaceIdentityBasicAuthConfig
+import com.rackspace.papi.filter.logic.AbstractConfiguredFilterHandlerFactory
+import com.rackspace.papi.service.datastore.DatastoreService
+import com.rackspace.papi.service.serviceclient.akka.AkkaServiceClient
+
+class RackspaceIdentityBasicAuthHandlerFactory(akkaServiceClient: AkkaServiceClient, datastoreService: DatastoreService)
+  extends AbstractConfiguredFilterHandlerFactory[RackspaceIdentityBasicAuthHandler] {
+
+  private var rackspaceIdentityBasicAuthHandler: RackspaceIdentityBasicAuthHandler = _
+
+  override def buildHandler: RackspaceIdentityBasicAuthHandler = {
+    if (isInitialized) rackspaceIdentityBasicAuthHandler
+    else null
+  }
+
+  override def getListeners: java.util.Map[Class[_], UpdateListener[_]] = {
+    val listenerMap = new util.HashMap[Class[_], UpdateListener[_]]()
+    listenerMap.put(classOf[RackspaceIdentityBasicAuthConfig], new RackspaceIdentityBasicAuthConfigurationListener())
+    listenerMap
+  }
+
+  private class RackspaceIdentityBasicAuthConfigurationListener extends UpdateListener[RackspaceIdentityBasicAuthConfig] {
+    private var initialized = false
+
+    def configurationUpdated(config: RackspaceIdentityBasicAuthConfig) {
+      rackspaceIdentityBasicAuthHandler = new RackspaceIdentityBasicAuthHandler(config, akkaServiceClient, datastoreService)
+      initialized = true
+    }
+
+    def isInitialized = {
+      initialized
+    }
+  }
+
+}
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/resources/log4j.properties b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/resources/log4j.properties
new file mode 100644
index 0000000..5808b6e
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/resources/log4j.properties
@@ -0,0 +1,8 @@
+# Set root logger level to WARN
+#log4j.rootLogger=TRACE, consoleOut
+log4j.rootLogger=DEBUG, consoleOut
+
+# Console
+log4j.appender.consoleOut=org.apache.log4j.ConsoleAppender
+log4j.appender.consoleOut.layout=org.apache.log4j.PatternLayout
+log4j.appender.consoleOut.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/BasicAuthUtilsTest.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/BasicAuthUtilsTest.scala
new file mode 100644
index 0000000..9b15e8b
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/BasicAuthUtilsTest.scala
@@ -0,0 +1,28 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import com.rackspace.papi.components.rackspace.identity.basicauth.BasicAuthUtils._
+import org.apache.commons.codec.binary.Base64
+import org.scalatest.{FunSpec, Matchers}
+
+class BasicAuthUtilsTest extends FunSpec with Matchers {
+
+  describe("decoding username and API key credentials") {
+    val cases = List(
+      "userName:apiKey" ->("userName", "apiKey"), // No extra colons
+      "userName:::apiKey" ->("userName", "::apiKey"), // Extra leading colons
+      "userName:api:::Key" ->("userName", "api:::Key"), // Extra embedded colons
+      "userName:apiKey::" ->("userName", "apiKey::"), // Extra trailing colons
+      "userName::a:p:i:K:e:y:" ->("userName", ":a:p:i:K:e:y:") // Just crazy
+    )
+    cases.foreach { case (decoded, (expectedUsername, expectedPassword)) =>
+      it(s"decodes $decoded into $expectedUsername and $expectedPassword") {
+        val authValue = new String(Base64.encodeBase64URLSafeString(decoded.getBytes()))
+
+        val (extractedUsername, extractedPassword) = extractCredentials(authValue)
+
+        extractedUsername shouldBe expectedUsername
+        extractedPassword shouldBe expectedPassword
+      }
+    }
+  }
+}
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerFactoryTest.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerFactoryTest.scala
new file mode 100644
index 0000000..8bcf03e
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerFactoryTest.scala
@@ -0,0 +1,37 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import com.rackspace.papi.components.rackspace.identity.basicauth.config.RackspaceIdentityBasicAuthConfig
+import com.rackspace.papi.service.datastore.DatastoreService
+import com.rackspace.papi.service.serviceclient.akka.AkkaServiceClient
+import org.junit.runner.RunWith
+import org.scalatest.junit.JUnitRunner
+import org.scalatest.mock.MockitoSugar
+import org.scalatest.{BeforeAndAfter, FunSpec, Matchers}
+
+@RunWith(classOf[JUnitRunner])
+class RackspaceIdentityBasicAuthHandlerFactoryTest extends FunSpec with BeforeAndAfter with Matchers with MockitoSugar {
+
+  val mockAkkaServiceClient = mock[AkkaServiceClient]
+  val mockDatastoreService = mock[DatastoreService]
+  var handlerFactory: RackspaceIdentityBasicAuthHandlerFactory = _
+
+  before {
+    handlerFactory = new RackspaceIdentityBasicAuthHandlerFactory(mockAkkaServiceClient, mockDatastoreService)
+  }
+
+  describe("buildHandler") {
+    it("should return a Rackspace Identity Basic Auth handler") {
+      handlerFactory.configurationUpdated(new RackspaceIdentityBasicAuthConfig())
+      handlerFactory.buildHandler shouldBe a[RackspaceIdentityBasicAuthHandler]
+    }
+  }
+
+  describe("getListeners") {
+    it("should return a map of listeners one of which listens to the Rackspace Identity configuration file") {
+      val listeners = handlerFactory.getListeners
+
+      listeners should have size 1
+      listeners should contain key classOf[RackspaceIdentityBasicAuthConfig]
+    }
+  }
+}
diff --git a/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerTest.scala b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerTest.scala
new file mode 100644
index 0000000..8232cae
--- /dev/null
+++ b/repose-aggregator/components/filters/rackspace-identity-basic-auth/src/test/scala/com/rackspace/papi/components/rackspace/identity/basicauth/RackspaceIdentityBasicAuthHandlerTest.scala
@@ -0,0 +1,73 @@
+package com.rackspace.papi.components.rackspace.identity.basicauth
+
+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}
+
+import com.mockrunner.mock.web.MockHttpServletRequest
+import com.rackspace.papi.commons.util.servlet.http.ReadableHttpServletResponse
+import com.rackspace.papi.components.datastore.Datastore
+import com.rackspace.papi.components.rackspace.identity.basicauth.config.RackspaceIdentityBasicAuthConfig
+import com.rackspace.papi.filter.logic.FilterAction
+import com.rackspace.papi.service.datastore.DatastoreService
+import com.rackspace.papi.service.serviceclient.akka.AkkaServiceClient
+import org.junit.runner.RunWith
+import org.mockito.Matchers.anyString
+import org.mockito.Mockito.when
+import org.scalatest.junit.JUnitRunner
+import org.scalatest.mock.MockitoSugar
+import org.scalatest.{BeforeAndAfter, FunSpec, Matchers, PrivateMethodTester}
+
+@RunWith(classOf[JUnitRunner])
+class RackspaceIdentityBasicAuthHandlerTest extends FunSpec with BeforeAndAfter with Matchers with PrivateMethodTester with MockitoSugar {
+
+  var rackspaceIdentityBasicAuthHandler: RackspaceIdentityBasicAuthHandler = _
+  var rackspaceIdentityBasicAuthConfig: RackspaceIdentityBasicAuthConfig = _
+  var mockAkkaServiceClient: AkkaServiceClient = _
+  var mockDatastoreService: DatastoreService = _
+  var mockDatastore: Datastore = _
+
+  before {
+    mockAkkaServiceClient = mock[AkkaServiceClient]
+    mockDatastoreService = mock[DatastoreService]
+    mockDatastore = mock[Datastore]
+    rackspaceIdentityBasicAuthConfig = new RackspaceIdentityBasicAuthConfig()
+    rackspaceIdentityBasicAuthConfig.setTokenCacheTimeoutMillis(0)
+
+    when(mockDatastoreService.getDefaultDatastore).thenReturn(mockDatastore)
+    when(mockDatastore.get(anyString)).thenReturn(null, Nil: _*)
+
+    rackspaceIdentityBasicAuthHandler = new RackspaceIdentityBasicAuthHandler(rackspaceIdentityBasicAuthConfig, mockAkkaServiceClient, mockDatastoreService)
+  }
+
+  describe("handleRequest") {
+    it("should simply pass if there is not an HTTP Basic authentication header") {
+      // given: "a mock'd ServletRequest and ServletResponse"
+      val mockServletRequest = new MockHttpServletRequest
+      val mockServletResponse = mock[ReadableHttpServletResponse]
+
+      // when: "the filter's/handler's handleRequest() is called without an HTTP Basic authentication header"
+      val filterDirector = rackspaceIdentityBasicAuthHandler.handleRequest(mockServletRequest, mockServletResponse)
+
+      // then: "the filter's response status code would only be processed if it were set to UNAUTHORIZED (401) by another filter/service."
+      filterDirector.getFilterAction equals FilterAction.PROCESS_RESPONSE
+    }
+  }
+
+  // Due to the apparent limitation of the current mock environment,
+  // this test will be moved to a Spock functional test.
+  //describe("handleResponse") {
+  //  it("should pass filter") {
+  //    // given: "a mock'd ServletRequest and ServletResponse"
+  //    val mockServletRequest = mock[HttpServletRequest]
+  //    val mockServletResponse = mock[ReadableHttpServletResponse]
+  //
+  //    // TODO: This should work, but seems to be a limitation of the current ScalaMock.
+  //    //when(mockServletResponse.getStatus()).thenReturn(HttpServletResponse.SC_OK)
+  //
+  //    // when: "the filter's/handler's handleResponse() is called"
+  //    val filterDirector = rackspaceIdentityBasicAuthHandler.handleResponse(mockServletRequest, mockServletResponse)
+  //
+  //    // then: "the filter's response status code should be No Content (204)"
+  //    filterDirector.getResponseStatusCode should be(HttpServletResponse.SC_NO_CONTENT)
+  //  }
+  //}
+}
diff --git a/repose-aggregator/core/core-lib/src/main/java/com/rackspace/papi/filter/logic/FilterDirector.java b/repose-aggregator/core/core-lib/src/main/java/com/rackspace/papi/filter/logic/FilterDirector.java
index 845276b..f8c02e9 100644
--- a/repose-aggregator/core/core-lib/src/main/java/com/rackspace/papi/filter/logic/FilterDirector.java
+++ b/repose-aggregator/core/core-lib/src/main/java/com/rackspace/papi/filter/logic/FilterDirector.java
@@ -46,0 +47,7 @@
+   /**
+    * Informs the Filter Chain whether to continue (PASS), stop and return immediately (RETURN), or continue and then
+    * handle the response on the unwind (PROCESS_RESPONSE).
+    * The default is NOT_SET and shouldn't be used. This should always be set to one of the other three.
+    *
+    * @param action the action to take
+    */
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/cache/rackspace-identity-basic-auth.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/cache/rackspace-identity-basic-auth.cfg.xml
new file mode 100644
index 0000000..8435cd3
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/cache/rackspace-identity-basic-auth.cfg.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<rackspace-identity-basic-auth
+        xmlns="http://docs.openrepose.org/rackspace-identity-basic-auth/v1.0"
+        rackspace-identity-service-uri="http://localhost:${identityPort}/tokens"
+        token-cache-timeout-millis="2000"/>
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/client-auth-n.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/client-auth-n.cfg.xml
new file mode 100644
index 0000000..e9cb643
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/client-auth-n.cfg.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<client-auth xmlns="http://docs.rackspacecloud.com/repose/client-auth/v1.0">
+    <openstack-auth delegable="false"
+                    tenanted="false"
+                    request-groups="true"
+                    token-cache-timeout="0"
+                    group-cache-timeout="600000"
+                    xmlns="http://docs.openrepose.org/repose/client-auth/os-ids-auth/v1.0">
+        <identity-service username="admin_username"
+                          password="admin_password"
+                          uri="http://localhost:${identityPort}"/>
+        <client-mapping id-regex=".*/servers/([-|\w]+)/?.*"/>
+    </openstack-auth>
+</client-auth>
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/onlybasicauth/system-model.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/onlybasicauth/system-model.cfg.xml
new file mode 100644
index 0000000..2eee09e
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/onlybasicauth/system-model.cfg.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<system-model xmlns="http://docs.rackspacecloud.com/repose/system-model/v2.0">
+    <repose-cluster id="repose">
+
+        <nodes>
+            <node id="node" hostname="localhost" http-port="${reposePort}"/>
+        </nodes>
+
+        <filters>
+            <filter name="rackspace-identity-basic-auth"/>
+        </filters>
+
+        <destinations>
+            <endpoint id="target"
+                      protocol="http"
+                      hostname="localhost"
+                      root-path="/"
+                      port="${targetPort}"
+                      default="true"/>
+        </destinations>
+
+    </repose-cluster>
+</system-model>
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/rackspace-identity-basic-auth.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/rackspace-identity-basic-auth.cfg.xml
new file mode 100644
index 0000000..187b76b
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/rackspace-identity-basic-auth.cfg.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<rackspace-identity-basic-auth
+        xmlns="http://docs.openrepose.org/rackspace-identity-basic-auth/v1.0"
+        rackspace-identity-service-uri="http://localhost:${identityPort}/tokens"
+        token-cache-timeout-millis="0"/>
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/system-model.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/system-model.cfg.xml
new file mode 100644
index 0000000..30a1ba7
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identitybasicauth/system-model.cfg.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<system-model xmlns="http://docs.rackspacecloud.com/repose/system-model/v2.0">
+    <repose-cluster id="repose">
+
+        <nodes>
+            <node id="node" hostname="localhost" http-port="${reposePort}"/>
+        </nodes>
+
+        <filters>
+            <filter name="rackspace-identity-basic-auth"/>
+            <filter name="client-auth"/>
+        </filters>
+
+        <destinations>
+            <endpoint id="target"
+                      protocol="http"
+                      hostname="localhost"
+                      root-path="/"
+                      port="${targetPort}"
+                      default="true"/>
+        </destinations>
+
+    </repose-cluster>
+</system-model>
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identityv3/projectidinuri/noserviceroles/openstack-identity-v3.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identityv3/projectidinuri/noserviceroles/openstack-identity-v3.cfg.xml
new file mode 100644
index 0000000..2b5f5d3
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identityv3/projectidinuri/noserviceroles/openstack-identity-v3.cfg.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<openstack-identity-v3 xmlns="http://docs.openrepose.org/openstack-identity-v3/v1.0">
+
+    <openstack-identity-service username="admin-username"
+                      password="admin-password"
+                      uri="http://localhost:${identityPort}"
+                      xmlns="http://docs.openrepose.org/openstack-identity-v3/v1.0"/>
+    <validate-project-id-in-uri regex=".*/servers/([-|\w]+)/?.*"/>
+
+</openstack-identity-v3>
\ No newline at end of file
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identityv3/projectidinuri/serviceroles/openstack-identity-v3.cfg.xml b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identityv3/projectidinuri/serviceroles/openstack-identity-v3.cfg.xml
new file mode 100644
index 0000000..ca729c3
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/configs/features/filters/identityv3/projectidinuri/serviceroles/openstack-identity-v3.cfg.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<openstack-identity-v3 xmlns="http://docs.openrepose.org/openstack-identity-v3/v1.0">
+
+    <openstack-identity-service username="admin-username"
+                      password="admin-password"
+                      uri="http://localhost:${identityPort}"
+                      xmlns="http://docs.openrepose.org/openstack-identity-v3/v1.0"/>
+    <validate-project-id-in-uri regex=".*/servers/([-|\w]+)/?.*"/>
+    <roles-which-bypass-project-id-check>
+        <role>service:admin-role1</role>
+        <role>service:admin-role2</role>
+    </roles-which-bypass-project-id-check>
+
+</openstack-identity-v3>
\ No newline at end of file
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthCacheTimeoutTest.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthCacheTimeoutTest.groovy
new file mode 100644
index 0000000..3303a14
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthCacheTimeoutTest.groovy
@@ -0,0 +1,94 @@
+package features.filters.identitybasicauth
+import framework.ReposeValveTest
+import framework.mocks.MockIdentityService
+import org.apache.commons.codec.binary.Base64
+import org.rackspace.deproxy.Deproxy
+import org.rackspace.deproxy.MessageChain
+
+import javax.servlet.http.HttpServletResponse
+import javax.ws.rs.core.HttpHeaders
+/**
+ * Created by jennyvo on 9/24/14.
+ * simple token cache timeout test
+ */
+class BasicAuthCacheTimeoutTest extends ReposeValveTest {
+    def static originEndpoint
+    def static identityEndpoint
+    def static MockIdentityService fakeIdentityService
+
+    def setupSpec() {
+        deproxy = new Deproxy()
+
+        def params = properties.getDefaultTemplateParams()
+        repose.configurationProvider.cleanConfigDirectory()
+        repose.configurationProvider.applyConfigs("common", params);
+        repose.configurationProvider.applyConfigs("features/filters/identitybasicauth", params);
+        repose.configurationProvider.applyConfigs("features/filters/identitybasicauth/cache", params);
+        repose.start()
+
+        originEndpoint = deproxy.addEndpoint(properties.targetPort, 'origin service')
+        fakeIdentityService = new MockIdentityService(properties.identityPort, properties.targetPort)
+        identityEndpoint = deproxy.addEndpoint(properties.identityPort, 'identity service', null, fakeIdentityService.handler)
+        fakeIdentityService.checkTokenValid = true
+    }
+
+    def setup() {
+        fakeIdentityService.with {
+            // This is required to ensure that one piece of the authentication data is changed
+            // so that the cached version in the Akka Client is not used.
+            client_apikey = UUID.randomUUID().toString()
+            client_token = UUID.randomUUID().toString()
+        }
+    }
+
+    def cleanupSpec() {
+        if (deproxy) {
+            deproxy.shutdown()
+        }
+
+        if (repose) {
+            repose.stop()
+        }
+    }
+
+    def "Ensure that subsequent calls within the cache timeout are retrieving the token from the cache"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "multiple requests that have the same HTTP Basic authentication header"
+        MessageChain mc0 = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+        MessageChain mc1 = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "get the token from the cache"
+        mc0.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc0.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc0.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+        mc1.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc1.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc1.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+        mc1.orphanedHandlings.size() == 0
+    }
+
+    def "Ensure that subsequent calls outside the cache timeout are retrieving a new token not from the cache"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "multiple requests that have the same HTTP Basic authentication header, but are separated by more than the cache timeout"
+        MessageChain mc0 = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+        sleep 3000 // How do I get this programmatically from the config.
+        MessageChain mc1 = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "get the token from the Identity (Keystone) service"
+        mc0.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc0.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc0.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+        mc1.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc1.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc1.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+        mc1.orphanedHandlings.size() == 1
+    }
+}
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthStandaloneTest.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthStandaloneTest.groovy
new file mode 100644
index 0000000..2b00a54
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthStandaloneTest.groovy
@@ -0,0 +1,233 @@
+package features.filters.identitybasicauth
+
+import framework.ReposeValveTest
+import framework.mocks.MockIdentityService
+import org.apache.commons.codec.binary.Base64
+import org.rackspace.deproxy.Deproxy
+import org.rackspace.deproxy.MessageChain
+import org.rackspace.deproxy.Response
+import spock.lang.Ignore
+import spock.lang.Unroll
+
+import javax.servlet.http.HttpServletResponse
+import javax.ws.rs.core.HttpHeaders
+
+/**
+ * Created by jennyvo on 9/17/14.
+ * Basic Auth filter can't be used alone, have to use with client-auth filter
+ */
+class BasicAuthStandaloneTest extends ReposeValveTest {
+    def static originEndpoint
+    def static identityEndpoint
+    def static MockIdentityService fakeIdentityService
+
+    def setupSpec() {
+        deproxy = new Deproxy()
+
+        def params = properties.getDefaultTemplateParams()
+        repose.configurationProvider.cleanConfigDirectory()
+        repose.configurationProvider.applyConfigs("common", params);
+        repose.configurationProvider.applyConfigs("features/filters/identitybasicauth", params);
+        repose.configurationProvider.applyConfigs("features/filters/identitybasicauth/onlybasicauth", params);
+
+        repose.start()
+
+        originEndpoint = deproxy.addEndpoint(properties.targetPort, 'origin service')
+        fakeIdentityService = new MockIdentityService(properties.identityPort, properties.targetPort)
+        identityEndpoint = deproxy.addEndpoint(properties.identityPort, 'identity service', null, fakeIdentityService.handler)
+        fakeIdentityService.checkTokenValid = true
+    }
+
+    def setup() {
+        fakeIdentityService.with {
+            // This is required to ensure that one piece of the authentication data is changed
+            // so that the cached version in the Akka Client is not used.
+            client_apikey = UUID.randomUUID().toString()
+            client_token = UUID.randomUUID().toString()
+        }
+    }
+
+    def cleanupSpec() {
+        if (deproxy) {
+            deproxy.shutdown()
+        }
+
+        if (repose) {
+            repose.stop()
+        }
+    }
+
+    def "when start repose with basic auth, send request without credential"() {
+        when: "send request without credential"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET')
+
+        then: "simply pass it on down the filter chain"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.orphanedHandlings.size() == 0
+    }
+
+    // NOTE: This would normally be removed by a Header Normalization filter.
+    def "Request with X-Auth-Token header sent."() {
+        given: "the X-Auth-Token header containing the User Token"
+        def headers = [
+                "X-Auth-Token": fakeIdentityService.client_token
+        ]
+
+        when: "the request already has credentials"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "simply pass it on down the filter chain with out client-aut filter just a pass through"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.orphanedHandlings.size() == 0
+        !mc.receivedResponse.headers.findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+    }
+
+    // NOTE: This would normally be removed by a Header Normalization filter.
+    def "Request that contains both an X-Auth-Token and HTTP Basic authentication header is sent."() {
+        given: "header containing the User Token and an HTTP Basic authentication header (username/apikey)"
+        def headers = [
+                "X-Auth-Token"             : fakeIdentityService.client_token,
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "the request already has credentials"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "simply pass it on down the filter chain NOT processing the HTTP Basic authentication"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.orphanedHandlings.size() == 0
+        !mc.receivedResponse.headers.findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+    }
+
+    @Unroll("Sending request with invalid UserName #userName and API Key #apiKey pair.")
+    def "Fail to retrieve a token for an HTTP Basic authentication header with an invalid UserName/ApiKey pair"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((userName + ":" + apiKey).bytes)
+        ]
+
+        when: "the request does have an HTTP Basic authentication header with UserName/ApiKey"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "Request reject if invalid apikey or username"
+        mc.receivedResponse.code == HttpServletResponse.SC_UNAUTHORIZED.toString()
+        mc.handlings.size() == 0
+        mc.receivedResponse.getHeaders().findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+
+        where:
+        userName                            | apiKey
+        fakeIdentityService.client_username | "BAD-API-KEY"
+        "BAD-USER-NAME"                     | fakeIdentityService.client_apikey
+        "BAD-USER-NAME"                     | "BAD-API-KEY"
+    }
+
+    @Ignore
+    // Only the first AUTHORIZATION Basic header will be processed.
+    def "Stop trying to retrieve a token for an HTTP Basic authentication header after a token has been obtained."() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + "BAD-API-KEY").bytes),
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes),
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString(("BAD-USER-NAME" + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "the request does have an HTTP Basic authentication header with UserName/ApiKey"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "then get a token for it"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+    }
+
+    // NOTE: This would normally be removed by a Header Normalization filter.
+    def "when start repose with basic auth only, x-auth-token should work"() {
+        given:
+        def headers = [
+                "X-Auth-Token": fakeIdentityService.client_token
+        ]
+
+        when: "send request without credential"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "request should pass as no basic auth filter"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.orphanedHandlings.size() == 0
+        !mc.receivedResponse.getHeaders().findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+    }
+
+    def "Retrieve a token for an HTTP Basic authentication header with UserName/ApiKey"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "the request does have an HTTP Basic authentication header with UserName/ApiKey"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "then get a token for it"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.handlings[0].request.headers.getCountByName(HttpHeaders.AUTHORIZATION) == 1
+        mc.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+        mc.orphanedHandlings.size() == 1 // This is the call to the Mock Identity service through deproxy.
+        !mc.receivedResponse.getHeaders().findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+    }
+
+    def "Inject header WWW-authenticate when basicauth or other component failed with 401"() {
+        when: "the request sends with invalid key"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET',
+                defaultHandler: { new Response(HttpServletResponse.SC_UNAUTHORIZED, null, null, null) })
+
+        then: "request should pass as no basic auth filter"
+        mc.receivedResponse.code == HttpServletResponse.SC_UNAUTHORIZED.toString()
+        mc.handlings.size() == 1
+        mc.orphanedHandlings.size() == 0
+        mc.receivedResponse.getHeaders().findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+    }
+
+    def "Log a very loud WARNING stating the OpenStack Basic Auth filter cannot be used alone."() {
+        expect: "check for the WARNING."
+        reposeLogSearch.searchByString("WARNING: This filter cannot be used alone, it requires an AuthFilter after it.").size() > 0
+    }
+
+    @Unroll("Sending request to the Identity service returns HTTP Status Code #identityStatusCode")
+    def "when failing to authenticate admin client"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key and the Mock Identity Service's generateTokenHandler"
+        fakeIdentityService.with {
+            generateTokenHandler = {
+                request, xml ->
+                    new Response(identityStatusCode, null, null, null)
+            }
+        }
+        def headers = [
+                'content-type'             : 'application/json',
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "user passes a request through repose"
+        MessageChain mc = deproxy.makeRequest(url: "$reposeEndpoint/servers/$reqTenant/", method: 'GET', headers: headers)
+
+        then: "request body sent from repose to the origin service should contain"
+        mc.receivedResponse.code == filterStatusCode.toString()
+        mc.handlings.size() == 0
+
+        where:
+        reqTenant | identityStatusCode                           | filterStatusCode
+        9400      | HttpServletResponse.SC_BAD_REQUEST           | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9401      | HttpServletResponse.SC_UNAUTHORIZED          | HttpServletResponse.SC_UNAUTHORIZED
+        9403      | HttpServletResponse.SC_FORBIDDEN             | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9404      | HttpServletResponse.SC_NOT_FOUND             | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9500      | HttpServletResponse.SC_INTERNAL_SERVER_ERROR | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9501      | HttpServletResponse.SC_NOT_IMPLEMENTED       | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9502      | HttpServletResponse.SC_BAD_GATEWAY           | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9503      | HttpServletResponse.SC_SERVICE_UNAVAILABLE   | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9504      | HttpServletResponse.SC_GATEWAY_TIMEOUT       | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+    }
+}
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthTest.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthTest.groovy
new file mode 100644
index 0000000..d9201eb
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identitybasicauth/BasicAuthTest.groovy
@@ -0,0 +1,162 @@
+package features.filters.identitybasicauth
+
+import framework.ReposeValveTest
+import framework.mocks.MockIdentityService
+import org.apache.commons.codec.binary.Base64
+import org.rackspace.deproxy.Deproxy
+import org.rackspace.deproxy.MessageChain
+import org.rackspace.deproxy.Response
+import spock.lang.Ignore
+import spock.lang.Unroll
+
+import javax.servlet.http.HttpServletResponse
+import javax.ws.rs.core.HttpHeaders
+
+class BasicAuthTest extends ReposeValveTest {
+    def static originEndpoint
+    def static identityEndpoint
+    def static MockIdentityService fakeIdentityService
+
+    def setupSpec() {
+        deproxy = new Deproxy()
+
+        def params = properties.getDefaultTemplateParams()
+        repose.configurationProvider.cleanConfigDirectory()
+        repose.configurationProvider.applyConfigs("common", params);
+        repose.configurationProvider.applyConfigs("features/filters/identitybasicauth", params);
+
+        repose.start()
+
+        originEndpoint = deproxy.addEndpoint(properties.targetPort, 'origin service')
+        fakeIdentityService = new MockIdentityService(properties.identityPort, properties.targetPort)
+        identityEndpoint = deproxy.addEndpoint(properties.identityPort, 'identity service', null, fakeIdentityService.handler)
+        fakeIdentityService.checkTokenValid = true
+    }
+
+    def setup() {
+        fakeIdentityService.with {
+            // This is required to ensure that one piece of the authentication data is changed
+            // so that the cached version in the Akka Client is not used.
+            client_apikey = UUID.randomUUID().toString()
+            client_token = UUID.randomUUID().toString()
+        }
+    }
+
+    def cleanupSpec() {
+        if (deproxy) {
+            deproxy.shutdown()
+        }
+
+        if (repose) {
+            repose.stop()
+        }
+    }
+
+    def "Retrieve a token for an HTTP Basic authentication header with UserName/ApiKey"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "the request does have an HTTP Basic authentication header with UserName/ApiKey"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "get a token for it"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        mc.handlings[0].request.headers.getCountByName("X-Auth-Token") == 1
+        mc.handlings[0].request.headers.getFirstValue("X-Auth-Token").equals(fakeIdentityService.client_token)
+        mc.handlings[0].request.headers.getFirstValue(HttpHeaders.AUTHORIZATION)
+        !mc.receivedResponse.headers.getFirstValue(HttpHeaders.WWW_AUTHENTICATE)
+    }
+    def "No HTTP Basic authentication header sent and no token."() {
+        when: "the request does not have an HTTP Basic authentication header"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET')
+
+        then: "simply pass it on down the filter chain and this configuration will respond with a SC_UNAUTHORIZED (401) and add an HTTP Basic authentication header"
+        mc.receivedResponse.code == HttpServletResponse.SC_UNAUTHORIZED.toString()
+        mc.handlings.size() == 0
+        mc.receivedResponse.getHeaders().findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+        mc.orphanedHandlings.size() == 0
+    }
+
+    def "When the request has an x-auth-token, then still work with client-auth"() {
+        given:
+        def headers = ['X-Auth-Token': fakeIdentityService.client_token]
+
+        when: "the request already has an x-auth-token header"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "then get a token and validate it"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        !mc.handlings[0].request.headers.getFirstValue(HttpHeaders.AUTHORIZATION)
+        !mc.receivedResponse.headers.getFirstValue(HttpHeaders.WWW_AUTHENTICATE)
+        mc.handlings[0].request.headers.getFirstValue("X-Auth-Token")
+    }
+
+    def "When the request send with invalid key or username, then will fail to authenticate"() {
+        given: "the HTTP Basic authentication header containing the User Name and invalid API Key"
+        def headers = [
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":BAD-API-KEY").bytes)
+        ]
+
+        when: "the request does have an HTTP Basic authentication header"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "get a token and validate it"
+        mc.receivedResponse.code == HttpServletResponse.SC_UNAUTHORIZED.toString()
+        mc.handlings.size() == 0
+        mc.receivedResponse.getHeaders().findAll(HttpHeaders.WWW_AUTHENTICATE).contains("Basic realm=\"RAX-KEY\"")
+    }
+
+    @Ignore // This test was removed due to a current limitation of the MockIdentityService to not differentiate between the two services calling it.
+    @Unroll("Sending request with admin response set to HTTP #identityStatusCode")
+    def "when failing to authenticate admin client"() {
+        given: "the HTTP Basic authentication header containing the User Name and API Key and the Mock Identity Service's generateTokenHandler"
+        fakeIdentityService.with {
+            generateTokenHandler = {
+                request, xml ->
+                    new Response(identityStatusCode, null, null, null)
+            }
+        }
+        def headers = [
+                'content-type'             : 'application/json',
+                (HttpHeaders.AUTHORIZATION): 'Basic ' + Base64.encodeBase64URLSafeString((fakeIdentityService.client_username + ":" + fakeIdentityService.client_apikey).bytes)
+        ]
+
+        when: "user passes a request through repose"
+        MessageChain mc = deproxy.makeRequest(url: "$reposeEndpoint/servers/$reqTenant/", method: 'GET', headers: headers)
+
+        then: "request body sent from repose to the origin service should contain"
+        mc.receivedResponse.code == filterStatusCode.toString()
+        mc.handlings.size() == 0
+
+        where:
+        reqTenant | identityStatusCode                           | filterStatusCode
+        9400      | HttpServletResponse.SC_BAD_REQUEST           | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9401      | HttpServletResponse.SC_UNAUTHORIZED          | HttpServletResponse.SC_UNAUTHORIZED
+        9403      | HttpServletResponse.SC_FORBIDDEN             | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9404      | HttpServletResponse.SC_NOT_FOUND             | HttpServletResponse.SC_UNAUTHORIZED
+        9500      | HttpServletResponse.SC_INTERNAL_SERVER_ERROR | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9501      | HttpServletResponse.SC_NOT_IMPLEMENTED       | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9502      | HttpServletResponse.SC_BAD_GATEWAY           | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9503      | HttpServletResponse.SC_SERVICE_UNAVAILABLE   | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+        9504      | HttpServletResponse.SC_GATEWAY_TIMEOUT       | HttpServletResponse.SC_INTERNAL_SERVER_ERROR
+    }
+
+    def "When the request does have an x-auth-token, then still work with client-auth"() {
+        given: "the X-Auth-Token authentication header containing the User Token"
+        def headers = ['X-Auth-Token': fakeIdentityService.client_token]
+
+        when: "the request already has an x-auth-token header"
+        MessageChain mc = deproxy.makeRequest(url: reposeEndpoint, method: 'GET', headers: headers)
+
+        then: "get a token and validate it"
+        mc.receivedResponse.code == HttpServletResponse.SC_OK.toString()
+        mc.handlings.size() == 1
+        !mc.handlings[0].request.headers.getFirstValue(HttpHeaders.AUTHORIZATION)
+        !mc.receivedResponse.headers.getFirstValue(HttpHeaders.WWW_AUTHENTICATE)
+        mc.handlings[0].request.headers.getFirstValue("X-Auth-Token")
+    }
+}
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identityv3/projectidinuri/ProjectIdUriTest.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identityv3/projectidinuri/ProjectIdUriTest.groovy
new file mode 100644
index 0000000..17bdbaf
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identityv3/projectidinuri/ProjectIdUriTest.groovy
@@ -0,0 +1,183 @@
+package features.filters.identityv3.projectidinuri
+
+import framework.ReposeValveTest
+import framework.mocks.MockIdentityV3Service
+import org.joda.time.DateTime
+import org.rackspace.deproxy.Deproxy
+import org.rackspace.deproxy.MessageChain
+import org.rackspace.deproxy.Response
+import spock.lang.Unroll
+
+class ProjectIdUriTest extends ReposeValveTest{
+    def static originEndpoint
+    def static identityEndpoint
+    def static MockIdentityV3Service fakeIdentityV3Service
+
+    def setupSpec() {
+        deproxy = new Deproxy()
+        def params = properties.defaultTemplateParams
+        repose.configurationProvider.applyConfigs("common", params)
+        repose.configurationProvider.applyConfigs("features/filters/identityv3/common",params)
+        repose.configurationProvider.applyConfigs("features/filters/identityv3/projectidinuri/serviceroles", params)
+        repose.start()
+        waitUntilReadyToServiceRequests('401')
+
+        originEndpoint = deproxy.addEndpoint(properties.targetPort, 'origin service')
+        fakeIdentityV3Service = new MockIdentityV3Service(properties.identityPort, properties.targetPort)
+        identityEndpoint = deproxy.addEndpoint(properties.identityPort,
+                'identity service', null, fakeIdentityV3Service.handler)
+    }
+
+    def cleanupSpec() {
+        if(deproxy)
+            deproxy.shutdown()
+        if(repose)
+            repose.stop()
+    }
+
+    def setup(){
+        fakeIdentityV3Service.resetHandlers()
+    }
+
+    @Unroll("With project: #requestProject, response project: #responseProject, identity resp code (#authResponseCode), and group resp code (#groupResponseCode), return #responseCode")
+    def "when authenticating project id - fail"() {
+        given:
+        fakeIdentityV3Service.with {
+            client_token = UUID.randomUUID().toString()
+            tokenExpiresAt = DateTime.now().plusDays(1)
+            client_projectid = responseProject
+            service_admin_role = "not-admin"
+            client_userid = requestProject
+        }
+
+        if (authResponseCode != 200) {
+            fakeIdentityV3Service.validateTokenHandler = {
+                tokenId, request ->
+                    new Response(authResponseCode)
+            }
+        }
+
+        if (groupResponseCode != 200) {
+            fakeIdentityV3Service.getGroupsHandler = {
+                userId, request ->
+                    new Response(groupResponseCode)
+            }
+        }
+
+        when:
+        "User passes a request through repose with request project: $requestProject, response project: $responseProject in a role that is not bypassed"
+        MessageChain mc = deproxy.makeRequest(
+                url: "$reposeEndpoint/servers/$requestProject/",
+                method: 'GET',
+                headers: [
+                        'content-type': 'application/json',
+                        'X-Subject-Token': fakeIdentityV3Service.client_token
+                ]
+        )
+
+        then: "Request body sent from repose to the origin service should contain"
+        mc.receivedResponse.code == responseCode
+        mc.receivedResponse.headers.contains("www-authenticate") == x_www_auth
+
+        where:
+        requestProject | responseProject | authResponseCode | groupResponseCode | x_www_auth | responseCode
+        713            | 713             | 500              | 200               | false      | "500"
+        714            | 714             | 404              | 200               | true       | "401"
+        715            | 715             | 200              | 404               | false      | "500"
+        716            | 716             | 200              | 500               | false      | "500"
+        711            | 712             | 200              | 200               | true       | "401"
+    }
+
+    @Unroll("With Project ID: #requestProject, return from identity with response project: #responseProject, and role: #serviceAdminRole, return 200")
+    def "when authenticating project id and roles that bypass"() {
+        given:
+        fakeIdentityV3Service.with {
+            client_token = UUID.randomUUID().toString()
+            tokenExpiresAt = DateTime.now().plusDays(1)
+            client_projectid = responseProject
+            service_admin_role = serviceAdminRole
+            client_userid = requestProject
+        }
+
+        when: "User passes a request through repose with request tenant: $requestProject, response tenant: $responseProject in a bypassed role = $serviceAdminRole"
+        MessageChain mc = deproxy.makeRequest(
+                url: "$reposeEndpoint/servers/$requestProject/",
+                method: 'GET',
+                headers: [
+                        'content-type': 'application/json',
+                        'X-Subject-Token': fakeIdentityV3Service.client_token
+                ]
+        )
+
+        then: "Request body sent from repose to the origin service should contain"
+        mc.receivedResponse.code == responseCode
+        mc.handlings.size() == 1
+        mc.handlings[0].endpoint == originEndpoint
+        def request2 = mc.handlings[0].request
+        request2.headers.getFirstValue("x-forwarded-for") == "127.0.0.1"
+        request2.headers.getFirstValue("x-project-id") == responseProject.toString()
+        request2.headers.contains("x-token-expires")
+        request2.headers.getFirstValue("x-pp-user") == requestProject.toString()
+        request2.headers.contains("x-roles")
+        request2.headers.getFirstValue("x-authorization") == "Proxy"
+        request2.headers.getFirstValue("x-user-name") == "username"
+
+        mc.receivedResponse.headers.contains("www-authenticate") == false
+
+        where:
+        requestProject | responseProject  | serviceAdminRole      | responseCode
+        717            | 717              | "not-admin"           | "200"
+        718            | 719              | "service:admin-role1" | "200"
+        720            | 720              | "service:admin-role1" | "200"
+    }
+
+    def "Should not split request headers according to rfc"() {
+        given:
+        def reqHeaders = ["user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_4) " +
+                "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.65 Safari/537.36", "x-pp-user": "usertest1," +
+                "usertest2, usertest3", "accept": "application/xml;q=1 , application/json;q=0.5"]
+        Map<String, String> headers = ["X-Roles": "group1", "Content-Type": "application/xml"]
+        fakeIdentityV3Service.with {
+            client_token = UUID.randomUUID().toString()
+            tokenExpiresAt = DateTime.now().plusDays(1)
+            client_projectid = 720
+            client_userid = 720
+        }
+
+        when: "User passes a request through repose"
+        def mc = deproxy.makeRequest(url:reposeEndpoint + "/servers/720/", method:'GET', headers:['content-type': 'application/json', 'X-Subject-Token': fakeIdentityV3Service.client_token] + reqHeaders)
+
+        then:
+        mc.handlings.size() == 1
+        mc.handlings[0].request.headers.getCountByName("user-agent") == 1
+        mc.handlings[0].request.headers.getCountByName("x-pp-user") == 4
+        mc.handlings[0].request.headers.getCountByName("accept") == 2
+    }
+
+    def "Should not split response headers according to rfc"() {
+        given: "Origin service returns headers "
+        def respHeaders = ["location": "http://somehost.com/blah?a=b,c,d", "via": "application/xml;q=0.3, application/json;q=1"]
+        def xmlResp = { request -> return new Response(201, "Created", respHeaders) }
+        Map<String, String> headers = ["X-Roles": "group1", "Content-Type": "application/xml"]
+        fakeIdentityV3Service.with {
+            client_token = UUID.randomUUID().toString()
+            tokenExpiresAt = DateTime.now().plusDays(1)
+            client_projectid = 123
+            client_userid = 123
+        }
+
+        when: "User passes a request through repose"
+        def mc =
+                deproxy.makeRequest(
+                        url: reposeEndpoint + "/servers/123/",
+                        method: 'GET',
+                        headers: ['content-type': 'application/json', 'X-Subject-Token': fakeIdentityV3Service.client_token],
+                        defaultHandler: xmlResp
+                )
+
+        then:
+        mc.receivedResponse.code == "201"
+        mc.receivedResponse.headers.findAll("location").size() == 1
+        mc.receivedResponse.headers.findAll("via").size() == 1
+    }
+}
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identityv3/projectidinuri/ProjectIdUriWithoutBypassRolesTest.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identityv3/projectidinuri/ProjectIdUriWithoutBypassRolesTest.groovy
new file mode 100644
index 0000000..9814a68
--- /dev/null
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/features/filters/identityv3/projectidinuri/ProjectIdUriWithoutBypassRolesTest.groovy
@@ -0,0 +1,121 @@
+package features.filters.identityv3.projectidinuri
+
+import framework.ReposeValveTest
+import framework.mocks.MockIdentityV3Service
+import org.joda.time.DateTime
+import org.rackspace.deproxy.Deproxy
+import org.rackspace.deproxy.MessageChain
+import org.rackspace.deproxy.Response
+import spock.lang.Unroll
+
+class ProjectIdUriWithoutBypassRolesTest extends ReposeValveTest{
+    def static originEndpoint
+    def static identityEndpoint
+    def static MockIdentityV3Service fakeIdentityV3Service
+
+    def setupSpec() {
+        deproxy = new Deproxy()
+        def params = properties.defaultTemplateParams
+        repose.configurationProvider.applyConfigs("common", params)
+        repose.configurationProvider.applyConfigs("features/filters/identityv3/common",params)
+        repose.configurationProvider.applyConfigs("features/filters/identityv3/projectidinuri/noserviceroles", params)
+        repose.start()
+        waitUntilReadyToServiceRequests('401')
+
+        originEndpoint = deproxy.addEndpoint(properties.targetPort, 'origin service')
+        fakeIdentityV3Service = new MockIdentityV3Service(properties.identityPort, properties.targetPort)
+        identityEndpoint = deproxy.addEndpoint(properties.identityPort,
+                'identity service', null, fakeIdentityV3Service.handler)
+    }
+
+    def cleanupSpec() {
+        if(deproxy)
+            deproxy.shutdown()
+        if(repose)
+            repose.stop()
+    }
+
+    def setup(){
+        fakeIdentityV3Service.resetHandlers()
+    }
+
+
+    @Unroll("Given project ID: #requestProject, response project ID: #responseProject, identity resp code: #authResponseCode, identity group resp code: #groupResponseCode, return #responseCode")
+    def "when authenticating project id and without service-admin - fail"() {
+
+        given:
+        fakeIdentityV3Service.with {
+            client_token = UUID.randomUUID().toString()
+            tokenExpiresAt = DateTime.now().plusDays(1)
+            client_projectid = responseProject
+            client_userid = requestProject
+            service_admin_role = "not-admin"
+        }
+
+        if(authResponseCode != 200){
+            fakeIdentityV3Service.validateTokenHandler = {
+                tokenId, request ->
+                    new Response(authResponseCode)
+            }
+        }
+
+        if(groupResponseCode != 200){
+            fakeIdentityV3Service.getGroupsHandler = {
+                userId, request ->
+                    new Response(groupResponseCode)
+            }
+        }
+
+        when: "User passes a request through repose"
+        MessageChain mc = deproxy.makeRequest(
+                url: "$reposeEndpoint/servers/$requestProject/",
+                method: 'GET',
+                headers: [
+                        'content-type': 'application/json',
+                        'X-Subject-Token': fakeIdentityV3Service.client_token
+                ]
+        )
+
+        then: "Request body sent from repose to the origin service should contain"
+        mc.receivedResponse.code == responseCode
+        mc.handlings.size() == 0
+
+        where:
+        requestProject | responseProject  | authResponseCode | groupResponseCode | x_www_auth | responseCode
+        813            | 813              | 500              | 200               | false      | "500"
+        814            | 814              | 404              | 200               | true       | "401"
+        815            | 815              | 200              | 404               | false      | "500"
+        816            | 816              | 200              | 500               | false      | "500"
+        811            | 812              | 200              | 200               | true       | "401"
+
+
+    }
+
+    def "When authenticating a valid project id and without bypass roles, repose should return a 200"() {
+        given:
+        fakeIdentityV3Service.with {
+            client_token = UUID.randomUUID().toString()
+            tokenExpiresAt = DateTime.now().plusDays(1)
+            client_projectid = 999
+            client_userid = 999
+            service_admin_role = "non-admin"
+        }
+
+        when: "User passes a request through repose"
+        MessageChain mc = deproxy.makeRequest(
+                url:"$reposeEndpoint/servers/999/",
+                method:'GET',
+                headers:['content-type': 'application/json', 'X-Subject-Token': fakeIdentityV3Service.client_token])
+
+        then: "Request body sent from repose to the origin service should contain"
+        mc.receivedResponse.code == "200"
+        mc.handlings.size() == 1
+        mc.handlings[0].endpoint == originEndpoint
+        def request2 = mc.handlings[0].request
+        request2.headers.contains("x-subject-token")
+        !request2.headers.contains("x-identity-status")
+        request2.headers.contains("x-authorization")
+        request2.headers.getFirstValue("x-authorization") == "Proxy"
+    }
+
+}
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityService.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityService.groovy
index 4c1ca18..8d4cb8b 100644
--- a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityService.groovy
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityService.groovy
@@ -43,0 +44 @@
+    boolean checkTokenValid = false;
@@ -114,0 +116 @@
+    def client_apikey = 'this-is-the-api-key';
@@ -384,9 +386,10 @@
-        try {
-
-            final StreamSource sampleSource = new StreamSource(new ByteArrayInputStream(request.body.getBytes()));
-            validator.validate(sampleSource);
-
-        } catch (Exception e) {
-
-            println("Admin token XSD validation error: " + e);
-            return new Response(400);
+        // Since the SchemaFactory does not appear to import parent XSD's,
+        // the validation is skipped for the API Key Credentials that are defined externally.
+        if(xml && !(request.body.toString().contains("apiKeyCredentials"))) {
+            try {
+                final StreamSource sampleSource = new StreamSource(new ByteArrayInputStream(request.body.getBytes()));
+                validator.validate(sampleSource);
+            } catch (Exception e) {
+                println("Admin token XSD validation error: " + e);
+                return new Response(400);
+            }
@@ -395,9 +398 @@
-        def params = [
-                expires     : getExpires(),
-                userid      : admin_userid,
-                username    : admin_username,
-                tenant      : admin_tenant,
-                tenanttwo   : admin_tenant,
-                token       : admin_token,
-                serviceadmin: service_admin_role
-        ];
+        def params
@@ -404,0 +400,48 @@
+        def isTokenChecked = true
+        // IF the body of the request should be evaluated to determine the validity of the Token, THEN ...
+        // ELSE the just use the isTokenValid value.
+        if(checkTokenValid) {
+            // IF the body is a Client userName/apiKey request,
+            // THEN return the Client token response;
+            // ELSE /*IF the body is userName/passWord request*/,
+            // THEN return the Admin token response.
+            if (request.body.contains("username") &&
+                    request.body.contains(client_username) &&
+                    request.body.contains("apiKey") &&
+                    request.body.contains(client_apikey)) {
+                params = [
+                        expires     : getExpires(),
+                        userid      : client_userid,
+                        username    : client_username,
+                        tenant      : client_tenant,
+                        tenanttwo   : client_tenant,
+                        token       : client_token,
+                        serviceadmin: service_admin_role
+                ];
+            } else if (request.body.contains("username") &&
+                    request.body.contains(admin_username) /*&&
+                request.body.contains("password") &&
+                request.body.contains(admin_password)*/) {
+                params = [
+                        expires     : getExpires(),
+                        userid      : admin_userid,
+                        username    : admin_username,
+                        tenant      : admin_tenant,
+                        tenanttwo   : admin_tenant,
+                        token       : admin_token,
+                        serviceadmin: service_admin_role
+                ];
+            } else {
+                isTokenChecked = false
+            }
+        } else {
+            params = [
+                    expires     : getExpires(),
+                    userid      : admin_userid,
+                    username    : admin_username,
+                    tenant      : admin_tenant,
+                    tenanttwo   : admin_tenant,
+                    token       : admin_token,
+                    serviceadmin: service_admin_role
+            ];
+        }
@@ -416 +459 @@
-        if (isTokenValid) {
+        if (isTokenValid && isTokenChecked) {
@@ -424 +467 @@
-            code = 404
+            code = 401
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityV3Service.groovy b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityV3Service.groovy
index 2a83c9d..3224a70 100644
--- a/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityV3Service.groovy
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/groovy/framework/mocks/MockIdentityV3Service.groovy
@@ -121,0 +122 @@
+    def client_projectid2 = "openstack-project"
@@ -316,0 +318 @@
+                projectid2  : client_projectid2,
@@ -358,0 +361 @@
+                projectid2  : client_projectid2,
@@ -555 +558,2 @@
-                    "name": "admin"
+                    "name": "\${serviceadmin}",
+                     "RAX-AUTH:projectId": "\${projectid}"
@@ -562 +566,2 @@
-                    "name": "member"
+                    "name": "\${projectid2}",
+                    "project_id": "\${projectid2}"
diff --git a/repose-aggregator/functional-tests/spock-functional-test/src/test/resources/log4j.properties b/repose-aggregator/functional-tests/spock-functional-test/src/test/resources/log4j.properties
index e694a6b..257fa9f 100755
--- a/repose-aggregator/functional-tests/spock-functional-test/src/test/resources/log4j.properties
+++ b/repose-aggregator/functional-tests/spock-functional-test/src/test/resources/log4j.properties
@@ -4 +4 @@
-log4j.rootLogger=INFO, defaultFile
+log4j.rootLogger=INFO, defaultFile, consoleOut
@@ -6 +6 @@
-#Jetty Loggin Turned Off
+#Jetty Logging Turned Off
@@ -9,0 +10,5 @@
+
+# Console
+log4j.appender.consoleOut=org.apache.log4j.ConsoleAppender
+log4j.appender.consoleOut.layout=org.apache.log4j.PatternLayout
+log4j.appender.consoleOut.layout.ConversionPattern=%d %-4r [%t] %-5p %c %x - %m%n
@@ -18 +22,0 @@
-
diff --git a/repose-aggregator/installation/deb/cli-utils/pom.xml b/repose-aggregator/installation/deb/cli-utils/pom.xml
index 385d2a7..67944f1 100644
--- a/repose-aggregator/installation/deb/cli-utils/pom.xml
+++ b/repose-aggregator/installation/deb/cli-utils/pom.xml
@@ -9 +9 @@
-        <version>7.0.0-SNAPSHOT</version>
+        <version>6.1.1.0-SNAPSHOT</version>
diff --git a/repose-aggregator/installation/rpm/cli-utils/pom.xml b/repose-aggregator/installation/rpm/cli-utils/pom.xml
index bb46f24..311d3e9 100644
--- a/repose-aggregator/installation/rpm/cli-utils/pom.xml
+++ b/repose-aggregator/installation/rpm/cli-utils/pom.xml
@@ -9 +9 @@
-        <version>7.0.0-SNAPSHOT</version>
+        <version>6.1.1.0-SNAPSHOT</version>
diff --git a/repose-aggregator/installation/rpm/ug-repose-filters/pom.xml b/repose-aggregator/installation/rpm/ug-repose-filters/pom.xml
index 1cd349e..784214d 100644
--- a/repose-aggregator/installation/rpm/ug-repose-filters/pom.xml
+++ b/repose-aggregator/installation/rpm/ug-repose-filters/pom.xml
@@ -9 +9 @@
-        <version>7.0.0-SNAPSHOT</version>
+        <version>6.1.1.0-SNAPSHOT</version>
diff --git a/repose-aggregator/installation/rpm/ug-repose-valve/pom.xml b/repose-aggregator/installation/rpm/ug-repose-valve/pom.xml
index c672827..d0c9711 100644
--- a/repose-aggregator/installation/rpm/ug-repose-valve/pom.xml
+++ b/repose-aggregator/installation/rpm/ug-repose-valve/pom.xml
@@ -9 +9 @@
-        <version>7.0.0-SNAPSHOT</version>
+        <version>6.1.1.0-SNAPSHOT</version>

