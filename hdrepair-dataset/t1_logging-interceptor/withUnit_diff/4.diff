diff --git a/src/main/java/com/github/t1/log/LogConverterCollector.java b/src/main/java/com/github/t1/log/LogConverterCollector.java
index bd83426..8cf535f 100644
--- a/src/main/java/com/github/t1/log/LogConverterCollector.java
+++ b/src/main/java/com/github/t1/log/LogConverterCollector.java
@@ -20 +20 @@
-        Map<Class<?>, LogConverter<Object>> converters = new HashMap<>();
+        Map<Class<?>, LogConverter<Object>> converters = new LinkedHashMap<>();
diff --git a/src/test/java/com/github/t1/log/LogConverterCollectorTest.java b/src/test/java/com/github/t1/log/LogConverterCollectorTest.java
index dc41d58..f362183 100644
--- a/src/test/java/com/github/t1/log/LogConverterCollectorTest.java
+++ b/src/test/java/com/github/t1/log/LogConverterCollectorTest.java
@@ -3,2 +2,0 @@
-import static com.github.t1.log.LogLevel.*;
-import static org.hamcrest.CoreMatchers.*;
@@ -8 +5,0 @@
-import java.lang.reflect.Method;
@@ -19 +15,0 @@
-import org.mockito.invocation.InvocationOnMock;
@@ -21,2 +16,0 @@
-import org.mockito.stubbing.Answer;
-import org.slf4j.MDC;
@@ -27,32 +20,0 @@
-    private final class StoreMdcAnswer implements Answer<Void> {
-        private final String key;
-        private final String[] result;
-
-        private StoreMdcAnswer(String key, String[] result) {
-            this.key = key;
-            this.result = result;
-        }
-
-        @Override
-        public Void answer(InvocationOnMock invocation) throws Throwable {
-            result[0] = MDC.get(key);
-            return null;
-        }
-    }
-
-    private class Nested {
-        @Logged
-        public void implicit() {}
-
-        @Logged(logger = Nested.class)
-        public void explicit() {}
-    }
-
-    private class Inner {
-        @Logged
-        public void implicit() {}
-
-        @Logged(logger = Inner.class)
-        public void explicit() {}
-    }
-
@@ -66,16 +27,0 @@
-    @Before
-    public void setup() {
-        givenConverters(new PojoConverter());
-    }
-
-    // sometimes I hate java generics
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private void givenConverters(LogConverter... converters) {
-        List<LogConverter<Object>> list = new ArrayList<>();
-        for (LogConverter converter : converters) {
-            list.add(converter);
-        }
-        when(converterInstances.iterator()).thenReturn(list.iterator());
-        interceptor.loadConverters();
-    }
-
@@ -85,15 +31,6 @@
-    private void whenMethod(Object target, String methodName, Object... args) throws ReflectiveOperationException {
-        Method method = target.getClass().getMethod(methodName, types(args));
-        whenMethod(method, target, args);
-    }
-
-    private void whenMethod(Method method, Object target, Object... args) {
-        when(context.getMethod()).thenReturn(method);
-        when(context.getTarget()).thenReturn(target);
-        when(context.getParameters()).thenReturn(args);
-    }
-
-    private Class<?>[] types(Object[] objects) {
-        Class<?>[] result = new Class[objects.length];
-        for (int i = 0; i < objects.length; i++) {
-            result[i] = objects[i].getClass();
+    private void givenConverters(LogConverter<?>... converters) {
+        List<LogConverter<Object>> list = new ArrayList<>();
+        for (LogConverter<?> converter : converters) {
+            @SuppressWarnings("unchecked")
+            LogConverter<Object> c = (LogConverter<Object>) converter;
+            list.add(c);
@@ -101,368 +38 @@
-        return result;
-    }
-
-    @Test
-    public void shouldLogALongMethodNameWithSpaces() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithALongName() {}
-        }
-        whenMethod(new Container(), "methodWithALongName");
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("method with a long name", new Object[0]);
-    }
-
-    @Test
-    public void shouldLogAnAnnotatedMethod() throws Exception {
-        class Container {
-            @Logged("bar")
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("bar", new Object[0]);
-    }
-
-    @Test
-    public void shouldLogReturnValue() throws Exception {
-        class Container {
-            @Logged
-            public boolean methodWithReturnType() {
-                return true;
-            }
-        }
-        whenMethod(new Container(), "methodWithReturnType");
-        when(context.proceed()).thenReturn(true);
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("return {}", new Object[] { true });
-    }
-
-    @Test
-    public void shouldLogException() throws Exception {
-        class Container {
-            @Logged
-            public boolean methodThatMightFail() {
-                return true;
-            }
-        }
-        whenMethod(new Container(), "methodThatMightFail");
-        RuntimeException exception = new RuntimeException("foo");
-        when(context.proceed()).thenThrow(exception);
-
-        try {
-            interceptor.aroundInvoke(context);
-            fail("RuntimeException expected");
-        } catch (RuntimeException e) {
-            // that's okay
-        }
-        verify(logger).debug("failed", exception);
-    }
-
-    @Test
-    public void shouldNotLogVoidReturnValue() throws Exception {
-        class Container {
-            @Logged
-            public void voidReturnType() {}
-        }
-        whenMethod(new Container(), "voidReturnType");
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("void return type", new Object[0]);
-        verify(logger, atLeast(0)).isDebugEnabled();
-        verifyNoMoreInteractions(logger);
-    }
-
-    @Test
-    public void shouldLogIntParameter() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithIntArgument(int i) {}
-        }
-        Method method = Container.class.getMethod("methodWithIntArgument", int.class);
-        whenMethod(method, new Container(), 3);
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("method with int argument {}", new Object[] { 3 });
-    }
-
-    @Test
-    public void shouldLogIntegerParameter() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithIntegerArgument(Integer i) {}
-        }
-        whenMethod(new Container(), "methodWithIntegerArgument", 3);
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("method with integer argument {}", new Object[] { 3 });
-    }
-
-    @Test
-    public void shouldLogTwoParameters() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithTwoParameters(String one, String two) {}
-        }
-        whenMethod(new Container(), "methodWithTwoParameters", "foo", "bar");
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).debug("method with two parameters {} {}", new Object[] { "foo", "bar" });
-    }
-
-    @Test
-    public void shouldNotLogWhenOff() throws Exception {
-        class Container {
-            @Logged(level = OFF)
-            public void atOff() {}
-        }
-        whenMethod(new Container(), "atOff");
-
-        interceptor.aroundInvoke(context);
-
-        verifyNoMoreInteractions(logger);
-    }
-
-    @Test
-    public void shouldNotLogWhenDebugIsNotEnabled() throws Exception {
-        class Container {
-            @Logged(level = DEBUG)
-            public void atDebug() {}
-        }
-        when(logger.isDebugEnabled()).thenReturn(false);
-        whenMethod(new Container(), "atDebug");
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger, atLeast(0)).isDebugEnabled();
-        verifyNoMoreInteractions(logger);
-    }
-
-    @Test
-    public void shouldLogInfoWhenInfoIsEnabled() throws Exception {
-        class Container {
-            @Logged(level = INFO)
-            public void atInfo() {}
-        }
-        when(logger.isInfoEnabled()).thenReturn(true);
-        whenMethod(new Container(), "atInfo");
-
-        interceptor.aroundInvoke(context);
-
-        verify(logger).info("at info", new Object[0]);
-    }
-
-    @Test
-    public void shouldUseExplicitLoggerClass() throws Exception {
-        class Container {
-            @Logged(logger = Integer.class)
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(Integer.class, loggerType);
-    }
-
-    @Test
-    public void shouldNotUnwrapUseExplicitLocalLoggerClass() throws Exception {
-        class Container {
-            @Logged(logger = Container.class)
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(Container.class, loggerType);
-    }
-
-    @Test
-    public void shouldNotUnwrapUseExplicitNestedLoggerClass() throws Exception {
-        whenMethod(new Nested(), "explicit");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(Nested.class, loggerType);
-    }
-
-    @Test
-    public void shouldNotUnwrapUseExplicitInnerLoggerClass() throws Exception {
-        whenMethod(new Inner(), "explicit");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(Inner.class, loggerType);
-    }
-
-    @Test
-    public void shouldNotUnwrapUseExplicitDollarLoggerClass() throws Exception {
-        class Container {
-            @Logged(logger = Dollar$Type.class)
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(Dollar$Type.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToLoggerClass() throws Exception {
-        whenMethod(new LogConverterCollectorTest(), "shouldDefaultToLoggerClass");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(LogConverterCollectorTest.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToContainerOfLocalLoggerClass() throws Exception {
-        class Container {
-            @Logged
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(LogConverterCollectorTest.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToContainerOfNestedLoggerClass() throws Exception {
-        whenMethod(new Nested(), "implicit");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(LogConverterCollectorTest.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToContainerOfInnerLoggerClass() throws Exception {
-        whenMethod(new Inner(), "implicit");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(LogConverterCollectorTest.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToDoubleContainerLoggerClass() throws Exception {
-        class Outer {
-            class Inner {
-                @Logged
-                public void foo() {}
-            }
-        }
-        whenMethod(new Outer().new Inner(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(LogConverterCollectorTest.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToAnonymousLoggerClass() throws Exception {
-        whenMethod(new Runnable() {
-            @Override
-            @Logged
-            public void run() {}
-        }, "run");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(LogConverterCollectorTest.class, loggerType);
-    }
-
-    @Test
-    public void shouldDefaultToDollarLoggerClass() throws Exception {
-        whenMethod(new Dollar$Type(), "foo");
-
-        interceptor.aroundInvoke(context);
-
-        assertEquals(Dollar$Type.class, loggerType);
-    }
-
-    @Test
-    public void shouldLogContextParameter() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithLogContextParameter(@LogContext("var") String one, @Deprecated String two) {}
-        }
-        whenMethod(new Container(), "methodWithLogContextParameter", "foo", "bar");
-        final String[] result = new String[1];
-        when(context.proceed()).then(new StoreMdcAnswer("var", result));
-
-        MDC.put("var", "bar");
-        interceptor.aroundInvoke(context);
-        assertEquals("bar", MDC.get("var"));
-
-        verify(logger).debug("method with log context parameter {} {}", new Object[] { "foo", "bar" });
-        assertEquals("foo", result[0]);
-    }
-
-    @Test
-    public void shouldLogTwoContextParameters() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithLogContextParameter(@LogContext("var1") String one, @LogContext("var2") String two) {}
-        }
-        whenMethod(new Container(), "methodWithLogContextParameter", "foo", "bar");
-        final String[] result1 = new String[1];
-        final String[] result2 = new String[1];
-        when(context.proceed()).then(new Answer<Void>() {
-            @Override
-            public Void answer(InvocationOnMock invocation) throws Throwable {
-                result1[0] = MDC.get("var1");
-                result2[0] = MDC.get("var2");
-                return null;
-            }
-        });
-
-        MDC.put("var1", "old1");
-        MDC.put("var2", "old2");
-        interceptor.aroundInvoke(context);
-        assertEquals("old1", MDC.get("var1"));
-        assertEquals("old2", MDC.get("var2"));
-
-        verify(logger).debug("method with log context parameter {} {}", new Object[] { "foo", "bar" });
-        assertEquals("foo", result1[0]);
-        assertEquals("bar", result2[0]);
-    }
-
-    @Test
-    public void shouldRestoreMdcValue() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithLogContextParameter(@LogContext("foo") String foo) {}
-        }
-        whenMethod(new Container(), "methodWithLogContextParameter", "newvalue");
-
-        MDC.put("foo", "oldvalue");
-        interceptor.aroundInvoke(context);
-        assertEquals("oldvalue", MDC.get("foo"));
-    }
-
-    @Test
-    public void shouldRestoreNullMdcValue() throws Exception {
-        class Container {
-            @Logged
-            public void methodWithLogContextParameter(@LogContext("var") String one, String two) {}
-        }
-        whenMethod(new Container(), "methodWithLogContextParameter", "foo", "bar");
-
-        MDC.remove("var"); // just to make sure with other tests running before
-        interceptor.aroundInvoke(context);
-        assertEquals(null, MDC.get("var"));
+        when(converterInstances.iterator()).thenReturn(list.iterator());
@@ -488,0 +59,2 @@
+
+        collector.loadConverters();
@@ -514,4 +85,0 @@
-        class Container {
-            @Logged
-            public void foo(@LogContext(value = "foobar") DupPojo pojo) {}
-        }
@@ -519,3 +86,0 @@
-        whenMethod(new Container(), "foo", new DupPojo("a"));
-        final String[] result = new String[1];
-        when(context.proceed()).then(new StoreMdcAnswer("foobar", result));
@@ -523 +88 @@
-        interceptor.aroundInvoke(context);
+        Map<Class<?>, LogConverter<Object>> map = collector.loadConverters();
@@ -525,68 +90 @@
-        assertThat(result[0], either(is("a!1")).or(is("a!2")));
-    }
-
-    @LogConverterType(Pojo.class)
-    static class PojoConverter implements LogConverter<Pojo> {
-        @Override
-        public String convert(Pojo object) {
-            return object.one;
-        }
-    }
-
-    @Test
-    public void shouldConvertLogContextParameter() throws Exception {
-        class Container {
-            @Logged
-            public void foo(@LogContext(value = "foobar") Pojo pojo) {}
-        }
-        whenMethod(new Container(), "foo", new Pojo("a", "b"));
-        final String[] result = new String[1];
-        when(context.proceed()).then(new StoreMdcAnswer("foobar", result));
-
-        MDC.put("foobar", "bar");
-        interceptor.aroundInvoke(context);
-        assertEquals("bar", MDC.get("foobar"));
-
-        verify(logger).debug("foo {}", new Object[] { new Pojo("a", "b") });
-        assertEquals("a", result[0]);
-    }
-
-    @Test
-    public void shouldFindAddALogContextVariable() throws Exception {
-        class Container {
-            @Logged
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-        final String[] result = new String[1];
-        when(context.proceed()).then(new StoreMdcAnswer("foo", result));
-
-        LogContextVariable variable = new LogContextVariable("foo", "baz");
-        when(variables.iterator()).thenReturn(Collections.<LogContextVariable> singletonList(variable).iterator());
-
-        MDC.put("foo", "bar");
-        interceptor.aroundInvoke(context);
-        assertEquals("bar", MDC.get("foo"));
-
-        verify(logger).debug("foo", new Object[0]);
-        assertEquals("baz", result[0]);
-    }
-
-    @Test
-    public void shouldSkipNullLogContextVariable() throws Exception {
-        class Container {
-            @Logged
-            public void foo() {}
-        }
-        whenMethod(new Container(), "foo");
-        final String[] result = new String[1];
-        when(context.proceed()).then(new StoreMdcAnswer("foo", result));
-
-        when(variables.iterator()).thenReturn(Collections.<LogContextVariable> singletonList(null).iterator());
-
-        MDC.put("foo", "bar");
-        interceptor.aroundInvoke(context);
-        assertEquals("bar", MDC.get("foo"));
-
-        verify(logger).debug("foo", new Object[0]);
-        assertEquals("bar", result[0]);
+        assertEquals(DuplicatePojoConverter2.class, map.get(DupPojo.class).getClass());
diff --git a/src/test/java/com/github/t1/log/LoggingInterceptorTest.java b/src/test/java/com/github/t1/log/LoggingInterceptorTest.java
index a9e8a45..8e2b84d 100644
--- a/src/test/java/com/github/t1/log/LoggingInterceptorTest.java
+++ b/src/test/java/com/github/t1/log/LoggingInterceptorTest.java
@@ -4 +3,0 @@
-import static org.hamcrest.CoreMatchers.*;
@@ -88,4 +87,6 @@
-    private void givenConverters(LogConverter... converters) {
-        Map<LogConverter<Object>> list = new ArrayList<>();
-        for (LogConverter converter : converters) {
-            list.add(converter);
+    private void givenConverters(LogConverter... defined) {
+        for (LogConverter converter : defined) {
+            Class<?>[] types = converter.getClass().getAnnotation(LogConverterType.class).value();
+            for (Class<?> type : types) {
+                when(converters.get(type)).thenReturn(converter);
+            }
@@ -93,2 +93,0 @@
-        when(converterInstances.iterator()).thenReturn(list.iterator());
-        interceptor.loadConverters();
@@ -489,52 +487,0 @@
-    }
-
-    static class UnannotatedPojoConverter implements LogConverter<Pojo> {
-        @Override
-        public String convert(Pojo object) {
-            return object.one;
-        }
-    }
-
-    @Test
-    public void shouldFailToLoadUnannotatedConverter() throws Exception {
-        expectedException.expect(RuntimeException.class);
-        expectedException.expectMessage("must be annotated as @" + LogConverterType.class.getName());
-
-        givenConverters(new UnannotatedPojoConverter());
-    }
-
-    @Value
-    static class DupPojo {
-        String value;
-    }
-
-    @LogConverterType(DupPojo.class)
-    static class DuplicatePojoConverter1 implements LogConverter<DupPojo> {
-        @Override
-        public String convert(DupPojo object) {
-            return object.value + "!1";
-        }
-    }
-
-    @LogConverterType(DupPojo.class)
-    static class DuplicatePojoConverter2 implements LogConverter<DupPojo> {
-        @Override
-        public String convert(DupPojo object) {
-            return object.value + "!2";
-        }
-    }
-
-    @Test
-    public void shouldPickOneDuplicateConverter() throws Exception {
-        class Container {
-            @Logged
-            public void foo(@LogContext(value = "foobar") DupPojo pojo) {}
-        }
-        givenConverters(new DuplicatePojoConverter1(), new DuplicatePojoConverter2());
-        whenMethod(new Container(), "foo", new DupPojo("a"));
-        final String[] result = new String[1];
-        when(context.proceed()).then(new StoreMdcAnswer("foobar", result));
-
-        interceptor.aroundInvoke(context);
-
-        assertThat(result[0], either(is("a!1")).or(is("a!2")));

