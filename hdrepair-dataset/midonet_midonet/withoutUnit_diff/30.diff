diff --git a/midolman/src/main/java/org/midonet/midolman/layer4/NatLeaseManager.java b/midolman/src/main/java/org/midonet/midolman/layer4/NatLeaseManager.java
index daeeab3..1b082bc 100644
--- a/midolman/src/main/java/org/midonet/midolman/layer4/NatLeaseManager.java
+++ b/midolman/src/main/java/org/midonet/midolman/layer4/NatLeaseManager.java
@@ -518 +518 @@
-        int numTries = MAX_PORT_ALLOC_ATTEMPTS;
+        int numTries = 0;
diff --git a/midolman/src/main/scala/org/midonet/midolman/topology/VirtualToPhysicalMapper.scala b/midolman/src/main/scala/org/midonet/midolman/topology/VirtualToPhysicalMapper.scala
index 86a1f4c..c249e63 100644
--- a/midolman/src/main/scala/org/midonet/midolman/topology/VirtualToPhysicalMapper.scala
+++ b/midolman/src/main/scala/org/midonet/midolman/topology/VirtualToPhysicalMapper.scala
@@ -123,18 +122,0 @@
-/**
- * The Virtual-Physical Mapping is a component that interacts with Midonet
- * state management cluster and is responsible for those pieces of state that
- * map physical world entities to virtual world entities.
- *
- * In particular, the VPM can be used to:
- * <ul>
- * <li>determine what virtual port UUIDs should be mapped to what interfaces
- * (by interface name) on a given physical host. </li>
- * <li> determine what physical hosts are subscribed to a given PortSet. </li>
- * <li> determine what local virtual ports are part of a PortSet.</li>
- * <li> determine all the virtual ports that are part of a PortSet.</li>
- * <li> determine whether a virtual port is reachable and at what physical host
- * (a virtual port is reachable if the responsible host has mapped the vport ID
- * to its corresponding local interface and the interface is ready to receive).
- * </li>
- * </ul>
- */
@@ -203,0 +186,18 @@
+/**
+ * The Virtual-Physical Mapping is a component that interacts with Midonet
+ * state management cluster and is responsible for those pieces of state that
+ * map physical world entities to virtual world entities.
+ *
+ * In particular, the VPM can be used to:
+ * <ul>
+ * <li>determine what virtual port UUIDs should be mapped to what interfaces
+ * (by interface name) on a given physical host. </li>
+ * <li> determine what physical hosts are subscribed to a given PortSet. </li>
+ * <li> determine what local virtual ports are part of a PortSet.</li>
+ * <li> determine all the virtual ports that are part of a PortSet.</li>
+ * <li> determine whether a virtual port is reachable and at what physical host
+ * (a virtual port is reachable if the responsible host has mapped the vport ID
+ * to its corresponding local interface and the interface is ready to receive).
+ * </li>
+ * </ul>
+ */
diff --git a/midolman/src/test/scala/org/midonet/midolman/topology/DeviceHandlerTest.scala b/midolman/src/test/scala/org/midonet/midolman/topology/DeviceHandlerTest.scala
new file mode 100644
index 0000000..66c2b55
--- /dev/null
+++ b/midolman/src/test/scala/org/midonet/midolman/topology/DeviceHandlerTest.scala
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *                                                                            *
+ *      Copyright (c) 2013 Midokura Europe SARL, All Rights Reserved.         *
+ *                                                                            *
+ ******************************************************************************/
+
+package org.midonet.midolman.topology
+
+import java.util.UUID;
+
+import akka.actor.ActorSystem
+import akka.testkit.TestKit
+import akka.testkit.ImplicitSender
+
+import org.junit.runner.RunWith
+import org.scalatest.BeforeAndAfter
+import org.scalatest.Suite
+import org.scalatest.junit.JUnitRunner
+import org.scalatest.matchers.ShouldMatchers
+
+@RunWith(classOf[JUnitRunner])
+class DeviceHandlerTest extends TestKit(ActorSystem("DeviceHandlerTests"))
+        with ImplicitSender with Suite with ShouldMatchers with BeforeAndAfter
+        with DeviceHandler {
+
+    case class HandleMsg(id: UUID)
+
+    val id = UUID.randomUUID()
+
+    def handle(deviceId: UUID) { self ! HandleMsg(deviceId) }
+
+    def testOneShotSubscribe() {
+        val handler = new DeviceHandlersManager[String](this)
+
+        // register self and expect handle msg
+        handler.addSubscriber(id, self, false)
+        expectMsg(HandleMsg(id))
+
+        // notify subscribers and expect one msg
+        handler.notifySubscribers(id, "whatever")
+        expectMsg("whatever")
+
+        // notify subscribers again but don't expect anything
+        handler.notifySubscribers(id, "somethingelse")
+
+        // resubcribe, notify, and expect a msg
+        handler.addSubscriber(id, self, false)
+        handler.notifySubscribers(id, "yetonemsg")
+        expectMsg("yetonemsg")
+    }
+
+    def testSubscribeWithUpdate() {
+        val handler = new DeviceHandlersManager[String](this)
+
+        // register self for updates and expect handle msg
+        handler.addSubscriber(id, self, true)
+        expectMsg(HandleMsg(id))
+
+        // notify subscribers and expect all msg
+        val msgs = List("foo1","foo2","foo3")
+        for (m <- msgs) { handler.notifySubscribers(id, "foo1") }
+        for (m <- msgs) { expectMsg("foo1") }
+    }
+
+    def testUnsubscribe() {
+        val handler = new DeviceHandlersManager[String](this)
+
+        // unregister unregistered actor, nothing goes bad after that
+        handler.removeSubscriber(id, self)
+
+        // register self for updates and expect handle msg
+        handler.addSubscriber(id, self, false)
+        expectMsg(HandleMsg(id))
+
+        // unregister, notify, dont get msg
+        handler.removeSubscriber(id, self)
+        handler.notifySubscribers(id, "wontreceive")
+
+        // reregister with update, next msg should be from next notify
+        handler.addSubscriber(id, self, true)
+        handler.notifySubscribers(id, "willreceive")
+        expectMsg("willreceive")
+
+        // unregister, notify, dont get msg
+        handler.removeSubscriber(id, self)
+        handler.notifySubscribers(id, "wontreceive2")
+
+        // rereregister with update, next msg should be from next notify
+        handler.addSubscriber(id, self, true)
+        handler.notifySubscribers(id, "willreceive2")
+        expectMsg("willreceive2")
+    }
+
+}

