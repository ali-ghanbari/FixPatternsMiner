diff --git a/pom.xml b/pom.xml
index 77b4826..91ed061 100644
--- a/pom.xml
+++ b/pom.xml
@@ -198,0 +199,12 @@
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-docck-plugin</artifactId>
+        <version>1.0</version>
+        <executions>
+          <execution>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
diff --git a/src/main/java/org_scala_tools_maven_cs/ScalaCSInitMojo.java b/src/main/java/org_scala_tools_maven_cs/ScalaCSInitMojo.java
index 42ee385..6fd2c63 100644
--- a/src/main/java/org_scala_tools_maven_cs/ScalaCSInitMojo.java
+++ b/src/main/java/org_scala_tools_maven_cs/ScalaCSInitMojo.java
@@ -15,0 +16,2 @@
+ * Register the current project into running ScalaCS. If there is no running ScalaCS then install (if needed) and start it.
+ *
diff --git a/src/site/site.xml b/src/site/site.xml
index 91bd93b..96914d4 100644
--- a/src/site/site.xml
+++ b/src/site/site.xml
@@ -25,2 +25,3 @@
-      <item name="scala-tools" href="http://scala-tools.org/"/>
-      <item name="scala-blogs" href="http://scala-blogs.org/"/>
+      <item name="Wiki" href="http://wiki.github.com/davidB/maven-scala-plugin/"/>
+      <item name="FAQ" href="http://wiki.github.com/davidB/maven-scala-plugin/frequently-asked-questions"/>
+      <item name="Mailing-list" href="http://groups.google.com/group/maven-and-scala"/>
@@ -35,8 +36,8 @@
-      <item name="Compiling" href="usage_compile.html" />
-      <item name="Continuous Compilation" href="usage_cc.html" />
-      <item name="Scaladoc" href="usage_doc.html" />
-      <item name="Running" href="usage_run.html" />
-      <item name="Scripting" href="usage_script.html" />
-      <item name="Scala Console" href="usage_console.html" />
-      <item name="Mixed Java/Scala Projects" href="usage_java.html" />
-      <item name="Creating Scalac Plugins" href="usage_scalac_plugins.html" />
+      <item name="Compiling" href="example_compile.html" />
+      <item name="Continuous Compilation" href="example_cc.html" />
+      <item name="Scaladoc" href="example_doc.html" />
+      <item name="Running" href="example_run.html" />
+      <item name="Scripting" href="example_script.html" />
+      <item name="Scala Console" href="example_console.html" />
+      <item name="Mixed Java/Scala Projects" href="example_java.html" />
+      <item name="Creating Scalac Plugins" href="example_scalac_plugins.html" />
diff --git a/src/site/xdoc/articles.xml b/src/site/xdoc/articles.xml
index d73d682..ba86603 100644
--- a/src/site/xdoc/articles.xml
+++ b/src/site/xdoc/articles.xml
@@ -11,0 +12 @@
+                <li>[2010-06-05 en] <a href="https://www.assembla.com/wiki/show/scala-ide/Using_Maven_with_the_Scala_IDE_for_Eclipse">Using Maven with the Scala IDE for Eclipse</a></li>
diff --git a/src/site/xdoc/example_cc.xml b/src/site/xdoc/example_cc.xml
new file mode 100644
index 0000000..c72a5bd
--- /dev/null
+++ b/src/site/xdoc/example_cc.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>maven-scala-plugin</title>
+    <authors>
+      <person name="David Bernard" />
+    </authors>
+  </properties>
+  <body>
+    <h1>Continuous Compilation of Scala sources</h1>
+
+    <span>Prerequis : <a href="usage.html">common usages</a></span>
+
+    <section>
+      <p>
+        If you want a continuous compilation of sources under src/main and src/test (compilation when file are saved) :
+        <source>
+          <![CDATA[
+mvn scala:cc
+       ]]>
+        </source>
+      </p>
+      <ul>
+      <li>Compilation run in a infinite loop and compile only modified file (non-stop), so use Ctrl+C to stop it</li>
+      <li>If you want to compile without FSC (with regular scalac like non-continuous compilation) :
+        <source>
+          <![CDATA[
+mvn scala:cc -Dfsc=false
+       ]]>
+        </source>
+      </li>
+      <li>If you want to display command used to run scala :
+        <source>
+          <![CDATA[
+mvn scala:cc -DdisplayCmd=true
+       ]]>
+        </source>
+      </li>
+      <li style="color:red">WARNING : continius compilation is an infinite loop so, avoid call the goal "cc" in pom.xml or to connect it to a lifecycle's phase.</li>
+      </ul>
+    </section>
+  </body>
+</document>
diff --git a/src/site/xdoc/example_compile.xml b/src/site/xdoc/example_compile.xml
new file mode 100644
index 0000000..2bcd599
--- /dev/null
+++ b/src/site/xdoc/example_compile.xml
@@ -0,0 +1,127 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>maven-scala-plugin</title>
+    <authors>
+      <person name="David Bernard" />
+    </authors>
+  </properties>
+  <body>
+    <h1>Compiling Scala sources</h1>
+
+    <span>Prerequis : <a href="usage.html">common usages</a></span>
+
+    <section name="Compiling">
+      <p>
+        Place scala sources files in :
+        <source>src/main/scala</source>
+      </p>
+      <p>
+        Place scala test sources files in :
+        <source>src/test/scala</source>
+      </p>
+      <p>
+        Then use the standard maven phases :
+        <source>
+          <![CDATA[
+# compile only
+mvn compile
+# or compile and test
+mvn test
+# or compile, test and package
+mvn package
+       ]]>
+        </source>
+      </p>
+      <p>
+        Or the plugin specifics goal :
+        <source>
+          <![CDATA[
+# compile source
+mvn scala:compile
+# compile test
+mvn scala:testCompile
+       ]]>
+        </source>
+      </p>
+      <p>
+        Or if you want to compile only source (from main and test) without calling previous phases like check resources, generate-sources,... :
+        <source>
+          <![CDATA[
+# compile source and test with fsc
+mvn scala:cc -Donce=true
+# compile source and test with scalac
+mvn scala:cc -Donce=true -Dfsc=false
+       ]]>
+        </source>
+        WARNING:
+        <ul>
+        <li>This feature is provide for integration with editor.</li>
+        <li>using once and fsc => reuse server if previously started else start a new one but never stop it (except if you call scala:cc without -Donce=true, or if you kill the process yourself)</li>
+        </ul>
+      </p>
+    </section>
+    <section name="Increasing memory">
+      <source>
+        <![CDATA[
+<project>
+  ...
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>compile</goal>
+              <goal>testCompile</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <jvmArgs>
+            <jvmArg>-Xms64m</jvmArg>
+            <jvmArg>-Xmx1024m</jvmArg>
+          </jvmArgs>
+        </configuration>
+      </plugin>
+  ...
+</project>
+            ]]>
+      </source>
+    </section>
+    <section name="Emacs user">
+      <p>If you are an emacs user, you could try the to run the compilation with "-DemacsMode=true" then compilation error will be displayed without [WARNING] at the begin of the line like :
+      <source><![CDATA[
+[INFO] Compiling 1 source files to /home/dwayne/work/oss/scala-tools/vscaladoc/target/classes
+[WARNING] Compilation failure
+
+/project/src/main/scala/org/example/Main.scala:12: error: expected class or object definition
+foo()
+^
+one error found
+       ]]></source>
+       </p>
+	</section>
+
+    <section name="Compiler Arguments">
+        <p>It is common to wish to send arguments to the scalac compiler during compilation of your project.  To do so, make use of the args configuration parameter like so:</p>
+        <source><![CDATA[
+<project>
+  ...
+  <plugin>
+    <groupId>org.scala-tools</groupId>
+    <artifactId>maven-scala-plugin</artifactId>
+      <configuration>
+        <args>
+          <arg>-unchecked</arg>
+          <arg>-deprecation</arg>
+          <arg>-explaintypes</arg>
+        </args>
+    </configuration>
+  </plugin>
+  ...
+</project>
+                ]]></source>
+    </section>
+  </body>
+</document>
diff --git a/src/site/xdoc/example_console.xml b/src/site/xdoc/example_console.xml
new file mode 100644
index 0000000..d1ba106
--- /dev/null
+++ b/src/site/xdoc/example_console.xml
@@ -0,0 +1,118 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>Example</title>
+    <authors>
+      <person name="David Bernard"/>
+    </authors>
+  </properties>
+  <body>
+    <h1>Running a scala console</h1>
+
+    <section name="Running">
+      <p>
+        You can start a console with a classpath set with the project dependencies (compile, test, runtime) and compiler classes (main and test):
+        <ol>
+        <li>compile your code (running the console doesn't force to compile:
+          <source>mvn test-compile #or mvn test</source>
+        </li>
+        <li>run the console :    
+          <source>mvn scala:console</source>
+        </li>
+        <li>when the scala prompt is shown, play :
+      <source><![CDATA[
+...
+[INFO] [scala:console]
+Welcome to Scala version 2.6.0-final.
+Type in expressions to have them evaluated.
+Type :help for more information.
+
+scala> print("hello")
+hello
+scala> new bootstrap.liftweb.Boot().boot
+...
+      ]]></source>
+        </li>
+        </ol>
+      </p>
+    </section>
+
+    <section name="pre/post action">
+    <p>If you want to always run some code before use the console or after use it, and don't want to type it at every startup. Then you could wrap the console into a scala main().</p>
+    <p>I'll show an example with the LiftConsole. A good pratice is to put this class in the test directory (it's not part of the main code ;) )</p>
+    <ol>
+    <li>add into the pom.xml the jar with the scala 's console
+    <source><![CDATA[
+      <dependency>
+        <groupId>org.scala-lang</groupId>
+        <artifactId>scala-compiler</artifactId>
+        <version>${scala.version}</version>
+        <scope>test</scope>
+      </dependency>
+      ]]></source>
+     </li>
+    <li>create the scala file src/test/scala/LiftConsole.scala (based on liftrepl)
+    <source><![CDATA[
+import bootstrap.liftweb.Boot
+import scala.tools.nsc.MainGenericRunner
+ 
+object LiftConsole {
+   def main(args : Array[String]) {
+     // Instantiate your project's Boot file
+     val b = new Boot();
+     // Boot your project
+     b.boot;
+     // Now run the MainGenericRunner to get your repl
+     MainGenericRunner.main(args)
+     // After the repl exits, then exit the scala script
+     exit(0)
+   }
+}
+      ]]></source>
+     </li>
+     <li>compile: <source><![CDATA[mvn test]]></source></li>
+     <li>run : <source><![CDATA[mvn scala:console -DmainConsole=LiftConsole]]></source></li>
+     <li>if you don't want to always need to set "-DmainConsole=LiftConsole",
+      then edit your pom.xml and add to the configuration of the plugin :
+    <source><![CDATA[
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+        ...
+        <configuration>
+          <mainConsole>LiftConsole</mainConsole>
+        </configuration>
+      </plugin>
+      ]]></source>
+      </li>
+  </ol>    
+    
+    </section>
+    
+    <section name="running with JavaRebel">
+    <p>If you want to run the console with <a href="">JavaRebel</a>, you need :
+     <ol>
+     <li>install javarebel somewhere on your disk, javarebel is available on a public maven repository (commercial tool)</li>
+     <li>call the console with the option define where is the javarebel.jar:
+       <source>mvn scala:console -Djavarebel.jar.path=[path_of_javarebel.jar]</source>
+       or through the pom.xml
+    <source><![CDATA[
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+        ...
+        <configuration>
+          <javaRebelPath>${user.home}/lib/java/javarebel/javarebel.jar</javaRebelPath>
+        </configuration>
+      </plugin>
+      ]]></source>
+    </li>
+    <li><b>NOTE</b> - Forking is currently disabled in the plugin due to cross-platform issues with jline and process indirection.
+        If you wish to use JRebel with the console, please set your maven opts in your environment:
+        <source>MAVEN_OPTS="$MAVEN_OPTS -noverify -javaagent:/...path/to/jrebel.jar" mvn scala:console</source>
+    </li>
+    </ol>       
+    </p>
+    </section>
+  </body>
+</document>
diff --git a/src/site/xdoc/example_doc.xml b/src/site/xdoc/example_doc.xml
new file mode 100644
index 0000000..c256275
--- /dev/null
+++ b/src/site/xdoc/example_doc.xml
@@ -0,0 +1,109 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>Generating API with ScalaDoc</title>
+    <authors>
+      <person name="David Bernard" />
+    </authors>
+  </properties>
+  <body>
+    <h1>Generating API with ScalaDoc</h1>
+
+    <span>Prerequis : <a href="usage.html">common usages</a></span>
+
+    <section name="Configuration">
+      <p>to generate apidocs / scaladoc for your scala sources, add this to your pom.xml</p>
+      <source><![CDATA[
+<project>
+  ...
+  <reporting>
+    <plugins>
+      ...
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+      </plugin>
+      ...
+    </plugins>
+  </reporting>
+  ...
+</project>]]></source>
+    </section>
+    <section name="To generate api">
+      <p>
+        Place scala sources files in :
+        <source>src/main/scala</source>
+      </p>
+      <p>
+        Then use the standard maven phases :
+        <source>
+          <![CDATA[
+# generate a site
+mvn site
+       ]]>
+        </source>
+      </p>
+      <p>
+        Or the plugin specifics goal :
+        <source>
+          <![CDATA[
+# generate only the doc
+mvn scala:doc
+        ]]>
+        </source>
+      </p>
+      <p>See the result under target/site/scaladocs/</p>
+    </section>
+    <section name="To use a custom api generator">
+      <p>
+        You need to declare the main class to call (with the same parameter as scaladoc). And you need to list the additional artifact(jar) to use :
+        <source><![CDATA[
+<configuration>
+  <scaladocClassName>org.scala_tools.vscaladoc.Main</scaladocClassName>
+  <scalaJars>
+    <scalaJar>
+      <groupId>org.scala-tools</groupId>
+      <artifactId>vscaladoc</artifactId>
+      <version>1.0</version>
+    </scalaJar>
+  </scalaJars>
+</configuration>
+        ]]></source>
+      </p>
+      <p>
+        Then use the standard maven phases :
+        <source>
+          <![CDATA[
+# generate a site
+mvn site
+# or generate only the doc
+mvn scala:doc
+       ]]>
+        </source>
+      </p>
+      <p>See the result under target/site/scaladocs/</p>
+    </section>
+    <section name="To use vscaladoc">
+      <p>
+        vscaladoc have a shortcut way to use it (instead of using the custom way describe above) :        
+        <source><![CDATA[
+<configuration>
+  <vscalaVersion>1.0</vscalaVersion>
+</configuration>
+        ]]></source>
+      </p>
+      <p>
+        Then use the standard maven phases :
+        <source>
+          <![CDATA[
+# generate a site
+mvn site
+# or generate only the doc
+mvn scala:doc
+       ]]>
+        </source>
+      </p>
+      <p>See the result under target/site/scaladocs/</p>
+    </section>
+  </body>
+</document>
diff --git a/src/site/xdoc/example_java.xml b/src/site/xdoc/example_java.xml
new file mode 100644
index 0000000..4dce02c
--- /dev/null
+++ b/src/site/xdoc/example_java.xml
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>maven-scala-plugin</title>
+    <authors>
+      <person name="Josh Suereth" />
+    </authors>
+  </properties>
+  <body>
+    <h1>Mixed Java/Scala Projects</h1>
+
+    <span>Prerequisites : <a href="usage.html">common usages</a></span>
+
+    <section name="setup">
+      <p>
+        Place java sources files in :
+        <source>src/main/java</source>
+      </p>
+      <p>
+        Place java test sources files in :
+        <source>src/test/java</source>
+      </p>    
+      <p>
+        Place scala sources files in :
+        <source>src/main/scala</source>
+      </p>
+      <p>
+        Place scala test sources files in :
+        <source>src/test/scala</source>
+      </p>
+      <p>Make your pom file look similar to the following (this is what we use for integration testing):
+       <source>
+          <![CDATA[
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+
+	<groupId>org.scala-tools.maven-scala-plugin</groupId>
+	<artifactId>testJavaAndScala</artifactId>
+	<version>1.0-SNAPSHOT</version>
+	<name>Test for Java + Scala compilation</name>
+	<description>Test for Java + Scala compilation</description>
+
+	<dependencies>
+		<dependency>
+			<groupId>org.scala-lang</groupId>
+			<artifactId>scala-library</artifactId>
+			<version>2.7.2</version>
+		</dependency>
+	</dependencies>
+	<repositories>
+		<repository>
+			<id>scala-tools.org</id>
+			<name>Scala-tools Maven2 Repository</name>
+			<url>http://scala-tools.org/repo-releases</url>
+		</repository>
+	</repositories>
+	<pluginRepositories>
+		<pluginRepository>
+			<id>scala-tools.org</id>
+			<name>Scala-tools Maven2 Repository</name>
+			<url>http://scala-tools.org/repo-releases</url>
+		</pluginRepository>
+	</pluginRepositories>
+
+	<build>
+		<pluginManagement>
+			<plugins>
+				<plugin>
+					<groupId>org.scala-tools</groupId>
+					<artifactId>maven-scala-plugin</artifactId>
+					<version>2.9.1</version>
+				</plugin>
+				<plugin>
+					<groupId>org.apache.maven.plugins</groupId>
+					<artifactId>maven-compiler-plugin</artifactId>
+					<version>2.0.2</version>
+				</plugin>
+			</plugins>
+		</pluginManagement>
+		<plugins>
+			<plugin>
+				<groupId>org.scala-tools</groupId>
+				<artifactId>maven-scala-plugin</artifactId>
+				<executions>
+					<execution>
+						<id>scala-compile-first</id>
+						<phase>process-resources</phase>
+						<goals>
+						    <goal>add-source</goal>
+							<goal>compile</goal>
+						</goals>
+					</execution>									
+					<execution>
+						<id>scala-test-compile</id>
+						<phase>process-test-resources</phase>
+						<goals>
+							<goal>testCompile</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<executions>
+					<execution>
+						<phase>compile</phase>
+						<goals>
+							<goal>compile</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+	</build>
+
+</project>
+
+          ]]>
+       </source>
+      </p>
+      <p>
+        Then use the standard maven phases :
+        <source>
+          <![CDATA[
+# compile only
+mvn compile
+# or compile and test
+mvn test
+# or compile, test and package
+mvn package
+       ]]>
+        </source>
+      </p>      
+      
+    </section>    
+
+  </body>
+</document>
diff --git a/src/site/xdoc/example_run.xml b/src/site/xdoc/example_run.xml
new file mode 100644
index 0000000..3281f67
--- /dev/null
+++ b/src/site/xdoc/example_run.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>Example</title>
+    <authors>
+      <person name="Brice Lambi"/>
+    </authors>
+  </properties>
+  <body>
+    <h1>Running a "main(args: Array[String])"</h1>
+
+    <div class="warning">
+      You must have a well define project, and it must compile your code successfully before (see
+      <a href="usage_compile.html">Compiling</a>
+      ).
+    </div>
+    <section name="Running">
+      <p>
+        So you can now run your scala app by defining the "mainClass" property :
+        <source>mvn scala:run -DmainClass=org.example.MyClass</source>
+      </p>
+    </section>
+    <section name="Using Launcher">
+      <p>You need to use launchers if you :
+        <ul>
+        <li>need to specify args and/or jvmArgs that are different from the main configuration</li>
+        <li>run and run again the same "configuration"/command line</li>
+        <li>want to store, some configuration for later user, or for sharing with other</li>
+        </ul>
+        </p>
+      <source><![CDATA[
+  <plugin>
+    <groupId>maven</groupId>
+    <artifactId>maven-scala-plugin</artifactId>
+    <configuration>
+      <launchers>
+        <launcher>
+          <id>foo</id>
+          <mainClass>org.example.MyClass</mainClass>
+          <!-- args are optional -->
+          <args>
+            <arg>arg1</arg>
+          </args>
+          <!-- jvmArgs are optional -->
+          <jvmArgs>
+            <jvmArg>-Xmx128m</jvmArg>
+            <jvmArg>-Djava.library.path=...</jvmArg>
+          </jvmArgs>
+        </launcher>
+        <!-- you could define other launcher -->
+      </launchers>
+    </configuration>
+  </plugin>]]>
+      </source>
+      <p>Now you can run the following command to run your launcher (the classpath used is the test classpath).</p>
+      <source>mvn scala:run -Dlauncher=foo</source>
+      <p>If you don't specify launcher or mainClass then the first launcher is used, in your case, the example below is equivalent to the example above.</p>
+    <source>mvn scala:run</source>
+      <p>If you need/which to specify some additional arguments at call time use "-DaddArgs=arg1|arg2|arg3" ('|' is used as separator)</p>
+      <p>Set the property 'displayCmd' to true, to display the command line used</p>
+
+    </section>
+  </body>
+</document>
diff --git a/src/site/xdoc/example_scalac_plugins.xml b/src/site/xdoc/example_scalac_plugins.xml
new file mode 100644
index 0000000..3694b37
--- /dev/null
+++ b/src/site/xdoc/example_scalac_plugins.xml
@@ -0,0 +1,108 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>Example Scalac plugin project</title>
+    <authors>
+      <person name="Josh Suereth"/>
+    </authors>
+  </properties>
+  <body>
+    <h1>Creating/Using a Scalac plugin</h1>
+    <section name="Project Setup">
+       <p>A scalac maven-based project has the following structure</p>
+       <source>
+project-root/
+  pom.xml
+  src/
+    main/
+      scala/
+        -Your plugin Source Here
+      resources/
+          scalac-plugin.xml
+       </source>
+       <p>Please follow the <a href="http://www.scala-lang.org/node/140">Writing Scala Compiler Plugins</a> tutorial for the content of the project.</p>
+      <p>A scalac plugin should *only* have dependencies on the scala-compiler artifact, and
+        these dependencies should be of type "provided". Here is an example pom for a plugin project:
+        </p>
+      <source><![CDATA[
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>org.scala-lang</groupId>
+  <artifactId>my-test-plugin</artifactId>
+  <packaging>jar</packaging>
+  <version>1.0-SNAPSHOT</version>
+  <name>Dependency Resolution extensions for the scala compiler</name>
+  <repositories>
+    <repository>
+      <id>scala-tools.org</id>
+      <name>Scala-tools Maven2 Repository</name>
+      <url>http://scala-tools.org/repo-releases</url>
+    </repository>
+  </repositories>
+  <pluginRepositories>
+    <pluginRepository>
+      <id>scala-tools.org</id>
+      <name>Scala-tools Maven2 Repository</name>
+      <url>http://scala-tools.org/repo-releases</url>
+    </pluginRepository>
+  </pluginRepositories>
+  <dependencies>
+    <dependency>
+      <groupId>org.scala-lang</groupId>
+      <artifactId>scala-compiler</artifactId>
+      <version>2.7.2</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>compile</goal>
+              <goal>testCompile</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <sourceDir>src/main/scala</sourceDir>
+          <jvmArgs>
+            <jvmArg>-Xms64m</jvmArg>
+            <jvmArg>-Xmx1024m</jvmArg>
+          </jvmArgs>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>]]>
+      </source>
+      <p>Now you need to make sure you install the plugin project into the local repository.</p>
+      <source>mvn install</source>
+    </section>
+    <section name="Using a scalac plugin">
+      <p>To make use of one or more scalac plugins, you need to declare them inside your pom using the "compilerPlugins" configuration item.</p>
+      <source><![CDATA[
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+        ...
+        <configuration>
+          ...
+          <compilerPlugins>
+            <compilerPlugin>
+              <groupId>org.scala-lang</groupId>
+              <artifactId>my-scalac-plugin</artifactId>
+              <version>1.0-SNAPSHOT</version>
+            </compilerPlugin>
+          </compilerPlugins>
+        </configuration>
+      </plugin>]]>
+      </source>
+      <p>If you need to send arguments to the plugin, this can be done with the "args" confguration tag.</p>
+    </section>
+  </body>
+</document>
\ No newline at end of file
diff --git a/src/site/xdoc/example_script.xml b/src/site/xdoc/example_script.xml
new file mode 100644
index 0000000..6ad1012
--- /dev/null
+++ b/src/site/xdoc/example_script.xml
@@ -0,0 +1,170 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>Execute Script</title>
+    <authors>
+      <person name="Jesse Eichar" />
+    </authors>
+  </properties>
+  <body>
+    <h1>Running a scala script</h1>
+    <section name="Running a Script Inlined in the pom">
+      <p>
+      This goal allows you to execute a scala script defined in the pom.
+      </p>
+      <source><![CDATA[
+  <plugin>
+    <groupId>org.scala-tools</groupId>
+    <artifactId>maven-scala-plugin</artifactId>
+    <executions>
+      <execution>
+        <phase>package</phase>
+        <goals>
+          <goal>script</goal>
+        </goals>
+      </execution>
+    </executions>
+    <configuration>
+      <script>
+        println ("Hello from pom script :-)")
+     </script>
+    </configuration>
+  </plugin>]]></source>
+      </section>
+    <section name="Running from a Script File">
+      <p>
+        This goal allows you to run a scala script by defining the "script"
+        property:
+        <source>mvn scala:script -DscriptFile=scripts/PrintHello.scala</source>
+      </p>
+    </section>
+    <section name="Running a script as part of a build">
+      <p>Executing a script as part of the build process.</p>
+      <source><![CDATA[
+  <plugin>
+    <groupId>org.scala-tools</groupId>
+    <artifactId>maven-scala-plugin</artifactId>
+    <executions>
+      <execution>
+        <phase>package</phase>
+        <goals>
+          <goal>script</goal>
+        </goals>
+      </execution>
+    </executions>
+    <configuration>
+      <scriptFile>package.scala</scriptFile>
+    </configuration>
+  </plugin>]]></source>
+    </section>
+    <section name="Predefining a script file">
+      <p>Adding the script configuration to your plugin
+        definition.</p>
+      <source><![CDATA[
+  <plugin>
+    <groupId>maven</groupId>
+    <artifactId>maven-scala-plugin</artifactId>
+    <configuration>
+      <scriptFile>pathToScript/MyScript</scriptFile>
+    </configuration>
+  </plugin>]]></source>
+      <p>Now you can run the following command to run your scala app.
+      </p>
+      <source>mvn scala:script</source>
+    </section>
+    <section name="Classpath for running and compiling script">
+    The classpath is define by configuration 'includeScopes', 'excludeScopes', 'addToClasspath'.
+    The possible scopes are : test, compile, system, runtime, plugin. The default rules (since 2.14) is :
+    <ul>
+      <li>embedded script into pom.xml run with 'plugin' scope</li>
+      <li>script read from scriptFile run with 'compile, test, runtime'</li>
+    </ul>
+    </section>
+    <section name="Using the Maven Project from within a script">
+              <p>If the script run within the 'PLUGIN' scope then a scala.maven.model.MavenProjectAdapter object
+                and a org.apache.maven.plugin.logging.Log object will be passed
+                to the script.  The Log will have the name "log" and the
+                MavenProjectAdapter will have the name "project"
+              </p><p>
+                The class MavenProjectAdapter is a decorator for the MavenProject class
+                that adds typing to the java.util.Collection and adds
+                apply and update methods for accessing the properties of the project.
+              </p><p>
+                  Note: In this scenario the scala.collection.jcl.Conversions._ is imported so
+                  that the java.util collections can be treated as Scala collections.
+                </p>
+              <p>Here is an example script using the project</p>
+              <source><![CDATA[
+        <executions>
+          <execution>
+            <id>generate-hello</id>
+            <phase>generate-sources</phase>
+            <goals>
+              <goal>script</goal>
+            </goals>
+            <configuration>
+              <scalaVersion>2.7.7</scalaVersion>
+              <keepGeneratedScript>true</keepGeneratedScript>
+              <script>
+              &lt;![CDATA[
+                println("hello from scala script constructor")
+
+                def run() {
+                  import java.io.PrintWriter
+                  import scala.collection.jcl.Conversions._
+
+                  println("hello from scala script run method")
+                  log.info( project("scala.version") )
+                  val fo = new PrintWriter("target/hello.txt")
+                  try {
+                    fo.println(project.getArtifactId())
+                    for( d <- project.getDependencies() ) {
+                      fo.println (d.getArtifactId)
+                    }
+                  } finally {
+                    fo.close()
+                  }
+                }
+              ]]&gt;
+              </script>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>]]></source>
+    </section>
+    <section name="Technical details">
+        <p>
+                This mojo operates by adding a class definition to the start of the script.
+                As a result the script is essentially the initialization of the class.
+            </p>
+            <p>
+                The reason for this is that it allows one to define classes and functions in any
+                order and not worry about '<em>forward reference extends over definition of
+                value _</em>' compile errors.
+            </p>
+            <p>
+                However there is a danger in putting complex code in the constructor of a class and
+                that has to do poor performance because of certain precautions the JVM takes when
+                 constructing a class.  In order to offer a solution to this this Mojo will look for
+                 a run() method after the '<em>virtual</em>' class has been constructed and invokes
+                  that method.
+            </p>
+            <p>
+                If this mojo detects that the MavenProjectAdapter class is on the classpath
+                (in otherwords this plugin is a dependency in the scope that the script runs) then
+                the MavenProjectAdapter that decorates the current MavenProject will be passed to
+                the script's construct.  The variable name is '<em>project</em>'.  The project
+                variable can be used to inspect parameters of the maven project like the properties and
+                dependencies of the project.
+            </p>
+        <p>Here is an example using the run method with the MavenProjectAdapter</p>
+        <source><![CDATA[<script>
+  println ("Hi I shouldn't do any heavy work here...")
+  def run(){
+    println(project.getName+" is the current project")
+    println("Now lets do some serious work!  Even multi-threaded programming is allowed.")
+  }
+</script>]]></source>
+        </section>
+  </body>
+</document>
\ No newline at end of file
diff --git a/src/site/xdoc/usage_cc.xml b/src/site/xdoc/usage_cc.xml
deleted file mode 100644
index c72a5bd..0000000
--- a/src/site/xdoc/usage_cc.xml
+++ /dev/null
@@ -1,43 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>maven-scala-plugin</title>
-    <authors>
-      <person name="David Bernard" />
-    </authors>
-  </properties>
-  <body>
-    <h1>Continuous Compilation of Scala sources</h1>
-
-    <span>Prerequis : <a href="usage.html">common usages</a></span>
-
-    <section>
-      <p>
-        If you want a continuous compilation of sources under src/main and src/test (compilation when file are saved) :
-        <source>
-          <![CDATA[
-mvn scala:cc
-       ]]>
-        </source>
-      </p>
-      <ul>
-      <li>Compilation run in a infinite loop and compile only modified file (non-stop), so use Ctrl+C to stop it</li>
-      <li>If you want to compile without FSC (with regular scalac like non-continuous compilation) :
-        <source>
-          <![CDATA[
-mvn scala:cc -Dfsc=false
-       ]]>
-        </source>
-      </li>
-      <li>If you want to display command used to run scala :
-        <source>
-          <![CDATA[
-mvn scala:cc -DdisplayCmd=true
-       ]]>
-        </source>
-      </li>
-      <li style="color:red">WARNING : continius compilation is an infinite loop so, avoid call the goal "cc" in pom.xml or to connect it to a lifecycle's phase.</li>
-      </ul>
-    </section>
-  </body>
-</document>
diff --git a/src/site/xdoc/usage_compile.xml b/src/site/xdoc/usage_compile.xml
deleted file mode 100644
index 2bcd599..0000000
--- a/src/site/xdoc/usage_compile.xml
+++ /dev/null
@@ -1,127 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>maven-scala-plugin</title>
-    <authors>
-      <person name="David Bernard" />
-    </authors>
-  </properties>
-  <body>
-    <h1>Compiling Scala sources</h1>
-
-    <span>Prerequis : <a href="usage.html">common usages</a></span>
-
-    <section name="Compiling">
-      <p>
-        Place scala sources files in :
-        <source>src/main/scala</source>
-      </p>
-      <p>
-        Place scala test sources files in :
-        <source>src/test/scala</source>
-      </p>
-      <p>
-        Then use the standard maven phases :
-        <source>
-          <![CDATA[
-# compile only
-mvn compile
-# or compile and test
-mvn test
-# or compile, test and package
-mvn package
-       ]]>
-        </source>
-      </p>
-      <p>
-        Or the plugin specifics goal :
-        <source>
-          <![CDATA[
-# compile source
-mvn scala:compile
-# compile test
-mvn scala:testCompile
-       ]]>
-        </source>
-      </p>
-      <p>
-        Or if you want to compile only source (from main and test) without calling previous phases like check resources, generate-sources,... :
-        <source>
-          <![CDATA[
-# compile source and test with fsc
-mvn scala:cc -Donce=true
-# compile source and test with scalac
-mvn scala:cc -Donce=true -Dfsc=false
-       ]]>
-        </source>
-        WARNING:
-        <ul>
-        <li>This feature is provide for integration with editor.</li>
-        <li>using once and fsc => reuse server if previously started else start a new one but never stop it (except if you call scala:cc without -Donce=true, or if you kill the process yourself)</li>
-        </ul>
-      </p>
-    </section>
-    <section name="Increasing memory">
-      <source>
-        <![CDATA[
-<project>
-  ...
-      <plugin>
-        <groupId>org.scala-tools</groupId>
-        <artifactId>maven-scala-plugin</artifactId>
-        <executions>
-          <execution>
-            <goals>
-              <goal>compile</goal>
-              <goal>testCompile</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <jvmArgs>
-            <jvmArg>-Xms64m</jvmArg>
-            <jvmArg>-Xmx1024m</jvmArg>
-          </jvmArgs>
-        </configuration>
-      </plugin>
-  ...
-</project>
-            ]]>
-      </source>
-    </section>
-    <section name="Emacs user">
-      <p>If you are an emacs user, you could try the to run the compilation with "-DemacsMode=true" then compilation error will be displayed without [WARNING] at the begin of the line like :
-      <source><![CDATA[
-[INFO] Compiling 1 source files to /home/dwayne/work/oss/scala-tools/vscaladoc/target/classes
-[WARNING] Compilation failure
-
-/project/src/main/scala/org/example/Main.scala:12: error: expected class or object definition
-foo()
-^
-one error found
-       ]]></source>
-       </p>
-	</section>
-
-    <section name="Compiler Arguments">
-        <p>It is common to wish to send arguments to the scalac compiler during compilation of your project.  To do so, make use of the args configuration parameter like so:</p>
-        <source><![CDATA[
-<project>
-  ...
-  <plugin>
-    <groupId>org.scala-tools</groupId>
-    <artifactId>maven-scala-plugin</artifactId>
-      <configuration>
-        <args>
-          <arg>-unchecked</arg>
-          <arg>-deprecation</arg>
-          <arg>-explaintypes</arg>
-        </args>
-    </configuration>
-  </plugin>
-  ...
-</project>
-                ]]></source>
-    </section>
-  </body>
-</document>
diff --git a/src/site/xdoc/usage_console.xml b/src/site/xdoc/usage_console.xml
deleted file mode 100644
index d1ba106..0000000
--- a/src/site/xdoc/usage_console.xml
+++ /dev/null
@@ -1,118 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>Example</title>
-    <authors>
-      <person name="David Bernard"/>
-    </authors>
-  </properties>
-  <body>
-    <h1>Running a scala console</h1>
-
-    <section name="Running">
-      <p>
-        You can start a console with a classpath set with the project dependencies (compile, test, runtime) and compiler classes (main and test):
-        <ol>
-        <li>compile your code (running the console doesn't force to compile:
-          <source>mvn test-compile #or mvn test</source>
-        </li>
-        <li>run the console :    
-          <source>mvn scala:console</source>
-        </li>
-        <li>when the scala prompt is shown, play :
-      <source><![CDATA[
-...
-[INFO] [scala:console]
-Welcome to Scala version 2.6.0-final.
-Type in expressions to have them evaluated.
-Type :help for more information.
-
-scala> print("hello")
-hello
-scala> new bootstrap.liftweb.Boot().boot
-...
-      ]]></source>
-        </li>
-        </ol>
-      </p>
-    </section>
-
-    <section name="pre/post action">
-    <p>If you want to always run some code before use the console or after use it, and don't want to type it at every startup. Then you could wrap the console into a scala main().</p>
-    <p>I'll show an example with the LiftConsole. A good pratice is to put this class in the test directory (it's not part of the main code ;) )</p>
-    <ol>
-    <li>add into the pom.xml the jar with the scala 's console
-    <source><![CDATA[
-      <dependency>
-        <groupId>org.scala-lang</groupId>
-        <artifactId>scala-compiler</artifactId>
-        <version>${scala.version}</version>
-        <scope>test</scope>
-      </dependency>
-      ]]></source>
-     </li>
-    <li>create the scala file src/test/scala/LiftConsole.scala (based on liftrepl)
-    <source><![CDATA[
-import bootstrap.liftweb.Boot
-import scala.tools.nsc.MainGenericRunner
- 
-object LiftConsole {
-   def main(args : Array[String]) {
-     // Instantiate your project's Boot file
-     val b = new Boot();
-     // Boot your project
-     b.boot;
-     // Now run the MainGenericRunner to get your repl
-     MainGenericRunner.main(args)
-     // After the repl exits, then exit the scala script
-     exit(0)
-   }
-}
-      ]]></source>
-     </li>
-     <li>compile: <source><![CDATA[mvn test]]></source></li>
-     <li>run : <source><![CDATA[mvn scala:console -DmainConsole=LiftConsole]]></source></li>
-     <li>if you don't want to always need to set "-DmainConsole=LiftConsole",
-      then edit your pom.xml and add to the configuration of the plugin :
-    <source><![CDATA[
-      <plugin>
-        <groupId>org.scala-tools</groupId>
-        <artifactId>maven-scala-plugin</artifactId>
-        ...
-        <configuration>
-          <mainConsole>LiftConsole</mainConsole>
-        </configuration>
-      </plugin>
-      ]]></source>
-      </li>
-  </ol>    
-    
-    </section>
-    
-    <section name="running with JavaRebel">
-    <p>If you want to run the console with <a href="">JavaRebel</a>, you need :
-     <ol>
-     <li>install javarebel somewhere on your disk, javarebel is available on a public maven repository (commercial tool)</li>
-     <li>call the console with the option define where is the javarebel.jar:
-       <source>mvn scala:console -Djavarebel.jar.path=[path_of_javarebel.jar]</source>
-       or through the pom.xml
-    <source><![CDATA[
-      <plugin>
-        <groupId>org.scala-tools</groupId>
-        <artifactId>maven-scala-plugin</artifactId>
-        ...
-        <configuration>
-          <javaRebelPath>${user.home}/lib/java/javarebel/javarebel.jar</javaRebelPath>
-        </configuration>
-      </plugin>
-      ]]></source>
-    </li>
-    <li><b>NOTE</b> - Forking is currently disabled in the plugin due to cross-platform issues with jline and process indirection.
-        If you wish to use JRebel with the console, please set your maven opts in your environment:
-        <source>MAVEN_OPTS="$MAVEN_OPTS -noverify -javaagent:/...path/to/jrebel.jar" mvn scala:console</source>
-    </li>
-    </ol>       
-    </p>
-    </section>
-  </body>
-</document>
diff --git a/src/site/xdoc/usage_doc.xml b/src/site/xdoc/usage_doc.xml
deleted file mode 100644
index c256275..0000000
--- a/src/site/xdoc/usage_doc.xml
+++ /dev/null
@@ -1,109 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>Generating API with ScalaDoc</title>
-    <authors>
-      <person name="David Bernard" />
-    </authors>
-  </properties>
-  <body>
-    <h1>Generating API with ScalaDoc</h1>
-
-    <span>Prerequis : <a href="usage.html">common usages</a></span>
-
-    <section name="Configuration">
-      <p>to generate apidocs / scaladoc for your scala sources, add this to your pom.xml</p>
-      <source><![CDATA[
-<project>
-  ...
-  <reporting>
-    <plugins>
-      ...
-      <plugin>
-        <groupId>org.scala-tools</groupId>
-        <artifactId>maven-scala-plugin</artifactId>
-      </plugin>
-      ...
-    </plugins>
-  </reporting>
-  ...
-</project>]]></source>
-    </section>
-    <section name="To generate api">
-      <p>
-        Place scala sources files in :
-        <source>src/main/scala</source>
-      </p>
-      <p>
-        Then use the standard maven phases :
-        <source>
-          <![CDATA[
-# generate a site
-mvn site
-       ]]>
-        </source>
-      </p>
-      <p>
-        Or the plugin specifics goal :
-        <source>
-          <![CDATA[
-# generate only the doc
-mvn scala:doc
-        ]]>
-        </source>
-      </p>
-      <p>See the result under target/site/scaladocs/</p>
-    </section>
-    <section name="To use a custom api generator">
-      <p>
-        You need to declare the main class to call (with the same parameter as scaladoc). And you need to list the additional artifact(jar) to use :
-        <source><![CDATA[
-<configuration>
-  <scaladocClassName>org.scala_tools.vscaladoc.Main</scaladocClassName>
-  <scalaJars>
-    <scalaJar>
-      <groupId>org.scala-tools</groupId>
-      <artifactId>vscaladoc</artifactId>
-      <version>1.0</version>
-    </scalaJar>
-  </scalaJars>
-</configuration>
-        ]]></source>
-      </p>
-      <p>
-        Then use the standard maven phases :
-        <source>
-          <![CDATA[
-# generate a site
-mvn site
-# or generate only the doc
-mvn scala:doc
-       ]]>
-        </source>
-      </p>
-      <p>See the result under target/site/scaladocs/</p>
-    </section>
-    <section name="To use vscaladoc">
-      <p>
-        vscaladoc have a shortcut way to use it (instead of using the custom way describe above) :        
-        <source><![CDATA[
-<configuration>
-  <vscalaVersion>1.0</vscalaVersion>
-</configuration>
-        ]]></source>
-      </p>
-      <p>
-        Then use the standard maven phases :
-        <source>
-          <![CDATA[
-# generate a site
-mvn site
-# or generate only the doc
-mvn scala:doc
-       ]]>
-        </source>
-      </p>
-      <p>See the result under target/site/scaladocs/</p>
-    </section>
-  </body>
-</document>
diff --git a/src/site/xdoc/usage_java.xml b/src/site/xdoc/usage_java.xml
deleted file mode 100644
index 4dce02c..0000000
--- a/src/site/xdoc/usage_java.xml
+++ /dev/null
@@ -1,142 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>maven-scala-plugin</title>
-    <authors>
-      <person name="Josh Suereth" />
-    </authors>
-  </properties>
-  <body>
-    <h1>Mixed Java/Scala Projects</h1>
-
-    <span>Prerequisites : <a href="usage.html">common usages</a></span>
-
-    <section name="setup">
-      <p>
-        Place java sources files in :
-        <source>src/main/java</source>
-      </p>
-      <p>
-        Place java test sources files in :
-        <source>src/test/java</source>
-      </p>    
-      <p>
-        Place scala sources files in :
-        <source>src/main/scala</source>
-      </p>
-      <p>
-        Place scala test sources files in :
-        <source>src/test/scala</source>
-      </p>
-      <p>Make your pom file look similar to the following (this is what we use for integration testing):
-       <source>
-          <![CDATA[
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-	<modelVersion>4.0.0</modelVersion>
-
-	<groupId>org.scala-tools.maven-scala-plugin</groupId>
-	<artifactId>testJavaAndScala</artifactId>
-	<version>1.0-SNAPSHOT</version>
-	<name>Test for Java + Scala compilation</name>
-	<description>Test for Java + Scala compilation</description>
-
-	<dependencies>
-		<dependency>
-			<groupId>org.scala-lang</groupId>
-			<artifactId>scala-library</artifactId>
-			<version>2.7.2</version>
-		</dependency>
-	</dependencies>
-	<repositories>
-		<repository>
-			<id>scala-tools.org</id>
-			<name>Scala-tools Maven2 Repository</name>
-			<url>http://scala-tools.org/repo-releases</url>
-		</repository>
-	</repositories>
-	<pluginRepositories>
-		<pluginRepository>
-			<id>scala-tools.org</id>
-			<name>Scala-tools Maven2 Repository</name>
-			<url>http://scala-tools.org/repo-releases</url>
-		</pluginRepository>
-	</pluginRepositories>
-
-	<build>
-		<pluginManagement>
-			<plugins>
-				<plugin>
-					<groupId>org.scala-tools</groupId>
-					<artifactId>maven-scala-plugin</artifactId>
-					<version>2.9.1</version>
-				</plugin>
-				<plugin>
-					<groupId>org.apache.maven.plugins</groupId>
-					<artifactId>maven-compiler-plugin</artifactId>
-					<version>2.0.2</version>
-				</plugin>
-			</plugins>
-		</pluginManagement>
-		<plugins>
-			<plugin>
-				<groupId>org.scala-tools</groupId>
-				<artifactId>maven-scala-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>scala-compile-first</id>
-						<phase>process-resources</phase>
-						<goals>
-						    <goal>add-source</goal>
-							<goal>compile</goal>
-						</goals>
-					</execution>									
-					<execution>
-						<id>scala-test-compile</id>
-						<phase>process-test-resources</phase>
-						<goals>
-							<goal>testCompile</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<executions>
-					<execution>
-						<phase>compile</phase>
-						<goals>
-							<goal>compile</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-	</build>
-
-</project>
-
-          ]]>
-       </source>
-      </p>
-      <p>
-        Then use the standard maven phases :
-        <source>
-          <![CDATA[
-# compile only
-mvn compile
-# or compile and test
-mvn test
-# or compile, test and package
-mvn package
-       ]]>
-        </source>
-      </p>      
-      
-    </section>    
-
-  </body>
-</document>
diff --git a/src/site/xdoc/usage_run.xml b/src/site/xdoc/usage_run.xml
deleted file mode 100644
index 3281f67..0000000
--- a/src/site/xdoc/usage_run.xml
+++ /dev/null
@@ -1,64 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>Example</title>
-    <authors>
-      <person name="Brice Lambi"/>
-    </authors>
-  </properties>
-  <body>
-    <h1>Running a "main(args: Array[String])"</h1>
-
-    <div class="warning">
-      You must have a well define project, and it must compile your code successfully before (see
-      <a href="usage_compile.html">Compiling</a>
-      ).
-    </div>
-    <section name="Running">
-      <p>
-        So you can now run your scala app by defining the "mainClass" property :
-        <source>mvn scala:run -DmainClass=org.example.MyClass</source>
-      </p>
-    </section>
-    <section name="Using Launcher">
-      <p>You need to use launchers if you :
-        <ul>
-        <li>need to specify args and/or jvmArgs that are different from the main configuration</li>
-        <li>run and run again the same "configuration"/command line</li>
-        <li>want to store, some configuration for later user, or for sharing with other</li>
-        </ul>
-        </p>
-      <source><![CDATA[
-  <plugin>
-    <groupId>maven</groupId>
-    <artifactId>maven-scala-plugin</artifactId>
-    <configuration>
-      <launchers>
-        <launcher>
-          <id>foo</id>
-          <mainClass>org.example.MyClass</mainClass>
-          <!-- args are optional -->
-          <args>
-            <arg>arg1</arg>
-          </args>
-          <!-- jvmArgs are optional -->
-          <jvmArgs>
-            <jvmArg>-Xmx128m</jvmArg>
-            <jvmArg>-Djava.library.path=...</jvmArg>
-          </jvmArgs>
-        </launcher>
-        <!-- you could define other launcher -->
-      </launchers>
-    </configuration>
-  </plugin>]]>
-      </source>
-      <p>Now you can run the following command to run your launcher (the classpath used is the test classpath).</p>
-      <source>mvn scala:run -Dlauncher=foo</source>
-      <p>If you don't specify launcher or mainClass then the first launcher is used, in your case, the example below is equivalent to the example above.</p>
-    <source>mvn scala:run</source>
-      <p>If you need/which to specify some additional arguments at call time use "-DaddArgs=arg1|arg2|arg3" ('|' is used as separator)</p>
-      <p>Set the property 'displayCmd' to true, to display the command line used</p>
-
-    </section>
-  </body>
-</document>
diff --git a/src/site/xdoc/usage_scalac_plugins.xml b/src/site/xdoc/usage_scalac_plugins.xml
deleted file mode 100644
index 3694b37..0000000
--- a/src/site/xdoc/usage_scalac_plugins.xml
+++ /dev/null
@@ -1,108 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>Example Scalac plugin project</title>
-    <authors>
-      <person name="Josh Suereth"/>
-    </authors>
-  </properties>
-  <body>
-    <h1>Creating/Using a Scalac plugin</h1>
-    <section name="Project Setup">
-       <p>A scalac maven-based project has the following structure</p>
-       <source>
-project-root/
-  pom.xml
-  src/
-    main/
-      scala/
-        -Your plugin Source Here
-      resources/
-          scalac-plugin.xml
-       </source>
-       <p>Please follow the <a href="http://www.scala-lang.org/node/140">Writing Scala Compiler Plugins</a> tutorial for the content of the project.</p>
-      <p>A scalac plugin should *only* have dependencies on the scala-compiler artifact, and
-        these dependencies should be of type "provided". Here is an example pom for a plugin project:
-        </p>
-      <source><![CDATA[
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>org.scala-lang</groupId>
-  <artifactId>my-test-plugin</artifactId>
-  <packaging>jar</packaging>
-  <version>1.0-SNAPSHOT</version>
-  <name>Dependency Resolution extensions for the scala compiler</name>
-  <repositories>
-    <repository>
-      <id>scala-tools.org</id>
-      <name>Scala-tools Maven2 Repository</name>
-      <url>http://scala-tools.org/repo-releases</url>
-    </repository>
-  </repositories>
-  <pluginRepositories>
-    <pluginRepository>
-      <id>scala-tools.org</id>
-      <name>Scala-tools Maven2 Repository</name>
-      <url>http://scala-tools.org/repo-releases</url>
-    </pluginRepository>
-  </pluginRepositories>
-  <dependencies>
-    <dependency>
-      <groupId>org.scala-lang</groupId>
-      <artifactId>scala-compiler</artifactId>
-      <version>2.7.2</version>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.scala-tools</groupId>
-        <artifactId>maven-scala-plugin</artifactId>
-        <executions>
-          <execution>
-            <goals>
-              <goal>compile</goal>
-              <goal>testCompile</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <sourceDir>src/main/scala</sourceDir>
-          <jvmArgs>
-            <jvmArg>-Xms64m</jvmArg>
-            <jvmArg>-Xmx1024m</jvmArg>
-          </jvmArgs>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>]]>
-      </source>
-      <p>Now you need to make sure you install the plugin project into the local repository.</p>
-      <source>mvn install</source>
-    </section>
-    <section name="Using a scalac plugin">
-      <p>To make use of one or more scalac plugins, you need to declare them inside your pom using the "compilerPlugins" configuration item.</p>
-      <source><![CDATA[
-      <plugin>
-        <groupId>org.scala-tools</groupId>
-        <artifactId>maven-scala-plugin</artifactId>
-        ...
-        <configuration>
-          ...
-          <compilerPlugins>
-            <compilerPlugin>
-              <groupId>org.scala-lang</groupId>
-              <artifactId>my-scalac-plugin</artifactId>
-              <version>1.0-SNAPSHOT</version>
-            </compilerPlugin>
-          </compilerPlugins>
-        </configuration>
-      </plugin>]]>
-      </source>
-      <p>If you need to send arguments to the plugin, this can be done with the "args" confguration tag.</p>
-    </section>
-  </body>
-</document>
\ No newline at end of file
diff --git a/src/site/xdoc/usage_script.xml b/src/site/xdoc/usage_script.xml
deleted file mode 100644
index 6ad1012..0000000
--- a/src/site/xdoc/usage_script.xml
+++ /dev/null
@@ -1,170 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document>
-  <properties>
-    <title>Execute Script</title>
-    <authors>
-      <person name="Jesse Eichar" />
-    </authors>
-  </properties>
-  <body>
-    <h1>Running a scala script</h1>
-    <section name="Running a Script Inlined in the pom">
-      <p>
-      This goal allows you to execute a scala script defined in the pom.
-      </p>
-      <source><![CDATA[
-  <plugin>
-    <groupId>org.scala-tools</groupId>
-    <artifactId>maven-scala-plugin</artifactId>
-    <executions>
-      <execution>
-        <phase>package</phase>
-        <goals>
-          <goal>script</goal>
-        </goals>
-      </execution>
-    </executions>
-    <configuration>
-      <script>
-        println ("Hello from pom script :-)")
-     </script>
-    </configuration>
-  </plugin>]]></source>
-      </section>
-    <section name="Running from a Script File">
-      <p>
-        This goal allows you to run a scala script by defining the "script"
-        property:
-        <source>mvn scala:script -DscriptFile=scripts/PrintHello.scala</source>
-      </p>
-    </section>
-    <section name="Running a script as part of a build">
-      <p>Executing a script as part of the build process.</p>
-      <source><![CDATA[
-  <plugin>
-    <groupId>org.scala-tools</groupId>
-    <artifactId>maven-scala-plugin</artifactId>
-    <executions>
-      <execution>
-        <phase>package</phase>
-        <goals>
-          <goal>script</goal>
-        </goals>
-      </execution>
-    </executions>
-    <configuration>
-      <scriptFile>package.scala</scriptFile>
-    </configuration>
-  </plugin>]]></source>
-    </section>
-    <section name="Predefining a script file">
-      <p>Adding the script configuration to your plugin
-        definition.</p>
-      <source><![CDATA[
-  <plugin>
-    <groupId>maven</groupId>
-    <artifactId>maven-scala-plugin</artifactId>
-    <configuration>
-      <scriptFile>pathToScript/MyScript</scriptFile>
-    </configuration>
-  </plugin>]]></source>
-      <p>Now you can run the following command to run your scala app.
-      </p>
-      <source>mvn scala:script</source>
-    </section>
-    <section name="Classpath for running and compiling script">
-    The classpath is define by configuration 'includeScopes', 'excludeScopes', 'addToClasspath'.
-    The possible scopes are : test, compile, system, runtime, plugin. The default rules (since 2.14) is :
-    <ul>
-      <li>embedded script into pom.xml run with 'plugin' scope</li>
-      <li>script read from scriptFile run with 'compile, test, runtime'</li>
-    </ul>
-    </section>
-    <section name="Using the Maven Project from within a script">
-              <p>If the script run within the 'PLUGIN' scope then a scala.maven.model.MavenProjectAdapter object
-                and a org.apache.maven.plugin.logging.Log object will be passed
-                to the script.  The Log will have the name "log" and the
-                MavenProjectAdapter will have the name "project"
-              </p><p>
-                The class MavenProjectAdapter is a decorator for the MavenProject class
-                that adds typing to the java.util.Collection and adds
-                apply and update methods for accessing the properties of the project.
-              </p><p>
-                  Note: In this scenario the scala.collection.jcl.Conversions._ is imported so
-                  that the java.util collections can be treated as Scala collections.
-                </p>
-              <p>Here is an example script using the project</p>
-              <source><![CDATA[
-        <executions>
-          <execution>
-            <id>generate-hello</id>
-            <phase>generate-sources</phase>
-            <goals>
-              <goal>script</goal>
-            </goals>
-            <configuration>
-              <scalaVersion>2.7.7</scalaVersion>
-              <keepGeneratedScript>true</keepGeneratedScript>
-              <script>
-              &lt;![CDATA[
-                println("hello from scala script constructor")
-
-                def run() {
-                  import java.io.PrintWriter
-                  import scala.collection.jcl.Conversions._
-
-                  println("hello from scala script run method")
-                  log.info( project("scala.version") )
-                  val fo = new PrintWriter("target/hello.txt")
-                  try {
-                    fo.println(project.getArtifactId())
-                    for( d <- project.getDependencies() ) {
-                      fo.println (d.getArtifactId)
-                    }
-                  } finally {
-                    fo.close()
-                  }
-                }
-              ]]&gt;
-              </script>
-            </configuration>
-          </execution>
-        </executions>
-      </plugin>]]></source>
-    </section>
-    <section name="Technical details">
-        <p>
-                This mojo operates by adding a class definition to the start of the script.
-                As a result the script is essentially the initialization of the class.
-            </p>
-            <p>
-                The reason for this is that it allows one to define classes and functions in any
-                order and not worry about '<em>forward reference extends over definition of
-                value _</em>' compile errors.
-            </p>
-            <p>
-                However there is a danger in putting complex code in the constructor of a class and
-                that has to do poor performance because of certain precautions the JVM takes when
-                 constructing a class.  In order to offer a solution to this this Mojo will look for
-                 a run() method after the '<em>virtual</em>' class has been constructed and invokes
-                  that method.
-            </p>
-            <p>
-                If this mojo detects that the MavenProjectAdapter class is on the classpath
-                (in otherwords this plugin is a dependency in the scope that the script runs) then
-                the MavenProjectAdapter that decorates the current MavenProject will be passed to
-                the script's construct.  The variable name is '<em>project</em>'.  The project
-                variable can be used to inspect parameters of the maven project like the properties and
-                dependencies of the project.
-            </p>
-        <p>Here is an example using the run method with the MavenProjectAdapter</p>
-        <source><![CDATA[<script>
-  println ("Hi I shouldn't do any heavy work here...")
-  def run(){
-    println(project.getName+" is the current project")
-    println("Now lets do some serious work!  Even multi-threaded programming is allowed.")
-  }
-</script>]]></source>
-        </section>
-  </body>
-</document>
\ No newline at end of file

