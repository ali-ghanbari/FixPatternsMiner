diff --git a/src/edu/washington/escience/myria/operator/LeapFrogJoin.java b/src/edu/washington/escience/myria/operator/LeapFrogJoin.java
index 53dec1c..565a8ad 100644
--- a/src/edu/washington/escience/myria/operator/LeapFrogJoin.java
+++ b/src/edu/washington/escience/myria/operator/LeapFrogJoin.java
@@ -340 +340 @@
-      rowIndices = new int[getChildren().length];
+      rowIndices = new int[tables[tableIndex].numColumns()];
diff --git a/test/edu/washington/escience/myria/operator/LeapFrogJoinTest.java b/test/edu/washington/escience/myria/operator/LeapFrogJoinTest.java
index 9638d4b..cc3f5de 100644
--- a/test/edu/washington/escience/myria/operator/LeapFrogJoinTest.java
+++ b/test/edu/washington/escience/myria/operator/LeapFrogJoinTest.java
@@ -99,0 +100,37 @@
+  public void binaryJoinWithMoreColumns() throws DbException {
+    /* Query: Result(x,y,z) :- R(x,y),T(x,y,z). */
+    final Schema r_schema =
+        new Schema(ImmutableList.of(Type.LONG_TYPE, Type.LONG_TYPE), ImmutableList.of("r_x", "r_y"));
+    final Schema t_schema =
+        new Schema(ImmutableList.of(Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE), ImmutableList.of("t_x", "t_z",
+            "t_y"));
+    /* read data from files. */
+    final String r_path = Paths.get("testdata", "multiwayjoin", "R.csv").toString();
+    final String t_path = Paths.get("testdata", "multiwayjoin", "T.csv").toString();
+    FileScan fileScanR = new FileScan(r_path, r_schema);
+    FileScan fileScanT = new FileScan(t_path, t_schema);
+    /* order the tables. */
+    InMemoryOrderBy orderR = new InMemoryOrderBy(fileScanR, new int[] { 0, 1 }, new boolean[] { true, true });
+    InMemoryOrderBy orderT = new InMemoryOrderBy(fileScanT, new int[] { 0, 1 }, new boolean[] { true, true });
+    /* leapfrog join. */
+    int[][][] fieldMap = new int[][][] { { { 0, 0 }, { 1, 0 } }, { { 0, 1 }, { 1, 2 } } };
+    int[][] outputMap = new int[][] { { 0, 0 }, { 0, 1 } };
+    final ImmutableList<String> outputColumnNames = ImmutableList.of("x", "y");
+    final Schema outputSchema = new Schema(ImmutableList.of(Type.LONG_TYPE, Type.LONG_TYPE), outputColumnNames);
+    LeapFrogJoin join =
+        new LeapFrogJoin(new Operator[] { orderR, orderT }, fieldMap, outputMap, outputColumnNames, new boolean[] {
+            false, false });
+    join.open(null);
+    TupleBatch tb;
+    TupleBatchBuffer batches = new TupleBatchBuffer(outputSchema);
+    while (!join.eos()) {
+      tb = join.nextReady();
+      if (tb != null) {
+        batches.appendTB(tb);
+      }
+    }
+    join.close();
+    assertEquals(0, batches.numTuples());
+  }
+
+  @Test

