diff --git a/src/main/java/com/hearthsim/util/DeckFactory.java b/src/main/java/com/hearthsim/util/DeckFactory.java
index f75ecaa..3dff321 100644
--- a/src/main/java/com/hearthsim/util/DeckFactory.java
+++ b/src/main/java/com/hearthsim/util/DeckFactory.java
@@ -37,0 +38 @@
+        this.limitCopies = limitCopies;
diff --git a/src/test/java/com/hearthsim/test/util/DeckFactoryTest.java b/src/test/java/com/hearthsim/test/util/DeckFactoryTest.java
index 1fef579..03a7ccd 100644
--- a/src/test/java/com/hearthsim/test/util/DeckFactoryTest.java
+++ b/src/test/java/com/hearthsim/test/util/DeckFactoryTest.java
@@ -5,0 +6 @@
+import java.util.HashMap;
@@ -7 +7,0 @@
-import java.util.function.Predicate;
@@ -11,0 +12 @@
+import com.hearthsim.card.Deck;
@@ -67,0 +69,149 @@
+    
+    @Test
+    public void checkHasOnlyCollectible()
+    {
+    	ArrayList<ImplementedCard> onlyCollectible = new DeckFactoryBuilder().buildDeckFactory().getAllPossibleCards();
+    	
+    	for(ImplementedCard card : onlyCollectible)
+    	{
+    		String errorMessage = card.name_ + " is not collectible.";
+    		assertTrue(errorMessage, card.collectible);
+    	}
+    }
+    
+    @Test
+    public void checkAllowUnCollectibleHasEveryCard()
+    {
+    	DeckFactoryBuilder builder = new DeckFactoryBuilder();
+    	builder.allowUncollectible();
+    	ArrayList<ImplementedCard> allCardsList = builder.buildDeckFactory().getAllPossibleCards();
+    	HashSet<ImplementedCard> allCards = new HashSet<ImplementedCard>();
+    	allCards.addAll(allCardsList);
+    	
+    	for(ImplementedCard card : referenceCards)
+    	{
+    		String errorMessage = "DeckFactory did not contain " + card.name_;
+    		assertTrue(errorMessage, allCards.contains(card));
+    	}
+    }
+    
+    @Test
+    public void checkFilterByManaCost()
+    {
+    	DeckFactoryBuilder builder = new DeckFactoryBuilder();
+    	builder.filterByManaCost(3, 7);
+    	ArrayList<ImplementedCard> filteredCards = builder.buildDeckFactory().getAllPossibleCards();
+    	
+    	for(ImplementedCard card : filteredCards)
+    		assertTrue(card.mana_ >= 3 && card.mana_ <= 7);
+    }
+    
+    @Test
+    public void checkLimitedCopies()
+    {
+    	Deck deckTest = new DeckFactoryBuilder().buildDeckFactory().generateRandomDeck();
+    	HashMap<String, Integer> cardCounts = new HashMap<String, Integer>();
+    	
+    	HashMap<String, ImplementedCard> nameToCard = new HashMap<String, ImplementedCard>();
+    	for(ImplementedCard card : referenceCards)
+    		nameToCard.put(card.name_, card);
+    	for(int i = 0; i < 30; i++)
+    	{
+    		String cardName = deckTest.drawCard(i).getName();
+    		if (cardCounts.containsKey(cardName))
+    		{
+    			if (nameToCard.get(cardName).rarity_.equals("legendary"))
+    				fail("Should only have one copy of " + cardName + ".");
+    			else
+    			{
+    				assertEquals(cardCounts.get(cardName), new Integer(1));
+    				cardCounts.put(cardName, 2);
+    			}
+    		}
+    		else
+    			cardCounts.put(cardName, 1);
+    	}
+    }
+    
+    @Test
+    public void checkUnlimitedCopiesLegendary()
+    {
+    	DeckFactoryBuilder builder = new DeckFactoryBuilder();
+    	builder.allowUnlimitedCopiesOfCards();
+    	DeckFactory factory = builder.buildDeckFactory();
+    	long start = System.currentTimeMillis();
+    	boolean testPassed = false;
+    	
+    	// This maximum time limit is extremely generous and should take well under a second to complete.
+    	mainloop : while(System.currentTimeMillis() - start < 10_000)
+    	{
+    		Deck deckTest = factory.generateRandomDeck();
+        	HashMap<String, Integer> cardCounts = new HashMap<String, Integer>();
+    		HashMap<String, ImplementedCard> nameToCard = new HashMap<String, ImplementedCard>();
+    		for(ImplementedCard card : referenceCards)
+    			nameToCard.put(card.name_, card);
+    		for(int i = 0; i < 30; i++)
+    		{
+    			String cardName = deckTest.drawCard(i).getName();
+    			if (cardCounts.containsKey(cardName))
+    			{
+    				if (nameToCard.get(cardName).rarity_.equals("legendary"))
+    				{
+    					testPassed = true;
+    					break mainloop;
+    				}
+    				else
+    				{
+    					cardCounts.put(cardName, cardCounts.get(cardName) + 1);
+    				}
+    			}
+    			else
+    				cardCounts.put(cardName, 1);
+    		}
+    	}
+    	
+    	assertTrue("DeckFactory could not generate a deck with more than one legendary within the time limit.", testPassed);
+    }
+    
+    public void checkUnlimitedCopiesNonLegendary()
+    {
+    	DeckFactoryBuilder builder = new DeckFactoryBuilder();
+    	builder.allowUnlimitedCopiesOfCards();
+    	DeckFactory factory = builder.buildDeckFactory();
+    	long start = System.currentTimeMillis();
+    	boolean testPassed = false;
+    	
+    	// This maximum time limit is extremely generous and should take well under a second to complete.
+    	mainloop : while(System.currentTimeMillis() - start < 10_000)
+    	{
+    		Deck deckTest = factory.generateRandomDeck();
+        	HashMap<String, Integer> cardCounts = new HashMap<String, Integer>();
+    		HashMap<String, ImplementedCard> nameToCard = new HashMap<String, ImplementedCard>();
+    		for(ImplementedCard card : referenceCards)
+    			nameToCard.put(card.name_, card);
+    		for(int i = 0; i < 30; i++)
+    		{
+    			String cardName = deckTest.drawCard(i).getName();
+    			if (cardCounts.containsKey(cardName))
+    			{
+    				if (nameToCard.get(cardName).rarity_.equals("legendary"))
+    				{
+    					cardCounts.put(cardName, cardCounts.get(cardName) + 1);
+    				}
+    				else
+    				{
+    					cardCounts.put(cardName, cardCounts.get(cardName) + 1);
+    					if (cardCounts.get(cardName) > 2)
+    					{
+        					testPassed = true;
+        					break mainloop;
+    					}
+    				}
+    			}
+    			else
+    				cardCounts.put(cardName, 1);
+    		}
+    	}
+    	
+    	assertTrue("DeckFactory could not generate a deck with more than one legendary within the time limit.", testPassed);
+    }

