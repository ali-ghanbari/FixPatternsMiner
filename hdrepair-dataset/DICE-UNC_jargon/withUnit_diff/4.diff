diff --git a/jargon-transfer/jargon-transfer-dao-spring/src/main/java/org/irods/jargon/transfer/dao/spring/SynchronizationDAOImpl.java b/jargon-transfer/jargon-transfer-dao-spring/src/main/java/org/irods/jargon/transfer/dao/spring/SynchronizationDAOImpl.java
index 222329f..76634c6 100644
--- a/jargon-transfer/jargon-transfer-dao-spring/src/main/java/org/irods/jargon/transfer/dao/spring/SynchronizationDAOImpl.java
+++ b/jargon-transfer/jargon-transfer-dao-spring/src/main/java/org/irods/jargon/transfer/dao/spring/SynchronizationDAOImpl.java
@@ -93,0 +94 @@
+			criteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
diff --git a/jargon-transfer/jargon-transfer-engine/src/test/java/org/irods/jargon/transfer/engine/TransferManagerForSynchTest.java b/jargon-transfer/jargon-transfer-engine/src/test/java/org/irods/jargon/transfer/engine/TransferManagerForSynchTest.java
index 1959011..ad1b931 100644
--- a/jargon-transfer/jargon-transfer-engine/src/test/java/org/irods/jargon/transfer/engine/TransferManagerForSynchTest.java
+++ b/jargon-transfer/jargon-transfer-engine/src/test/java/org/irods/jargon/transfer/engine/TransferManagerForSynchTest.java
@@ -4,0 +5 @@
+import java.util.List;
@@ -7,0 +9 @@
+import junit.framework.TestCase;
@@ -122,2 +124 @@
-				// Assert.fail("synch timed out"); FIXME uncomment after
-				// debugging done
+				Assert.fail("synch timed out");
@@ -143,0 +145,99 @@
+	
+	@Test
+	public void testEnqueueSynchTwice() throws Exception {
+		TransferManager transferManager = new TransferManagerImpl(
+				IRODSFileSystem.instance());
+
+		IRODSAccount irodsAccount = testingPropertiesHelper
+				.buildIRODSAccountFromTestProperties(testingProperties);
+
+		String rootCollection = "testEnqueueSynchTwice";
+		String localCollectionAbsolutePath = scratchFileUtils
+				.createAndReturnAbsoluteScratchPath(IRODS_TEST_SUBDIR_PATH
+						+ '/' + rootCollection);
+
+		String irodsCollectionRootAbsolutePath = testingPropertiesHelper
+				.buildIRODSCollectionAbsolutePathFromTestProperties(
+						testingProperties, IRODS_TEST_SUBDIR_PATH + "/"
+								+ rootCollection);
+		IRODSFile irodsSynchFile = irodsFileSystem.getIRODSFileFactory(
+				irodsAccount)
+				.instanceIRODSFile(irodsCollectionRootAbsolutePath);
+		irodsSynchFile.mkdirs();
+
+		FileGenerator
+				.generateManyFilesAndCollectionsInParentCollectionByAbsolutePath(
+						localCollectionAbsolutePath, "testSubdir", 1, 2, 1,
+						"testFile", ".txt", 3, 2, 2, 5);
+
+		Synchronization synchronization = new Synchronization();
+		synchronization
+				.setSynchronizationMode(SynchronizationType.ONE_WAY_LOCAL_TO_IRODS);
+		synchronization.setName(rootCollection);
+		synchronization.setCreatedAt(new Date());
+		synchronization.setDefaultResourceName(irodsAccount
+				.getDefaultStorageResource());
+		synchronization.setFrequencyType(FrequencyType.EVERY_FIFTEEN_MINUTES);
+		synchronization.setIrodsHostName(irodsAccount.getHost());
+		synchronization.setIrodsPassword(irodsAccount.getPassword());
+		synchronization.setIrodsPort(irodsAccount.getPort());
+		synchronization.setIrodsSynchDirectory(irodsCollectionRootAbsolutePath);
+		synchronization.setIrodsUserName(irodsAccount.getUserName());
+		synchronization.setIrodsZone(irodsAccount.getZone());
+		synchronization.setLocalSynchDirectory(localCollectionAbsolutePath);
+		SynchManagerService synchManagerService = transferManager
+				.getTransferServiceFactory().instanceSynchManagerService();
+		synchManagerService.createNewSynchConfiguration(synchronization);
+
+		synchronization = synchManagerService.findByName(rootCollection);
+
+		transferManager.purgeAllTransfers();
+
+		transferManager.enqueueASynch(synchronization, irodsAccount);
+		transferManager.enqueueASynch(synchronization, irodsAccount);
+
+		// let synch run
+
+		int waitCtr = 0;
+
+		while (true) {
+			if (waitCtr++ > 20) {
+				 //Assert.fail("synch timed out"); 
+			}
+			Thread.sleep(1000);
+			if (transferManager.getRunningStatus() == TransferManager.RunningStatus.IDLE) {
+				break;
+			}
+
+		}
+
+		/*
+		Assert.assertEquals("should have been no errors",
+				TransferManager.ErrorStatus.OK,
+				transferManager.getErrorStatus());
+				*/
+		FileTreeDiffUtility fileTreeDiffUtility = new FileTreeDiffUtilityImpl(
+				irodsAccount, irodsFileSystem.getIRODSAccessObjectFactory());
+		boolean noDiffs = fileTreeDiffUtility.verifyLocalAndIRODSTreesMatch(
+				new File(localCollectionAbsolutePath),
+				irodsCollectionRootAbsolutePath, 0L, 0L);
+
+		Assert.assertTrue("diffs found after synch", noDiffs);
+		
+		// make sure only one synch with this name
+		
+		List<Synchronization> synchronizations = synchManagerService.listAllSynchronizations();
+		int synchCount = 0;
+		
+		for (Synchronization actualSynchronization : synchronizations){
+			if (actualSynchronization.getName().equals(rootCollection)) {
+				synchCount++;
+			}
+		}
+		
+		TestCase.assertEquals("found more than one synch with a given name", 1, synchCount);
+		
+		
+		
+
+	}

