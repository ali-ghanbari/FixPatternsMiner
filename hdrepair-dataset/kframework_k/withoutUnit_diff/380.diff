diff --git a/javasources/K3Disamb/lib/analysis-library-internal.generated.str b/javasources/K3Disamb/lib/analysis-library-internal.generated.str
new file mode 100644
index 0000000..2c19ed7
--- /dev/null
+++ b/javasources/K3Disamb/lib/analysis-library-internal.generated.str
@@ -0,0 +1,731 @@
+module lib/analysis-library-internal.generated
+ 
+imports
+  libstratego-lib
+  libstratego-parallel
+  lib/editor-common.generated
+  lib/analysis-library.generated
+  lib/index-library.generated
+  
+signature constructors
+  
+  // Analysis
+  Results         : AST * List(Def) * List(Use) * List(DefData) * List(Def) * List(Def) * List(File) -> Results
+  ParallelResults : AST * AST * List(Error) * List(Warning) * List(Note) * List(File) -> ParallelResults
+  
+  // Namespaces
+  Diff            : Namespace
+  ASTDiff         : Namespace
+  
+rules // Analysis traversals
+  
+  /**
+   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
+   *
+   * @internal
+   * @type List((ast, (file, subfile))) -> Results(List(ast), List(def), List(use), List(data), List(addedElem), 
+   *                                       List(removedElem), List(fileToAnalyze@(file, subfile))))
+   */
+  analyze-top-internal(|phase, language, project-path, full-path):
+    astFilePairs -> Results(asts, defs, uses, data, added, removed, filesToAnalyze)
+    with
+      // Init
+      index-setup(|language, [project-path], full-path);
+      revision := <index-start-transaction>
+    with
+      // Store old elements
+      oldElems := <filter(index-diff-constructors)> <index-get-all-in-file> full-path;
+      <index-clear-file> full-path
+    with
+      {| Index-UnresolvedSet:
+        unresolvedSet := <new-iset>;
+        rules(Index-UnresolvedSet: _ -> unresolvedSet);
+        
+        (astFilePairs2, defsList) := <unzip> <map(analyze-top-defs)> astFilePairs;
+        defs := <concat> defsList;
+        (astFilePairs3, dataList) := <unzip> <map(analyze-top-data(|language, full-path))> astFilePairs2;
+        data := <concat> dataList;
+        (astFilePairs4, usesList) := <unzip> <map(analyze-top-uses(|language, full-path))> astFilePairs3;
+        uses := <concat> usesList;
+        (asts, _) := <unzip> astFilePairs4
+      |}
+    with
+      index-end-transaction
+    with
+      // Schedule re-analysis of dependent files (if current file is not testing language file)
+      // HACK: Depends on file extension, could be other languages with .spt extension?
+      if Editor() := phase; not(<is-test-file> full-path) then
+        newElems := <conc> (defs, <filter(index-diff-constructors)> data);
+        
+        // Find added and removed definitions
+        (added, removed) := <analyze-diff> (oldElems, newElems);
+        changed := <conc> (added, removed);
+        
+        // Store files that have changed in the index
+        index-transaction(
+          filesToAnalyze := <analyze-store-diff(|changed, revision)> astFilePairs4
+        )
+      else
+        (added, removed) := ([], []);
+        filesToAnalyze := []
+      end
+    with
+      <list-loop(analyze-top-store-ast)> astFilePairs4
+      
+  /**
+   * Add URI annotations to each definition and unresolved URI annotations to each use site.
+   *
+   * @internal
+   */
+  analyze-top-defs:
+    (ast, file) -> ((ast2, file), defs)
+    with
+      <index-set-current-file> file;
+      (Some(ast2), defs) := <analyze-defs> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
+      <index-add-all(|file)> defs
+      
+  /**
+   * Gathers all data for each definition.
+   *
+   * @internal
+   */
+  analyze-top-data(|language, full-path):
+    (ast, file) -> ((ast2, file), data2)
+    with
+      <index-set-current-file> file;
+      {| Index-ReadSet:
+        readSet := <new-iset>;
+        rules(Index-ReadSet: _ -> readSet);
+        
+        // Gather all data for each definition.
+        ast2 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast; // Parent pointers needed.
+        data := <origin-track-forced(analyze-tree-data)> ast2;
+        
+        // Resolve all references in gathered data.
+        (data2, _) := <analyze-uses> data; // Ignoring data uses, have not found a use-case for them yet.
+        <index-add-all(|file)> data2;
+        
+        // Store reads into the index (if not testing language)
+        if not(is-test-input(|language, full-path)) then
+          <index-add-all(|file)> <iset-elements> readSet
+        end
+      |}
+      
+  /**
+   * Resolves all unresolved references for each use site.
+   *
+   * @internal
+   */
+  analyze-top-uses(|language, full-path):
+    (ast, file) -> ((ast3, file), uses)
+    with
+      <index-set-current-file> file;
+      {| Index-ReadSet:
+        readSet := <new-iset>;
+        rules(Index-ReadSet: _ -> readSet);
+        
+        // Resolve all unresolved references for each use site.
+        (ast2, uses) := <analyze-uses> ast;
+        <index-add-all(|file)> uses;
+        
+        ast3 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast2; // AST changed, reset parent pointers.
+        
+        // Store reads into the index (if not testing language)
+        if not(is-test-input(|language, full-path)) then
+          <index-add-all(|file)> <iset-elements> readSet
+        end
+      |}
+      
+  /**
+   * Stores AST from file to the index.
+   *
+   * @internal
+   */   
+  analyze-top-store-ast:
+    (ast, file) -> <id>
+    with
+      <index-set-global(|<conc> (<index-file-to-uri> file, ["ast"]))> ast
+      
+  /**
+   * Identifies all definitions in the tree and annotates them with their URI.
+   * Also annotates uses with a preliminary "Unresolved(_)" URI.
+   *
+   * @internal
+   */
+  analyze-defs = analyze-defs(|Anon(), Anon())
+  /** @internal */
+  analyze-defs(|head-scope, head-scope-ns):
+    ast -> (ast', defs')
+    with
+      if def := <nam-get-definition> ast then
+        Def(def-path)                     := def;
+        [head-scope-ns', head-scope' | _] := def-path
+      else
+        def-path       := INTERNAL_ERROR();
+        head-scope-ns' := head-scope-ns;
+        head-scope'    := head-scope
+      end;
+      if scope-types := <nam-get-scope-types> ast then
+        {| IndexPath:
+          <list-loop(update-index-path(|head-scope', head-scope-ns', ast))> scope-types;
+          // <balanced-update-path> head-scope';
+          (ast', defs) := <analyze-defs-recurse(|Anon(), Anon(), def-path)> ast
+        |}
+      else
+        (ast', defs) := <analyze-defs-recurse(|head-scope', head-scope-ns', def-path)> ast
+      end;
+      defs' := <![def | defs] <+ !defs>
+      
+  /** @internal */
+  analyze-defs-recurse(|head-scope, head-scope-ns, def-path):
+    ast -> (ast'', defs)
+    where
+      analyzed      := <all(analyze-defs(|head-scope, head-scope-ns))> ast;
+      (ast', defs)  := <unzip-analyzed> analyzed;
+      ast''         := <try(nam-annotate-names(|def-path))> ast'
+ 
+  /** @internal */
+  update-index-path(|head-scope, head-scope-ns, ast):
+    scope-type -> scope-type
+    where
+      if !head-scope-ns => Anon() then
+        path  := <IndexPath <+ ![]> scope-type;
+        path' := <do-adjusted-index-path(|scope-type, path, Anon(<new>))> ast
+      else
+        path  := <IndexPath <+ ![]> head-scope-ns;
+        path' := <do-adjusted-index-path(|scope-type, path, head-scope)> ast
+      end;
+      rules(IndexPath: scope-type -> path')
+ 
+  /* TODO: consider using simple-update-def-path
+   *       which uses "balanced" path scopes
+   *       e.g. when Entity doesn't scope Function
+   *       then it's hard to access properties from a function
+  balanced-update-index-path:
+    head-scope -> head-scope
+    where
+      if !head-scope => Anon() then
+        head-scope' := Anon(<new>)
+      else
+        head-scope' := head-scope
+      end;
+      (something with do-adjust-path)
+      rules(IndexPath := [head-scope' | <IndexPath <+ ![]> ()])
+  */
+ 
+  /**
+   * Analyze all uses, changing their preliminary "Unresolved(_)" URI to a definite URI of their definition.
+   *
+   * @internal
+   */
+  analyze-uses:
+    ast -> (ast'', uses')
+    with
+      analyzed     := <all(analyze-uses)> ast;
+      (ast', uses) := <unzip-analyzed> analyzed;
+      if !ast' => _{unresolved@[Unresolved(namespace), x | path]} then
+        if Def(def-uri) := <index-lookup(id |namespace, path, <strip-annos> ast')> ast' then
+          ast'' := ast{def-uri};
+          uses' := [Use(def-uri) | uses]
+        else
+          ast'' := ast';
+          uses' := [BadUse([namespace, x]) | uses]
+        end
+      else
+        ast'' := ast';
+        uses' := uses
+      end
+ 
+  /**
+   * Collects all index data (e.g. types of definitions).
+   *
+   * @internal
+   */
+  analyze-tree-data:
+    tree -> data
+    where
+      set := <new-iset>;
+      <topdown(analyze-tree-data-part(|set))> tree;
+      data := <iset-elements> set
+      
+  /** @internal */
+  analyze-tree-data-part(|set):
+    tree -> tree
+    where
+      if def-term := <nam-get-definition-key> then
+        _{[namespace | path]} := def-term;
+        if result := <adjust-index-def-data(store-index-data-results(|set) |namespace, path)> tree then
+          <fatal-err(|"Unexpected result from adjust-index-def-data; should call <store-results>")> result
+        end
+      end
+  
+  /** @internal */
+  store-index-data-results(|set):
+    t -> <fail>
+    where
+      if is-list then
+        <iset-addlist(|t)> set
+      else
+        <iset-add(|t)> set
+      end
+      
+rules // Parallel analysis
+  
+  /** @internal */
+  index-parallel-analyze(analyze):
+    files -> allResults
+    with
+      map(index-parse-file); // Parsing cannot be done in parallel.
+      map(\(ast, file) -> (ast, file, <project-path>)\);
+      parallel-unordered(all(index-analyze(analyze)));
+      ?results;
+      with(<eq> (<length> results, <length> files) | "Input size not equal to output size");
+      filesToAnalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
+      if not([] := filesToAnalyze) then
+        allResults := <concat> [results, <index-parallel-analyze(analyze)> filesToAnalyze]
+      else
+        allResults := results
+      end
+  
+  /** @internal */   
+  index-parse-file:
+    file -> (ast, file)
+    with
+    if <file-exists> file then
+      ast := <parse-file> file
+    else
+      ast := ()
+    end
+   
+  /** @internal */   
+  index-set-markers:
+    ParallelResults(ast, ast', errors, warnings, notes, diffs) -> <id>
+    with
+      <set-markers(|ast)> (ast', errors, warnings, notes)
+      
+  /** @internal */
+  index-analyze(analyze):
+    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, filesToAnalyze)
+    with
+      (ast', errors, warnings, notes, filesToAnalyze) := <analyze>;
+      if [] := filesToAnalyze then
+        complete-work-unit
+      end
+      
+/** @internal */
+rules // Splitter
+  
+  /** @internal */
+  index-split = fail
+  /** @internal */
+  index-is-toplevel = fail
+  /** @internal */
+  index-is-qualifier = fail
+  /** @internal */
+  index-qualifier-subelements = fail
+  /** @internal */
+  index-create-qualifier(|qualifier) = fail
+  
+  /** @internal */
+  index-toplevel-split:
+    ast -> asts'
+    with
+      (ast', _) := <analyze-defs> ast;
+      asts      := <index-toplevel-split-internal> ast';
+      asts'     := <strip-annos> asts
+      
+  /** @internal */
+  index-toplevel-split-internal:
+    node -> units
+    with
+      switch id
+        case ?():
+          units := [((), [])]
+        case index-is-qualifier:
+          elems := <mapconcat(index-toplevel-split-internal)> <index-qualifier-subelements> node;
+          units := <map(index-transform-qualifier(|node))> elems
+        case index-is-toplevel:
+          units := [(node, <index-uri> <nam-get-definition-key> node)]
+        otherwise:
+          units := [(node, [])]
+      end
+      
+  /** @internal */
+  index-transform-qualifier(|node):
+    (elem, subfileName) -> (qualifier, subfileName)
+    with
+      qualifier := <index-create-qualifier(|node)> elem
+
+/** @internal */
+rules // Diffs
+  
+  /** @internal */
+  analyze-diff:
+    (defs1, defs2) -> (added, removed)
+    with
+      added   := <diff(index-diff-compare)> (defs2, defs1);
+      removed := <diff(index-diff-compare)> (defs1, defs2)
+    
+  /** @internal */
+  analyze-store-diff(|changedEntries, revision): 
+    astFilePairs -> analyzeFiles'
+    with
+      changedFiles    := <mapconcat(index-get-files-of)> changedEntries;
+      dependentFiles  := <index-get-dependent-files> changedEntries;
+      
+      // Files to analyze
+      analyzeFiles := <make-set> <remove-all(fake-file)> dependentFiles;
+      analyzeFiles' := analyzeFiles;
+      // TODO: Is this extra check needed?
+      /*if <getfirst(index-get-file-revision; \r -> (r, revision)\; gt)> analyzeFiles then
+        // Add current file if the current file has read information from another file with a higher revision.
+        // This indicates that potentially outdated information was read.
+        analyzeFiles' := [file|analyzeFiles]
+      else
+        analyzeFiles' := analyzeFiles
+      end;*/
+      
+      // Files to compile
+      changedAstFiles := <filter(analyze-astdiff)> astFilePairs;
+      compileFiles := <make-set> <concat> [analyzeFiles', changedFiles, changedAstFiles];
+      // TODO: Optimize so that there are no duplicate files stored in the index, use iset?
+      <map(analyze-add-compilediff)> compileFiles
+      
+  /** 
+   * Checks if ast for given file has changed. Succeeds if old ASTDiff is not found or if ASTDiff is different.
+   *
+   * @internal
+   */
+  analyze-astdiff:
+    (ast, file) -> file
+    where
+      name := <conc> (<index-file-to-uri> file, ["ast-checksum"]);
+      newChecksum := <checksum> ast;
+      if oldChecksum := <index-get-global(|name)> then
+        <index-set-global(|name)> newChecksum;
+        not(<eq> (oldChecksum, newChecksum))
+      else
+        <index-set-global(|name)> newChecksum
+      end
+      
+  /** 
+   * Adds given file to the list of files to compile.
+   *
+   * @internal
+   */
+  analyze-add-compilediff = index-add-global(|"compile-diff")
+  
+  /** 
+   * Gets the list of files to compile, and then clear it.
+   *
+   * @internal
+   */
+  analyze-get-compilediffs = index-get-all-globals(|"compile-diff"); index-clear-global(|"compile-diff")
+  
+rules // Index lookup rules (that take into account adjust-index-lookup)
+  
+  /**
+   * Given an annotated AST node, resolves it, returning all its Defs.
+   *
+   * @param prefix  Only Defs with a name that starts with this string are returned.
+   *
+   * @internal
+   * @type "name"{uri} -> ?Def(uri')
+   */
+  index-lookup(is-adjust-lookup-enabled|namespace, path, prefix):
+    x -> def
+    where
+      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
+      if <?StopLookup()> candidates then
+        fail
+      else
+        def        := <index-select(|namespace, path, x)>
+      <+
+        // TODO: optimize: try not to call do-adjust-index-lookup from here
+        [_ | path'] := path;
+        def         := <index-lookup(is-adjust-lookup-enabled|namespace, path', prefix)> x
+      end
+
+  /**
+   * Given an annotated AST node, resolves it, returning all its Defs.
+   *
+   * @param prefix  Only Defs with a name that starts with this string are returned.
+   *
+   * @type "name"{uri} -> List(Def(uri'))
+   * @internal
+   */
+  index-lookup-all(is-adjust-lookup-enabled|namespace, path, prefix):
+    x -> defs'
+    where
+      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
+      defs       := <index-select-all(|namespace, path, x)>;
+      // TODO: optimize: try not to call do-adjust-index-lookup from here
+      if [_ | path'] := path then
+        defs2 := <index-lookup-all(is-adjust-lookup-enabled|namespace, path', prefix)> x;
+        defs' := <conc> (defs, defs2)
+      else
+        defs' := defs
+      end
+      
+  /**
+   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
+   *
+   * @param prefix  Only Defs with a name that starts with this string are returned.
+   *
+   * @type "name"{uri} -> ?Def(uri')
+   * @internal
+   */
+  index-lookup-outermost(is-adjust-lookup-enabled |namespace, path, prefix):
+    x -> def
+    where
+      // TODO: optimize: just like index-lookup
+      [_ | path'] := path;
+      def         := <index-lookup-outermost(is-adjust-lookup-enabled |namespace, path', prefix)> x
+    <+
+      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
+      def        := <index-select(|namespace, path, x)>
+      
+  /**
+   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   *
+   * @param namespace Only Defs with this namespace are returned.
+   * @param prefix    Only Defs with a name that starts with this string are returned.
+   *
+   * @type "name"{uri} -> List(Def(uri'))
+   * @internal
+   */
+  index-lookup-one-level(is-adjusted-lookup-enabled|namespace, path, prefix):
+    x{_} -> defs
+    with
+      is-adjusted-lookup-enabled;
+      do-adjust-index-lookup(|namespace, path, x, prefix);
+      if ?StopLookup() then
+        defs := StopLookup()
+      else
+        mapconcat(\d@Def(p) -> [d]\
+          <+ \[namespace' | path'] -> <index-lookup-one-level(fail |namespace', path', prefix)> x\
+          <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
+        ?defs
+      end
+    <+
+      defs := <index-get-children(|namespace, prefix)> Def([namespace | path])
+      
+  /**
+   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   *
+   * @param prefix  Only Defs with a name that starts with this string are returned.
+   *
+   * @internal
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-all-levels(is-adjust-lookup-enabled |namespace, path, prefix):
+    x{_} -> all-defs
+    with
+      is-adjust-lookup-enabled;
+      do-adjust-index-lookup(|namespace, path, x, prefix);
+      if ?StopLookup() then
+        all-defs := []
+      else
+        mapconcat(\d@Def(p) -> [d]\
+            <+ \[namespace' | path'] -> <index-lookup-all-levels(fail |namespace', path', prefix)> x\
+            <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
+        ?all-defs
+      end
+    <+
+      one-level := <index-get-children(|namespace, prefix)> Def([namespace | path]);
+      if [_ | path'] := path then
+        all-defs := <concat> [one-level, <index-lookup-all-levels(fail |namespace, path', prefix)> x]
+      else
+        all-defs := one-level
+      end
+      
+/** @internal */
+rules // URI and value projections
+       
+  /** @internal */
+  index-uri-impl:
+    Def(uri) -> uri
+    
+  /** @internal */  
+  index-uri-impl:
+    Use(uri) -> uri
+    
+  /** @internal */  
+  index-uri-impl:
+    Read(uri) -> uri
+    
+  /** @internal */  
+  index-uri-impl:
+    x{[namespace | path]} -> [<index-namespace-unwrap> namespace | path]
+ 
+  /**
+   * TODO: Should second part of ReadWildcard be included in the URI, between namespace and path?
+   * 
+   * @internal 
+   */
+  index-uri-impl:
+    ReadWildcard(uri, _) -> uri
+
+  /** @internal */
+  index-value-impl:
+    Def(value) -> value
+
+  /** @internal */
+  index-value-impl:
+    Use(value) -> value
+
+  /** @internal */
+  index-value-impl:
+    Read(value) -> value
+  
+  /** @internal */
+  index-value-impl:
+    ReadWildcard(_, value) -> value
+       
+/** @internal */
+rules // Internal helpers
+
+  /**
+   * Transforms a term C( (a1, [b1]), (a2, [b2, b3]) ) to a tuple (C(a1, a2), [b1, b2, b3]).
+   *
+   * @internal
+   */
+  unzip-analyzed:
+    appl -> (appl', unzipped-parts)
+    with
+      appl'          := <all(\(a, _) -> a\)> appl;
+      unzipped-parts := <concat> <get-appl-arguments(\(_, b) -> b\) <+ map(\(_, b) -> b\) <+ ![]> appl
+       
+  /**
+   * Tests if the current file is just a testing language input
+   *
+   * @internal
+   */
+  is-test-file = 
+    string-ends-with(|".spt")
+  /** @internal */
+  is-test-language = 
+    ?"Spoofax-Testing"
+  /** @internal */
+  is-test-input(|language, path) = 
+    <is-test-language> language <+ <is-test-file> path
+      
+  /** @internal */
+  fake-file = 
+    is-test-file <+ index-is-fake-file
+  
+  /** @internal */    
+  index-filepair-to-file = 
+    Fst; string-replace(|$[[<project-path>]/], "")
+  
+  /** @internal */
+  ast-uri-to-ast-file(|full-path):
+    (ast, uri) -> (ast, (full-path, uri))
+  
+  /** @internal */     
+  index-is-name-substring(|name):
+    template -> <id>
+    with
+      [_, uri-name | _] := <index-uri>
+    where
+      <is-substring(!name)> uri-name
+   
+  /** @internal */    
+  index-readwildcard-substring(|prefix):
+    ReadWildcard(_, name) -> <id>
+    where <is-substring(!prefix)> name
+  
+  /** @internal */  
+  store-wildcard-read(|namespace, path, prefix):
+    children -> <id>
+    with
+      if set := <Index-ReadSet> then
+        if 1 := <length> children then
+          // HACK: This solves the problem of ReadWildcards making too many files re-analyze, but this should
+          // be handled in the index primitives instead.
+          <iset-add(|Read([namespace | path]))> set
+        else
+          <iset-add(|ReadWildcard([namespace | path], prefix))> set
+        end
+      end
+  
+  /** @internal */    
+  index-is-unresolved(|x, uri) = 
+    Index-UnresolvedSet; (iset-contains(|(x, uri)) <+ fail)
+  /** @internal */
+  index-add-unresolved(|x, uri) = 
+    (Index-UnresolvedSet; iset-add(|(x, uri))) <+ id
+  
+  /** @internal */
+  index-file-dependent-construct: 
+    uri -> <conc> (uses, reads)
+    with
+      uses := <index-get-uses-all> Def(uri);
+      reads := <index-get-reads-all> Def(uri)
+  
+  /** @internal */  
+  index-file-dependency-filter = 
+    ?Read(_) <+ ?ReadWildcard(_, _) <+ ?Use(_)
+ 
+  /** @internal */
+  do-adjust-index-lookup(|namespace, path, use, prefix) =
+    repeat-until(
+      prim("SSL_EXT_get_parent", <id>)
+    , adjust-index-lookup(origin-equal(|use) |namespace, path, prefix) 
+    )
+ 
+  /** @internal */
+  index-select(|namespace, path, use) =
+    getfirst(
+      where(
+        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
+      )
+    )
+ 
+  /** @internal */
+  index-select-all(|namespace, path, use) =
+    filter(
+      where(
+        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
+      )
+    )
+ 
+  /** @internal */
+  do-adjusted-index-path(|namespace, path, def) =
+    adjust-index-path(origin-equal(|def) |namespace, path)
+  <+
+    ![def | path]
+ 
+  /** @internal */
+  index-eq(|namespace, expected) =
+    where(
+      ?Def([_, name | _]);
+      <SRTS-EXT-eq-ignore-annos(|expected)> name
+    )
+  
+  /** @internal */
+  external SRTS-EXT-eq-ignore-annos(|t)
+  
+  /** @internal */
+  index-key-unwrap = 
+    \key{uri} -> key{<index-uri-unwrap> uri}\ <+ id
+    
+/** @internal */
+rules // Interface for generated code
+ 
+  /** @internal */
+  nam-get-def(|namespace):
+    x -> Def([namespace, x | <IndexPath <+ ![]> namespace])
+  
+  /** @internal */ 
+  nam-annotate-use(|namespace):
+    t -> t{[Unresolved(namespace), t | <IndexPath <+ ![]> namespace]}
+  
+  /** @internal */ 
+  nam-get-scope-types = fail
+  /** @internal */
+  nam-get-definition = fail
+  /** @internal */
+  nam-get-definition-key = fail
+  /** @internal */
+  nam-annotate-names(|def-path) = fail
diff --git a/javasources/K3Disamb/lib/analysis-library.generated.str b/javasources/K3Disamb/lib/analysis-library.generated.str
new file mode 100644
index 0000000..0aa6344
--- /dev/null
+++ b/javasources/K3Disamb/lib/analysis-library.generated.str
@@ -0,0 +1,564 @@
+module lib/analysis-library.generated
+ 
+imports
+  libstratego-lib
+  libstratego-parallel
+  lib/editor-common.generated
+  lib/analysis-library-internal.generated
+  lib/index-library.generated
+ 
+signature constructors
+ 
+  // Analyze constructors
+  Editor      : AnalysisPhase
+  Compile     : AnalysisPhase
+ 
+  // Index elements
+  Def          : List(UriPart) -> Summary
+  Use          : List(UriPart) -> Summary
+  BadUse       : List(UriPart) -> Summary
+  Read         : List(UriPart) -> Summary
+  ReadWildcard : List(UriPart) * String -> Summary
+  Diff         : List(UriPart) * List(Summary) -> Summary
+  
+  // Adjust lookup actions
+  StopLookup   : LookupAction
+  
+rules // Index analysis extension points
+ 
+  /**
+   * Extension point. Override this rule to adjust how the index analysis looks up use sites to definitions.
+   *
+   * The overriden rule must return a list that contains any of the following items:
+   *   - Def(uri)         : A definition with exactly this URI has been found. This tells the lookup to resolve the
+   *                        use site to this definition.
+   *   - [namespace|path] : This tells the lookup to do a new lookup at the given namespace and path.
+   * 
+   * Returning multiple of these in the list is allowed, these will all show up during content completion and possibly
+   * other custom strategies. If multiple items are returned during reference resolving for example, the first item
+   * will be used.
+   *
+   * If the lookup has failed, for example your custom rule cannot find any definitions, you can also return 
+   * StopLookup() instead of a list. This tells the lookup algorithm to stop any further lookups for this use site.
+   * This can be useful to stop lookups for recursive expressions like property access, preventing a lot of useless
+   * lookups that will always fail anyway.
+   *
+   * Extension example:
+   *   adjust-index-lookup(check-target-name|namespace, path, prefix):
+   *     PropAccess(exp, name) -> properties
+   *     where
+   *       <check-target-name> name
+   *     with
+   *       if TYPE(type{_}) := <type-of> exp then
+   *         properties := <index-lookup-children(|Property(), prefix)> type
+   *       else
+   *         properties := StopLookup()
+   *       end
+   *
+   *   adjust-index-lookup(check-target-name|namespace, path, prefix):
+   *     Var(name) -> [[Var() | path], [Property() | path]]
+   *     where
+   *       <check-target-name> name
+   *
+   * @param check-target-name   A strategy that should be used to check if the name of the current element is what the
+   *                            lookup algorithm is looking for.
+   * @param namespace           The namespace of the element that should be looked up.
+   * @param path                The path the lookup algorithm is currently looking at for the element.
+   * @param prefix              The prefix name of the element the lookup algorithm is looking for. This is usually the
+   *                            full name of the element, but could be a partial prefix during content completion.
+   * @type def -> List(Def(uri) or [namespace|path]) or StopLookup()
+   */
+  adjust-index-lookup(check-target-name|namespace, path, prefix) = fail
+  
+  /** 
+   * Extension point. Override this rule to store data about definitions in the index. Should call <store-results> on 
+   * a (list of) data that must be stored in the index.
+   *
+   * Note that store-results always fails, this is a trick to make every adjust-index-def-data override always fail so 
+   * that every overriden rule is called once for each definition. This can lead to unexpected behaviour when trying to 
+   * store multiple items by calling store-results in a map or filter! Be sure to always let your adjust-index-def-data 
+   * rule fail if you are doing a <filter(store-results)> for example.
+   *
+   * Extension example:
+   *   adjust-index-def-data(store-results|namespace, path):
+   *     def -> <store-results> Type([namespace|path], type)
+   *     where
+   *       type := <type-of> def
+   *
+   * @param store-results Call this on the data you want to store in the index.
+   * @param namespace     The namespace of the definition that the rule is being called on.
+   * @param path          The path of the definition that the rule is being called on.
+   * @type def -> fail 
+   */
+  adjust-index-def-data(store-results|namespace, path) = fail
+  
+  /**
+   * Extension point. Override this rule to adjust how the index assigns a namespace and path (URI) to definitions and
+   * use sites. Should return a path that will be assigned to the definition or use site.
+   *
+   * Extension example:
+   *   adjust-index-path(check-target-definition|namespace, path):
+   *     Start(_, _) -> [<string-replace(|<project-path>, "")> <Fst> <index-get-current-file>]
+   *
+   *
+   * @param check-target-definition 
+   * @param namespace               The namespace that would be given to the current definition or use site.
+   * @param path                    The path that would be given to the current definition or use site.
+   * @type def -> uri@[namespace|path]
+   */
+  adjust-index-path(check-target-definition|namespace, path) = fail
+  
+  /**
+   * Extension point. Override this rule to define index-stored constructors to check for difference during analysis.
+   * The index-diff-compare extension point is used to do the actual comparison. Defaults to Def constructs.
+   *
+   * Extension example:
+   *   index-diff-constructors = ?Type(_, _)
+   *
+   * @type a -> ?a
+   *
+   * @see index-diff-compare
+   */
+  index-diff-constructors = 
+    ?Def(_)
+  
+  /**
+   * Extension point. Override this rule to define a custom comparison of two index elements. It should fail if they 
+   * are not equal and return the indentity if they are equal. Only constructors defined by index-diff-constructors are
+   * compared.
+   *
+   * Extension example:
+   *   index-diff-compare:
+   *     (Type(u1, v1), Type(u2, v2)) -> <id>
+   *     where
+   *       <index-uri-eq> (u1, u2);
+   *       <eq> (v1, v2)
+   *
+   * @type (a, b) -> ?(a, b)
+   *
+   * @see index-diff-constructors
+   */
+  index-diff-compare:
+    (Def(u1), Def(u2)) -> <id>
+    where
+       <index-uri-eq> (u1, u2)
+ 
+rules // Analysis traversals
+  
+  /**
+   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
+   * Defaults to Editor() phase.
+   *
+   * @param language  The name of the language that is being analysed.
+   *
+   * @type (ast, path, project-path) -> (ast', List(fileToAnalyze@(file, subfile)))
+   *
+   * @see analyze-top(|phase, language)
+   */
+  analyze-top(|language):
+    (ast, path, project-path) -> <analyze-top(|Editor(), language, path, project-path)> ast
+   
+  /**
+   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
+   *
+   * @param phase         The type of analysis phase. There are 2 phases to choose from:
+   *                      - Editor():   File dependencies are analysed.
+   *                      - Compile():  File dependencies are not analysed.
+   * @param language      The name of the language that is being analysed.
+   * @param path          The path of the file to analyze relative to project-path.
+   * @param project-path  The path of the directory that contains all the source files.
+   * @type ast -> (ast', List(fileToAnalyze@(file, subfile)))
+   *
+   * @see analyze-top-internal(|phase, language, project-path, full-path)
+   */
+  analyze-top(|phase, language, path, project-path):
+    ast -> (ast', filesToAnalyze)
+    with
+      full-path := $[[project-path]/[path]];
+      if index-split then
+        index-setup(|language, [project-path], full-path); // Set up the index, splitting may require index calls.
+        asts := <index-toplevel-split> ast;
+        astsFilePairs := <map(ast-uri-to-ast-file(|full-path))> asts;
+        Results(ast', _, _, _, _, _, filesToAnalyze) := 
+          <analyze-top-internal(|phase, language, project-path, full-path)> astsFilePairs
+      else
+        Results(asts, _, _, _, _, _, filesToAnalyze) := 
+          <analyze-top-internal(|phase, language, project-path, full-path)> [(ast, full-path)];
+        ast' := <Hd> asts
+      end
+  
+rules // Parallel analysis
+  
+  /**
+   * Does a parallel analysis of given files using the specified analysis strategy. Automatically does parallel
+   * analysis of dependent files that have changed during the analysis.
+   *
+   * Example:
+   *   <index-parallel-analyze-files(analyze)> ["text/file1.ext", "text/file2.ext"]
+   *
+   * @param analyze (ast, path, project-path) -> (ast', errors, warnings, notes, filesToAnalyze). Strategy that 
+   *                analyzes a file using the index. Gets a (ast, path, project-path) tuple as input and must return 
+   *                a (ast', errors, warnings, notes, filesToAnalyze) tuple as output.
+   * @type List((file, subfile) or file) -> None()
+   */
+  index-parallel-analyze-files(analyze):
+    files -> None()
+    with
+      length; 
+      set-total-work-units
+    with
+      index-parallel-analyze(analyze);
+      filter(not(?ParallelResults((), (), _, _, _, _) <+ ?ParallelResults((), [()], _, _, _, _)); index-set-markers)
+ 
+rules // Query primitives
+ 
+  /**
+   * Gets all DefData entries that match the kind of data and URI in given definition.
+   *
+   * Example:
+   *   <index-get-data(|Type())> Def([Entity(), "Bar"]) => [DefData([Entity(), "Bar"], Type(), TYPE("Bar")), ...]
+   *
+   * @param kind Only data of this kind is returned.
+   * @type Def(uri) -> List(DefData(uri, kind, value))
+   */
+  index-get-data(|kind):
+    <with(?Def(uri) | "Def expected")> -> <index-get-value> DefData(uri, kind, ())
+      
+  /**
+   * Gets all data entries that match the kind of data and URI in given definition.
+   *
+   * Example:
+   *   <index-get-data-all(|Type())> Def([Entity(), "Bar"]) => [TYPE("Bar"), ...]
+   *
+   * @param kind Only data of this kind is returned.
+   * @type Def(uri) -> List(value)
+   */
+  index-get-data-all(|kind):
+    <with(?Def(uri) | "Def expected")> -> <index-get-all-values> DefData(uri, kind, ())
+     
+  /**
+   * Gets all Use entries that match the URI in given definition.
+   *
+   * Example:
+   *   <index-get-uses-all> Def([Entity(), "M", "Bar"]) => [Use([Entity(), "M", "Bar"]), ...]
+   *
+   * @type Def(uri) -> List(Use(uri))
+   */
+  index-get-uses-all:
+    <with(?Def(uri) | "Def expected")> -> <index-get-all> Use(uri)
+     
+  /**
+   * Gets all Read or ReadWildcard entries that match the given template.
+   *
+   * Example:
+   *   <index-get-reads-all> [Property(), "Bar", "p"] => [Read([Property(), "Bar", "p"]), ...]
+   *
+   * @type Def(uri) -> List(Read(uri) or ReadWildcard(uri, prefix))
+   */
+  index-get-reads-all:
+    template -> <conc> (reads, readwildcards')
+    where
+      uri   := <index-uri> template;
+      reads := <index-get-all> Read(uri);
+      if !uri => [namespace, prefix | path-parent] then
+        readwildcards  := <index-get-all> ReadWildcard([namespace | path-parent], ());
+        readwildcards' := <filter(index-readwildcard-substring(|prefix))> readwildcards
+      else
+        readwildcards' := []
+      end
+ 
+  /**
+   * Get all index entries that match the given template.
+   *
+   * Example:
+   *   <index-get-all> Def([Entity(), "Bar"]) => [Def([Entity(), "Bar"]), ...]
+   *
+   * @type template -> List(elem)
+   */
+  index-get-all:
+    template -> <indexlib-get-all> template
+      with
+       if set := <Index-ReadSet> then
+         uri := <index-uri>;
+         <iset-add(|Read(uri))> set
+       end
+       
+  /**
+   * Get all values of index entries that match the given template.
+   *
+   * Example:
+   *   <index-get-all-values> DefData([Property(), "s"], Type(), ()) => [TYPE("String"), ...]
+   *
+   * @type template -> List(value)
+   *
+   * @see index-value
+   */
+  index-get-all-values:
+    template -> <map(index-value)> <index-get-all> template
+       
+  /**
+   * Get the first index entry that matches the given template, or fail.
+   *
+   * Example:
+   *   <index-get> Def([Entity(), "Bar"]) => Def([Entity(), "Bar"])
+   *
+   * @type template -> ?elem
+   */
+  index-get:
+    template -> <?[<id>|_]> <index-get-all> template
+      
+  /**
+   * Get the value of first index entry that matches the given template, or fail.
+   *
+   * Example:
+   *   <index-get-value> DefData([Entity(), "Bar"], Type(), ()) => TYPE("Bar")
+   *
+   * @type template -> ?value
+   *
+   * @see index-value
+   */
+  index-get-value:
+    template -> <index-value> <?[<id>|_]> <index-get-all> template
+
+  /**
+   * Gets all Def children elements of an URI in a certain namespace.
+   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
+   *
+   * Example:
+   *   <index-get-children(|Field())> Def([Entity(), "Baz"]) => [Def([Field(), "Bar"]), Def([Field(), "Foo"]), ...]
+   *   <index-get-children(|Field())> "Foo"{[Entity(), "Baz"]} => [Def([Field(), "Bar"]), Def([Field(), "Foo"]), ...]
+   *   <index-get-children(|Field())> [Entity(), "Baz"] => [Def([Field(), "Bar"]), Def([Field(), "Foo"]), ...]
+   *
+   * @param namespace Only child Def elements in this namespace are returned.
+   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   */
+  index-get-children(|namespace) = 
+    index-get-children(\uri -> Def(uri)\|namespace)
+  
+  /**
+   * Gets all children elements of an URI in a certain namespace using custom templates.
+   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
+   *
+   * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
+   * @param namespace           Only child elements in this namespace are returned.
+   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   */
+  index-get-children(construct-template|namespace):
+    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children
+    with
+      template  := <construct-template> [namespace | path];
+      children  := <prim("LANG_index_get_children", template)>;
+      <store-wildcard-read(|namespace, path, "")> children
+
+  /**
+   * Gets all Def children elements of an URI in a certain namespace where the name starts with a prefix.
+   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
+   *
+   * Example:
+   *   <index-get-children(|Field(), "fo")> Def([Entity(), "Baz"]) => [Def([Field(), "Foo"]), ...]
+   *   <index-get-children(|Field(), "ba")> "Foo"{[Entity(), "Baz"]} => [Def([Field(), "Bar"]), ...]
+   *   <index-get-children(|Field(), "ze")> [Entity(), "Baz"] => [...]
+   *
+   * @param namespace Only child Def elements in this namespace are returned.
+   * @param prefix    Only child Def elements where the name starts with this prefix are returned.
+   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   */
+  index-get-children(|namespace, prefix) = 
+    index-get-children(\uri -> Def(uri)\|namespace, prefix)
+  
+  /**
+   * Gets all children elements of an URI in a certain namespace where the name starts with a prefix
+   * using custom templates.
+   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
+   *
+   * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
+   * @param namespace           Only child elements in this namespace are returned.
+   * @param prefix              Only child elements where the name starts with this prefix are returned.
+   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   */
+  index-get-children(construct-template|namespace, prefix):
+    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children'
+    with
+      prefix'   := <strip-annos> prefix;
+      template  := <construct-template> [namespace | path];
+      children  := <prim("LANG_index_get_children", template)>;
+      children' := <filter(index-is-name-substring(|prefix'))> children;
+      <store-wildcard-read(|namespace, path, prefix')> children'
+
+  /**
+   * Gets a set of all files that have a reference to the given index entries.
+   *
+   * Example:
+   *   <index-get-referenced-files(\uri -> [Read(uri), Use(uri, [])]\)> [Def([Entity(), "Bar"]), ...] => 
+   *     [("fullpath/otherfile.ext", "subfile"), ...]
+   *
+   * @param construct-from-uri  uri -> List(elements). Construction strategy that creates a list of reference 
+   *                            constructs from all given entries, such as \uri -> [Read(uri), Use(uri, [])]\
+   * @type List(elem) -> List((file, subfile))
+   */
+  index-get-referenced-files(construct-from-uri):
+    entries -> files
+    where
+      uris        := <filter(index-uri)> entries;
+      referenced  := <concat> <filter(construct-from-uri)> uris;
+      files       := <iset-elements> <iset-addlist(|<mapconcat(index-get-files-of)> referenced)> <new-iset>
+ 
+  /**
+   * Convenience function for finding files with Read and Use dependencies to the given definitions.
+   *
+   * Example:
+   *   <index-get-dependent-files> [Def([Entity(), "Bar"]), ...] => [("fullpath/otherfile.ext", "subfile"), ...]
+   *
+   * @type List(elem) -> List((file, subfile))
+   *
+   * @see index-get-referenced-files(construct-from-uri)
+   * @see index-file-dependent-construct
+   */
+  index-get-dependent-files = 
+    index-get-referenced-files(index-file-dependent-construct)
+     
+rules // Index lookup rules (that take into account adjust-index-lookup)
+ 
+  /**
+   * Given an annotated AST node, resolves it, returning its Def.
+   *
+   * @type "name"{uri} -> ?Def(uri')
+   */
+  index-lookup:
+    x{[namespace|path]} -> <index-lookup(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
+ 
+  /**
+   * Given an annotated AST node, resolves it, returning all its Defs.
+   * 
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-all:
+    x{[namespace|path]} -> <index-lookup-all(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
+ 
+  /**
+   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
+   *
+   * @param prefix  Only Defs with a name that starts with this string are returned.
+   * @type "name"{uri} -> ?Def(uri')
+   */
+  index-lookup-outermost(|prefix):
+    x{[namespace|path]} -> <index-lookup-outermost(id|<index-namespace-unwrap> namespace, path, prefix)>
+ 
+  /**
+   * Given an annotated AST node, returns Defs that have the same parent URI.
+   *
+   * @param prefix  Only Defs with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-one-level(|prefix):
+    x{[namespace|path]} -> <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
+      
+  /**
+   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   *
+   * @param namespace Only Defs with this namespace are returned.
+   * @param prefix    Only Defs with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-all-levels(|prefix):
+    x{[namespace|path]} -> <index-lookup-all-levels(id|<index-namespace-unwrap> namespace, path, prefix)>
+ 
+  /**
+   * Given an annotated AST node, resolves it, and returns all child Defs of its definition.
+   *
+   * @param namespace Only child Defs with this namespace are returned.
+   * @param prefix    Only Defs with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-children(|namespace, prefix): // TODO: how does this compare w/ index-lookup-one-level?
+    x{[ns | path]} -> defs
+    with
+      if !ns => Unresolved(_) then
+        Def([_ | def-path]) := <index-lookup>;
+        defs := <index-lookup-one-level(id|namespace, def-path, prefix)> x
+      else
+        defs := <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
+      end
+    <+
+      defs := []
+      
+rules // Index utilities
+  
+  /**
+   * Gets the namespace part of the URI for given key (term{uri} element).
+   *
+   * Example:
+   *   <index-uri-namespace> "Bar"{[Entity(), "Bar", "Baz"]} => Entity()
+   *
+   * @type "name"{uri@[namespace|path]} -> namespace
+   */
+  index-uri-namespace:
+    x{[namespace|path]} -> <index-namespace-unwrap> namespace
+
+  /**
+   * Gets the path part of the URI for given key (term{uri} element). Resolves it if unresolved.
+   *
+   * Example:
+   *   <index-uri-path> "Bar"{[Entity(), "Bar", "Baz"]} => ["Bar", "Baz"]
+   *
+   * @type "name"{uri@[namespace|path]} -> path'
+   */
+  index-uri-path:
+    x{[namespace|path]} -> path'
+    where
+      if !namespace => Unresolved(namespace) then
+        Def(path') := <index-lookup>
+      else
+        path' := path
+      end
+      
+  /**
+   * Gets the name part of the URI for given key (term{uri} element).
+   *
+   * Example:
+   *   <index-uri-name> "Bar"{[Entity(), "Bar", "Baz"] => "Bar"
+   *
+   * @type "name"{uri@[namespace|[name|restPath]]} -> name
+   */ 
+  index-uri-name:
+    x{[_|[name|_]]} -> name
+    
+  /**
+   * Tries to get the name part of the URI for given term or fail if given term does not have an URI or name.
+   *
+   * Example:
+   *   <index-uri-name> Def([Entity(), "Bar", "Baz"]) => "Bar"
+   *   <index-uri-name> Type("Foo") => fail
+   *   <index-uri-name> Read([Entity()]) => fail
+   *
+   * @type x -> name
+   */   
+  index-uri-name:
+    x -> <index-uri-name> <index-uri> x
+    where
+      not(<has-annos> x)
+    
+  /**
+   * Determines if a given AST node is a definition site, according to the syntax.
+   *
+   * FIXME: Also succeeds on use sites.
+   *
+   * @type def -> ?def
+   */
+  index-is-definition =
+    where(nam-get-definition-key)
+    
+  /**
+   * Checks if given keys (term{uri} elements) are equal. Discards unresolved URI's.
+   *
+   * Example:
+   *   <index-key-eq> ("Bar"{[Entity(), "Bar"]}, "Bar"{[Unresolved(Entity()), "Bar"]}) => 
+   *     ("Bar"{[Entity(), "Bar"]}, "Bar"{[Unresolved(Entity()), "Bar"]})
+   *   <index-key-eq> ("Foo"{[Entity(), "Foo"]}, "Bar"{[Entity(), "Bar"]}) => fail
+   *
+   * @type (k1, k2) -> ?(k1, k2)
+   */      
+  index-key-eq:
+    (k1, k2) -> <id>
+    where
+      <eq> (<index-key-unwrap> k1, <index-key-unwrap> k2)
diff --git a/javasources/K3Disamb/lib/compilation-library.generated.str b/javasources/K3Disamb/lib/compilation-library.generated.str
new file mode 100644
index 0000000..fa49228
--- /dev/null
+++ b/javasources/K3Disamb/lib/compilation-library.generated.str
@@ -0,0 +1,188 @@
+module lib/compilation-library.generated
+
+imports
+  libstratego-lib
+  lib/editor-common.generated
+  lib/index-library.generated
+  lib/analysis-library.generated
+  lib/analysis-library-internal.generated
+  
+rules // Extension points
+  
+  /**
+   * Extension point. Override this rule to define a desugaring that is applied to AST before analyzing and compiling.
+   *
+   * Extension example:
+   *   index-desugar-ast:
+   *     ast -> <desugar> ast
+   *
+   * @type ast -> ast'
+   */
+  index-desugar-ast = fail
+    
+  /**
+   * Extension point. Override this rule to define a compilation or transformation to some other target language. The
+   * index manages which files have to be compiled and calls this rule for each AST that has changed since the last
+   * compilation.
+   *
+   * Extensions example:
+   *   index-compile-ast(|file, subfile):
+   *     ast -> None()
+   *     with
+   *       java := <to-java> ast;
+   *       full-path := <dirname> file;
+   *       filename := <guarantee-extension(|"java")> <base-filename> file;
+   *       writePath := $[[full-path]/java/];
+   *       writeFile :=  $[[writePath][filename]];
+   *       try(<mkdir> writePath);
+   *       <fclose> <fputs> (java, <fopen> (writeFile, "w"))
+   *
+   * @param file    The file that must be compiled.
+   * @param subfile The subfile that must be compiled ("" if there is no subfile).
+   * @type ast -> None()
+   */
+  index-compile-ast(|file, subfile) = fail
+  
+rules // Compilation
+  
+  /**
+   * Schedules compilation in the background of all files that have changed since the last compilation.
+   *
+   * @type x -> x
+   */
+  index-schedule-compilation:
+    _ -> None()
+    with
+      queue-strategy(|"index-compilation", "Compiling files")
+  
+  /** @internal */
+  index-compilation:
+    language -> None()
+    with
+      // Init
+      project-path := <project-path>;
+      index-setup(|language, [project-path], ".")
+    with
+      // Determine the files to compile by looking at changed files
+      diffs         := <analyze-get-compilediffs>;
+      files         := <map(index-compilation-restore-read-file)> diffs;
+      filteredFiles := <make-set> <remove-all(index-compilation-filter-file)> files;
+      
+      // Clean compile time reads
+      <filter(index-compilation-clean-reads)> filteredFiles;
+      
+      // Set total work units to number of files to compile for visual indication
+      <set-total-work-units> <length> filteredFiles;
+      
+      // Compile the files
+      <filter(index-compilation-file(|language, project-path); complete-work-unit)> filteredFiles
+
+  /** @internal */
+  index-compilation-file(|language, project-path):
+    (path, subfile) -> None()
+    with
+      ast := <index-get-global(|<conc> (<index-file-to-uri> (path, subfile), ["ast"]))>;
+      {| Index-ReadSet:
+        readSet := <new-iset>;
+        rules(Index-ReadSet: _ -> readSet);
+        
+        // Compile file
+        <try(index-compile-ast(|path, subfile))> ast;
+        
+        // Store compile-time reads.
+        reads := <iset-elements> readSet;
+        <index-add-all(|<index-compilation-file-tuple> (path, subfile))> reads
+      |}
+
+  /** @internal */
+  index-compilation-filter-file:
+    (file, subfile) -> (file, subfile)
+    where
+      <is-test-file <+ index-is-fake-file <+ not(file-exists)> file
+    
+rules // On save handling
+  
+  /**
+   * Commits the index to disk and schedules compilation. Use trigger-commit-and-compile instead of this strategy.
+   *
+   * @see trigger-commit-and-compile
+   *
+   * @internal
+   */
+  commit-and-compile:
+    language -> None()
+    with
+      index-commit
+    with
+      index-schedule-compilation
+
+  /**
+   * Triggers commit and compilation, requires target language as current term.
+   * Compilation can be delayed by using disable-commit-and-compile. Compilation will be triggered when 
+   * enable-commit-and-compile is called.
+   *
+   * @type language -> language
+   *
+   * @see enable-commit-and-compile
+   * @see disable-commit-and-compile
+   */
+  trigger-commit-and-compile:
+    language -> <id>
+    with
+      if not(index-is-global-enabled(|"delay-compile")) then
+        commit-and-compile
+      else
+        index-enable-global(|"trigger-compile")
+      end
+  
+  /**
+   * Delays commit and compilation until enable-commit-and-compile is called.
+   *
+   * @type x -> x
+   *
+   * @see enable-commit-and-compile
+   */
+  disable-commit-and-compile = 
+    index-enable-global(|"delay-compile")
+  
+  /**
+   * Cancels the commit and compilation delay, requires target language as current term. 
+   * If commit and compilation was triggered during the delay, it is triggered now.
+   *
+   * @type language -> language
+   *
+   * @see disable-commit-and-compile
+   */
+  enable-commit-and-compile:
+    language -> <id>
+    with
+      if index-is-global-enabled(|"trigger-compile") then
+        commit-and-compile
+      end;
+      index-disable-global(|"delay-compile")
+      
+/** @internal */
+rules // Compile time reads
+
+  /** @internal */
+  index-compilation-restore-read-file:
+    (file, subfile) -> (file', subfile)
+    where
+      file' := <string-replace(|<index-compilation-read-path>, "")> file
+  /** @internal */
+  index-compilation-restore-read-file:
+    (file, subfile) -> (file, subfile)
+    where
+      not(<string-replace(|<index-compilation-read-path>, "")> file)
+      
+  /** @internal */
+  index-compilation-clean-reads = 
+    ?(file, subfile); index-compilation-file-tuple; index-clear-file
+      
+  /** @internal */
+  index-compilation-file-tuple:
+    (file, subfile) -> ($[[<index-compilation-read-path>]/[file]], subfile)
+    
+  /** @internal */
+  index-compilation-read-path =
+    !"/.internal/reads/compile"
diff --git a/javasources/K3Disamb/lib/editor-common.generated.str b/javasources/K3Disamb/lib/editor-common.generated.str
index 29985a5..a5be421 100644
--- a/javasources/K3Disamb/lib/editor-common.generated.str
+++ b/javasources/K3Disamb/lib/editor-common.generated.str
@@ -34,0 +35,2 @@
+    
+  language = !"K3Disamb"
@@ -228,0 +231,3 @@
+  
+  Type     : Namespace
+  Property : Namespace
diff --git a/javasources/K3Disamb/lib/index-library.generated.str b/javasources/K3Disamb/lib/index-library.generated.str
index 99eb4fe..34af862 100644
--- a/javasources/K3Disamb/lib/index-library.generated.str
+++ b/javasources/K3Disamb/lib/index-library.generated.str
@@ -24,0 +25,8 @@
+  // Globals
+  Global : Namespace
+  Global : List(UriPart) -> Summary
+  Global : List(UriPart) * List(Summary) -> Summary
+  
+  // None namespace
+  None   : Namespace
+  
@@ -26,0 +35,10 @@
+  /**
+   * Sets up the index library for given language and project paths.
+   * Must be called once before doing anything with the library.
+   *
+   * @param language      The language to set the index up for.
+   * @param project-path  The project paths that contain all source files to analyse and compile.
+   *
+   * @obsolete
+   * @type x -> x
+   */
@@ -32 +50 @@
-   * Sets up the index library for given language and project paths.
+   * Sets up the index library for given language, project paths and current file.
@@ -33,0 +52,9 @@
+   *
+   * Example:
+   *   <index-setup(|"MiniJava", [<project-path>], "test/test.mjv")
+   *
+   * @param language      The language to set the index up for.
+   * @param project-path  The project paths that contain all source files to analyse and compile.
+   * @param current-file  The current file that is being analysed. Can be retrieved later using index-get-current-file.
+   *                      Can also be changed later using index-set-current-file.
+   * @type x -> x
@@ -36,0 +64,25 @@
+    
+  /**
+   * Sets the current file the index (analysis) is operating on to the given file.
+   *
+   * Example:
+   *   <index-set-current-file> "fullpath/file.ext"
+   *   <index-set-current-file> ("fullpath/file.ext", "subfile")
+   *
+   * @type x -> ?x
+   */
+  index-set-current-file = 
+    prim("LANG_index_set_current_file", <id>)
+
+  /**
+   * Adds given element to the index with given file path and optionally subfile.
+   *
+   * Example:
+   *   <index-add(|"fullpath/file.ext")> Def([Entity(), "Bar"])
+   *   <index-add(|("fullpath/file.ext", "subfile"))> Def([Entity(), "Bar"])
+   *
+   * @param file  The file (and subfile) to add the element to.
+   * @type x -> ?x
+   */
+  index-add(|file) =
+    prim("LANG_index_add", <id>, file)
@@ -43,0 +96,3 @@
+   *
+   * @param file  The file (and subfile) to add the elements to.
+   * @type List(x) -> ?List(x)
@@ -46 +101,14 @@
-    list-loop(with(prim("LANG_index_add", <id>, file)))
+    list-loop(with(index-add(|file)))
+    
+  /**
+   * Removes given element from the index that is contained in given file path and optionally subfile.
+   *
+   * Example:
+   *   <index-remove(|"fullpath/file.ext")> Def([Entity(), "Bar"])
+   *   <index-remove(|("fullpath/file.ext", "subfile"))> Def([Entity(), "Bar"])
+   * 
+   * @param file  The file (and subfile) to remove the element from.
+   * @type x -> ?x
+   */
+  index-remove(|file) =
+    prim("LANG_index_remove", <id>, file)
@@ -53,0 +122,3 @@
+   *
+   * @param file  The file (and subfile) to remove the elements from.
+   * @type List(x) -> ?List(x)
@@ -55,2 +126,2 @@
-  index-remove-all(|files) =
-    list-loop(with(prim("LANG_index_remove", <id>, files)))
+  index-remove-all(|file) =
+    list-loop(with(index-remove(|file)))
@@ -63,0 +135,2 @@
+   *
+   * @type x -> ?x
@@ -69,0 +143,2 @@
+   *
+   * @type x -> x
@@ -75,0 +151,2 @@
+   *
+   * @type x -> x
@@ -78,4 +155,10 @@
-    if not(index-timestamp-get-updates(|"LANG_index_commit") => []) then
-      prim("LANG_index_commit");
-      index-timestamp-set-updated(|"LANG_index_commit")
-    end
+    prim("LANG_index_commit")
+
+  /**
+   * Starts a transaction on the index for the current file. Additions to the index are not visible to other files 
+   * until index-end-transaction is called. Operations on the index are only thread safe during a transaction.
+   *
+   * @type x -> x
+   */
+  index-start-transaction = 
+    prim("LANG_index_start_transaction")
@@ -83 +166,24 @@
-rules // Index API
+  /**
+   * Ends a transaction on the index for the current file. Additions made to the index during the transaction are
+   * added to the global index visible for other files. Operations on the index are not thread safe any more after 
+   * this call.
+   *
+   * @type x -> x
+   */
+  index-end-transaction = 
+    prim("LANG_index_end_transaction")
+  
+  /**
+   * Starts a transaction, applies given strategy and ends the transaction. All index operations used from the given
+   * strategy are thread safe.
+   * 
+   * @param s The strategy to apply. Transaction will still properly end if strategy fails.
+   * @type x -> x'
+   *
+   * @see index-start-transaction
+   * @see index-end-transaction
+   */
+  index-transaction(s) = 
+    prim("LANG_index_start_transaction"); try(s); prim("LANG_index_end_transaction")
+  
+rules // Index querying
@@ -86,0 +193,5 @@
+   *
+   * @type x -> (file, subfile)
+   *
+   * @see index-setup(|language, project-paths, current-file)
+   * @see index-set-current-file
@@ -92 +203 @@
-   * Gets a list of all files and subfile for current project.
+   * Gets a list of all files and subfiles for current project.
@@ -95 +206,3 @@
-   *   <index-get-all-files> => ["fullpath/file.ext", ...]
+   *   <index-get-all-files> => [("fullpath/file.ext", "subfile"), ...]
+   *
+   * @type x -> List((file, subfile))
@@ -105,0 +219,2 @@
+   *
+   * @type file or (file, subfile) -> List(elem)
@@ -113 +228 @@
-   * Gets all index entries for the given file path and optionally subfile.
+   * Gets index entries in some namespace for the given file path and optionally subfile.
@@ -116,0 +232,4 @@
+   *   <index-get-all-in-file(|Import())> ("fullpath/file.ext", "subfile") => [Def([Import(), "Bar"]), ...]
+   *
+   * @param namespace Only index entries from this namespace are retrieved.
+   * @type file or (file, subfile) -> List(elem)
@@ -125,0 +245,12 @@
+   * Gets the revision of a file and optionally subfile.
+   *
+   * Example:
+   *   <index-get-file-revision> "fullpath/file.ext" => 13
+   *   <index-get-file-revision> ("fullpath/file.ext", "subfile") => 37
+   *
+   * @type file or (file, subfile) -> Int
+   */
+  index-get-file-revision:
+    file -> <prim("LANG_index_get_file_revision", file)>
+    
+  /**
@@ -129,0 +261,2 @@
+   *
+   * @type template -> List((file, subfile))
@@ -133,10 +265,0 @@
-    
-  /**
-   * Gets all index entries (of every file for current project).
-   *
-   * Example:
-   *   <indexlib-get-all-elements> => [Def([Entity(), "Bar"]), ...]
-   */
-  indexlib-get-all-elements =
-    // TODO: is there a use case for this? doing this is *expensive*
-    <mapconcat(index-get-all-in-file)> <index-get-all-files>
@@ -148,0 +272,2 @@
+   *
+   * @type template -> List(elem)
@@ -156,2 +280,0 @@
-   * @see index-value
-   *
@@ -159,0 +283,4 @@
+   *
+   * @type template -> List(value)
+   *
+   * @see index-value
@@ -168,0 +296,2 @@
+   *
+   * @type template -> ?elem
@@ -176,2 +304,0 @@
-   * @see index-value
-   *
@@ -179,0 +307,4 @@
+   *
+   * @type template -> ?value
+   *
+   * @see index-value
@@ -183,25 +314,2 @@
- 
-  /**
-   * Updates the "last updated" timestamp for the given service name.
-   *
-   * @see index-get-changes-since-timestamp(|service)
-   */
-  index-timestamp-set-updated(|service) =
-    file := $[/.internal/timestamps/[service]];
-    <index-clear-file> file;
-    prim("LANG_index_add", DefData([Timestamp(), "timestamps", ".internal"], Timestamp(), []), file)
-   
-  /**
-   * Gets all files with changes since the last time stamp update for the given service name.
-   */
-  index-timestamp-get-updates(|service):
-    _ -> files'
-    with
-      timestampName := $[/.internal/timestamps/[service]];
-      files := <prim("LANG_index_get_files_newer_than", timestampName)>;
-      files' := <remove-all(?(timestampName, _))> files
-
-  /**
-   * Queries if given index file is a 'fake' file for storing internal data.
-   */
-  index-is-fake-file = string-starts-with(|"/.internal")
+    
+rules // Index globals
@@ -210 +318,46 @@
-   * Gets the URI part for given term.
+   * Gets the 'fake' path where globals are stored in the index.
+   *
+   * @internal
+   */
+  index-globals-path = 
+    !"/.internal/globals"
+    
+  /**
+   * Gets the URI where globals are stored in the index for given name or names.
+   *
+   * @internal
+   * @type name or List(name) -> uri
+   */
+  index-globals-uri:
+    names -> uri
+    with
+      if is-list then
+        uri := <concat> [[Global()], names, ["globals", ".internal"]]
+      else
+        uri := [Global(), names, "global", ".internal"]
+      end
+    
+  /**
+   * Gets the first value in global storage with given name, or fail.
+   *
+   * Example:
+   *   index-get-global(|"last-compile") => Timestamp(1334322856)
+   *   index-get-global(|["last-compile", "file.str"]) => Timestamp(1334322856)
+   * 
+   * @param name  The name or list of names to identify the global value.
+   * @type _ -> ?value
+   */
+  index-get-global(|name):
+    _ -> value
+    where
+      value := <indexlib-get-value> Global(<index-globals-uri> name, ())
+    
+  /**
+   * Gets all values in global storage with given name.
+   *
+   * Example:
+   *   index-get-global(|"last-compile") => [Timestamp(1334322856), ...]
+   *   index-get-global(|["last-compile", "file.str"]) => [Timestamp(1334322856), ...]
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type _ -> List(value)
@@ -212 +365,186 @@
-  index-uri = index-uri-impl <+ index-uri-generic
+  index-get-all-globals(|name):
+    _ -> values
+    with
+      values := <indexlib-get-all-values> Global(<index-globals-uri> name, ())
+    
+  /**
+   * Add value to global storage with given name.
+   *
+   * Example:
+   *   <index-add-global(|"last-compile")> Timestamp(1334322856)
+   *   <index-add-global(|["last-compile", "file.str"])> Timestamp(1334322856)
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type x -> x
+   */   
+  index-add-global(|name):
+    value -> <id>
+    with
+      <index-add(|<index-globals-path>)> Global(<index-globals-uri> name, value)
+      
+  /**
+   * Overwrites value in global storage with given value.
+   *
+   * Example:
+   *   <index-set-global(|"last-compile")> Timestamp(1334322856)
+   *   <index-set-global(|["last-compile", "file.str"])> Timestamp(1334322856)
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type x -> x
+   */   
+  index-set-global(|name):
+    value -> <id>
+    with
+      index-clear-global(|name);
+      <index-add-global(|name)> value
+    
+  /**
+   * Removes all values from global storage with given name.
+   *
+   * Example:
+   *   index-clear-global(|"last-compile")
+   *   index-clear-global(|["last-compile", "file.str"])
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type x -> x
+   */   
+  index-clear-global(|name):
+    _ -> <id>
+    with
+      <index-remove(|<index-globals-path>)> Global(<index-globals-uri> name, ())
+      
+  /**
+   * Gets the URI where boolean globals are stored in the index for given name or names.
+   *
+   * @internal
+   */
+  index-boolean-globals-uri:
+    names -> uri
+    with
+      if is-list then
+        uri := <concat> [[Global()], names, ["boolean", "globals", ".internal"]]
+      else
+        uri := [Global(), names, "boolean", "global", ".internal"]
+      end
+      
+  /**
+   * Sets boolean value true to global boolean storage with given name.
+   *
+   * Example:
+   *   index-enable-global(|"can-compile")
+   *   index-enable-global(|["can-compile", "file.str"])
+   *
+   * @param name  The name or list of names to identify the global boolean value.
+   * @type x -> x
+   */   
+  index-enable-global(|name):
+    _ -> <id>
+    with
+      <index-add(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
+      
+  /**
+   * Sets boolean value false to global boolean storage with given name.
+   *
+   * Example:
+   *   index-disable-global(|"can-compile")
+   *   index-disable-global(|["can-compile", "file.str"])
+   *
+   * @param name  The name or list of names to identify the global boolean value.
+   * @type x -> x
+   */   
+  index-disable-global(|name):
+    _ -> <id>
+    with
+      <index-remove(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
+      
+  /**
+   * Query for boolean value true in global boolean storage with given name.
+   *
+   * Example:
+   *   index-is-global-enabled(|"can-compile")
+   *   index-is-global-enabled(|["can-compile", "file.str"])
+   *
+   * @param name  The name or list of names to identify the global boolean value.
+   * @type x -> ?x
+   */   
+  index-is-global-enabled(|name):
+    _ -> <id>
+    where
+      <indexlib-get> Global(<index-boolean-globals-uri> name)
+
+rules // Index utility
+  
+  /**
+   * Gets the URI part for given term. Can be extended by defining a index-uri-impl rule. If no index-uri-impl rule
+   * is defined for the given term the first subterm is used as the URI. Fails if no URI can be retrieved from the
+   * given term.
+   *
+   * Example:
+   *   <index-uri> DefData([Entity(), "Bar", "Baz"], Type(), TYPE("Bar")) => [Entity(), "Bar", "Baz"]
+   *
+   * @type elem -> ?uri
+   *
+   * @see index-uri-impl
+   * @see index-uri-generic
+   */ 
+  index-uri = 
+    index-uri-impl <+ index-uri-generic
+  
+  /**
+   * Gets the namespace part of the given URI.
+   *
+   * Example:
+   *   <index-uri-path> [Entity(), "Bar", "Baz"] => Entity()
+   *
+   * @type uri@[namespace|path] -> namespace
+   */ 
+  index-uri-namespace =
+    ?[<id>|_]
+  
+  /**
+   * Gets the path part of the given URI.
+   *
+   * Example:
+   *   <index-uri-path> [Entity(), "Bar", "Baz"] => ["Bar", "Baz"]
+   *   <index-uri-path> [Entity()] => []
+   *
+   * @type uri@[namespace|path] -> path
+   */ 
+  index-uri-path =
+    ?[_|<id>]
+    
+  /**
+   * Gets the name part of the given URI or fail if there is no name.
+   *
+   * Example:
+   *   <index-uri-name> [Entity(), "Bar", "Baz"] => "Bar"
+   *   <index-uri-name> [Entity()] => fail
+   *
+   * @type uri@[namespace|[name|restPath]] -> ?name
+   */ 
+  index-uri-name =
+    ?[_|[<id>|_]]
+  
+  /**
+   * Gets the value part for given term. Can be extended by defining a index-value-impl rule. If no index-value-impl 
+   * rule is defined for the given term the second subterm is used as the value. Fails if no value can be retrieved
+   * from the given term.
+   *
+   * Example:
+   *   <index-value> DefData([Entity(), "Bar", "Baz"], Type(), TYPE("Bar")) => TYPE("Bar")
+   *
+   * @type elem -> ?value
+   *
+   * @see index-value-impl
+   * @see index-value-generic
+   */  
+  index-value = 
+    index-value-impl <+ index-value-generic
+  
+  /**
+   * Queries if given index file is a 'fake' file for storing internal data.
+   *
+   * @type x -> ?x
+   */
+  index-is-fake-file = 
+    string-starts-with(|"/.internal")
@@ -220,0 +559,2 @@
+   *
+   * @type (u1, u2) -> ?(u1, u2)
@@ -228,18 +567,0 @@
-
-  /**
-   * Checks if given keys (term{uri} elements) are equal. Discards unresolved URI's.
-   *
-   * Example:
-   *   <index-key-eq> ("Bar"{[Entity(), "Bar"]}, "Bar"{[Unresolved(Entity()), "Bar"]}) => 
-   *     ("Bar"{[Entity(), "Bar"]}, "Bar"{[Unresolved(Entity()), "Bar"]})
-   *   <index-key-eq> ("Foo"{[Entity(), "Foo"]}, "Bar"{[Entity(), "Bar"]}) => fail
-   */      
-  index-key-eq:
-    (k1, k2) -> <id>
-    where
-      <eq> (<index-key-unwrap> k1, <index-key-unwrap> k2)
-  
-  /**
-   * Gets the value part for given term.
-   */  
-  index-value = index-value-impl <+ index-value-generic
@@ -248,0 +571,2 @@
+   *
+   * @type x -> ?name{uri}
@@ -254,0 +579,88 @@
+  /**
+   * Converts a URI to a string.
+   *
+   * Example:
+   *   <index-uri-to-string> [Entity(), "Bar", "Baz"] => "Entity://Bar.Baz"
+   *
+   * @type uri -> str
+   */
+  index-uri-to-string:
+    [ns|path] -> <concat-strings> [nsStr, "://", pathStr]
+    with
+      pathStr := <take-until(?Anon(_)); reverse; separate-by(|"."); concat-strings> path;
+      nsStr := <?<id>#(_)> ns
+  
+  /**
+   * Converts a file to a string.
+   *
+   * Example:
+   *   <index-file-to-string> "fullpath/file.ext" => "fullpath/file.ext"
+   *
+   * @type file -> file
+   */
+  index-file-to-string:
+    file -> file
+    where
+      not(<is-tuple> file)
+  
+  /**
+   * Converts a file ((file, subfile) tuple) to a string.
+   *
+   * Example:
+   *   <index-file-to-string> ("fullpath/file.ext", []) => "fullpath/file.ext"
+   *
+   * @type (file, []) -> file
+   */
+  index-file-to-string:
+    (file, []) -> file
+    
+  /**
+   * Converts a file ((file, subfile) tuple) to a string.
+   *
+   * Example:
+   *   <index-file-to-string> ("fullpath/file.ext", [Entity(), "Foo" "Bar"]) => "fullpath/file.ext@Entity://Foo.Bar"
+   *
+   * @type (file, subfile) -> str
+   */
+  index-file-to-string:
+    (file, subfile) -> <concat-strings> [file, "@", <index-uri-to-string> subfile]
+    where
+      not([] := subfile)
+
+  /**
+   * Converts a file to a URI.
+   *
+   * Example:
+   *   <index-file-to-uri> "fullpath/file.ext" => [None(), "fullpath/file.ext"]
+   *
+   * @type file -> uri
+   */      
+  index-file-to-uri:
+    file -> [None(), file]
+    where
+      not(<is-tuple> file)
+      
+  /**
+   * Converts a file ((file, subfile) tuple) to a URI.
+   *
+   * Example:
+   *   <index-file-to-uri> ("fullpath/file.ext", []) => [None(), "fullpath/file.ext]
+   *
+   * @type (file, subfile) -> uri
+   */      
+  index-file-to-uri:
+    (file, []) -> [None(), file]
+    
+  /**
+   * Converts a file ((file, subfile) tuple) to a URI.
+   *
+   * Example:
+   *   <index-file-to-uri> ("fullpath/file.ext", [Entity(), "Foo" "Bar"]) => [Entity(), "Foo", "Bar", "fullpath/file.ext"]
+   *
+   * @type (file, subfile) -> uri
+   */      
+  index-file-to-uri:
+    (file, subfile) -> <conc> ([file], subfile)
+    where
+      not([] := subfile)
+      
@@ -257 +669,2 @@
-    
+  
+  /** @internal */
@@ -260,0 +674 @@
+  /** @internal */
@@ -263,0 +678 @@
+  /** @internal */
@@ -266,0 +682 @@
+  /** @internal */
@@ -272,0 +689 @@
+  /** @internal */
@@ -275,0 +693 @@
+  /** @internal */
@@ -278,3 +695,0 @@
-    
-  index-key-unwrap = 
-    \key{uri} -> key{<index-uri-unwrap> uri}\ <+ id
diff --git a/javasources/K3Disamb/test/simple-untyped.k3 b/javasources/K3Disamb/test/simple-untyped.k3
deleted file mode 100644
index 1260891..0000000
--- a/javasources/K3Disamb/test/simple-untyped.k3
+++ /dev/null
@@ -1,197 +0,0 @@
-  configuration <T color="red">
-                  <threads color="orange">
-                    <thread multiplicity="*" color="yellow">
-                      <k color="green"> (PGM:K ~> execute) </k>
-                      <control color="cyan">
-                        <fstack color="blue"> .List </fstack>
-                        <xstack color="purple"> .List </xstack>
-                      </control>
-                      <env color="violet"> .Map </env>
-                      <holds color="black"> .Map </holds>
-                    </thread>
-                  </threads>
-                  //<br/>
-                  <genv color="pink"> .Map </genv>
-                  <store color="white"> .Map </store>
-                  <busy color="cyan">.Set</busy>
-                  <in color="magenta" stream="stdin"> .List </in>
-                  <out color="brown" stream="stdout"> .List </out>
-                  <nextLoc color="gray"> 0 </nextLoc>
-                </T>
-
-
-
-  rule <k> var X:#Id; => . ...</k>
-       <env> Env:Map => Env[L:#Int/X] </env>
-       <store>... . => L|->undefined ...</store>
-       <nextLoc> L => L +Int 1 </nextLoc>
-
-  rule <k> var X[N:#Int]; => . ...</k>
-       <env> Env => Env[L/X] </env>
-       <store>... . => L |-> arrayRef(L +Int 1, N)
-                       (L +Int 1) .. (L +Int N) |-> undefined ...</store>
-       <nextLoc> L => (L +Int 1) +Int N </nextLoc>
-
-
-  context var X[HOLE];
-
-  rule var X[N1,N2,Vs:Vals]; =>
-       var X[N1];
-       {
-         var $1 = X;
-         for $2 = 0 to N1 - 1 do   // stupid parser
-         {
-           var X[N2,Vs];            // stupid parser
-           $1[$2] = X;
-         }
-       }  [structural]
-
-  rule <k> function F:#Id(Xs:Ids) S:Stmt => . ...</k>
-       <env> Env => Env[L/F] </env>
-       <store>... . => L|->lambda(Xs,S) ...</store>
-       <nextLoc> L => L +Int 1 </nextLoc>
-
-  rule <k> execute => main(.Exps); </k>
-       <env> Env </env> <genv> . => Env </genv>  [structural]
-
-  rule <k> X => V:Val ...</k>
-       <env>...X|->L...</env>
-       <store>...L|->V...</store>  [transition]
-
-
-
-  context ++(HOLE => lvalue(HOLE))
-  rule <k> ++loc(L) => I:#Int +Int 1 ...</k>
-       <store>... L |-> (I => I +Int 1) ...</store>  [transition]
-
-  rule I1:#Int + I2:#Int => I1 +Int I2
-  //rule Str1:#String + Str2:#String => Str1 +String Str2
-  rule I1:#Int - I2:#Int => I1 -Int I2
-  rule I1:#Int * I2 => I1 *Int I2
-  rule I1:#Int / I2 => I1 /Int I2 when I2 =/=Bool 0
-  rule I1:#Int % I2 => I1 %Int I2 when I2 =/=Bool 0
-  rule - I:#Int => -Int I
-  rule I1:#Int < I2 => I1 <Int I2
-  rule I1:#Int <= I2 => I1 <=Int I2
-  rule I1:#Int > I2 => I1 >Int I2
-  rule I1:#Int >= I2 => I1 >=Int I2
-  rule V1:Val == V2:Val => V1 ==Bool V2
-  rule V1:Val != V2 => V1 =/=Bool V2
-  rule B1:#Bool and B2:#Bool => B1 andBool B2
-  rule B1:#Bool or B2 => B1 orBool B2
-  rule not(B:#Bool) => notBool(B)
-
-
-  rule V[N1,N2,Vs] => V[N1][N2,Vs]  [structural]
-  rule arrayRef(L,_)[N] => lookup(L +Int N)  [structural]
-
-  rule <k> lookup(L) => V ...</k> <store>...L|->V...</store>  [transition]
-
-  rule sizeOf(arrayRef(_,N)) => N
-
-
-
-  rule <k> lambda(Xs,S)(Vs:Vals) ~> K:K
-        => bindto(Xs,Vs) ~> S ~> return; </k>
-       <control> <fstack> . => (Env,K,C) ...</fstack> C:Bag </control>
-       <env> Env => GEnv </env>
-       <genv> GEnv:Map </genv>
-  rule <k> return(V); ~> _ => V ~> K </k>
-       <control> <fstack> (Env,K,C) => . ...</fstack> (_ => C) </control>
-       <env> _ => Env </env>
-
-  rule return; => return nothing;   [structural]
-
-
-
-  rule <k> bindto((X,Xs => Xs),(V,Vs:Vals => Vs)) ...</k>
-       <env> Env => Env[L/X] </env>
-       <store>... . => L |-> V ...</store>
-       <nextLoc> L => L +Int 1 </nextLoc>
-  rule <k> bindto(.Ids,.Exps) => . ...</k>  [structural]
-
-  rule <k> read() => I ...</k> <in> ListItem(I) => . ...</in>  [transition]
-
-
-  context (HOLE => lvalue(HOLE)) = _
-  rule <k> loc(L)=V => V ...</k>
-       <store>... L|->(_=>V) ...</store> [transition]
-
-  rule {} => . [structural]
-  rule <k> {Ss:Stmts} => Ss~>env(Env) ...</k> <env> Env </env>  [structural]
-
-
-
-  rule <k> env(Env) => . ...</k> <env> _ => Env </env>  [structural]
-
-
-  rule (env(_) => .) ~> env(_)  [structural]
-
-
-  rule S1:Stmt S2:Stmt => S1 ~> S2  [structural]
-
-  rule V; => .
-
-  rule if  true then S else _ => S
-  rule if false then _ else S => S
-
-  rule <k> while E:Exp do S
-    => if E then {S while E do S} else {} ...</k>  [structural]
-
-  rule <k> print(V,Vs => Vs); ...</k>
-       <out>... . => ListItem(V) </out>  [transition]
-  rule print(.Vals); => .                [structural]
-
-
-
-  rule <k> (try S1 catch(X) S2 => S1 ~> popx) ~> K </k>
-       <control> <xstack> . => (X,S2,K,Env,C) ...</xstack> C:Bag </control>
-       <env> Env </env>
-  rule <k> popx => . ...</k> <xstack> _:ListItem => . ...</xstack>
-  rule <k> throw V; ~> _ => {var X=V; S2} ~> K </k>
-       <control> <xstack> (X,S2,K,Env,C) => . ...</xstack> (_ => C) </control>
-       <env> _ => Env </env>
-
-
-   rule <thread>... <k> spawn S => . ...</k> <env> Env </env> ...</thread>
-        (. => <thread>... <k> S </k> <env> Env </env> ...</thread>)
-
-   rule (<thread>... <k>.K</k> <holds> H:Map </holds> ...</thread> => .)
-        <busy> Busy:Set => Busy -Set keys(H) </busy>
-
-
-   rule <k> acquire V; => . ...</k> <holds>... . => V|->0 ...</holds>
-        <busy> Busy (. => SetItem(V)) </busy>
-     when (notBool(V in Busy:Set)) [transition]
-   rule <k> acquire V; => . ...</k> <holds>... V|->(N => N +Int 1) ...</holds>
-
-
-   rule <k> release V; => . ...</k>
-        <holds>... V|->(N => N:#Int -Int 1) ...</holds>
-     when N >Int 0
-   // used prefix notation for -Int because of parsing problems
-   rule <k> release V; => . ...</k> <holds>... V|->0 => . ...</holds>
-        <busy>... SetItem(V)=>. ...</busy>
-
-
-   rule <k> rendezvous V; => . ...</k>
-        <k> rendezvous V; => . ...</k>  [transition]
-
-// For parsing reasons, we prefer to allow lvalue to take a K
-
-// Local variable
-  rule <k> lvalue(X) => loc(L:#Int) ...</k>
-       <env>... X|->L ...</env>  [structural]
-// Array element: evaluate the array and its index;
-// then the array lookup rule above applies.
-  context lvalue(_[HOLE])
-  context lvalue(HOLE[_])
-// Finally, return the address of the desired object member
-  rule <k> lvalue(lookup(L)) => loc(L) ...</k>  [structural]
-
-
-
-
-  rule N1:#Int..N2:#Int => .List{K}              when N1  >Int N2  [structural]
-  rule N1:#Int..N2:#Int => N1 ,, (N1 +Int 1)..N2 when N1 <=Int N2  [structural]
-
diff --git a/javasources/K3Disamb/trans/analysis-manual.str b/javasources/K3Disamb/trans/analysis-manual.str
deleted file mode 100644
index f0b0a75..0000000
--- a/javasources/K3Disamb/trans/analysis-manual.str
+++ /dev/null
@@ -1,10 +0,0 @@
-module analysis-manual
-
-imports
-  include/K3Disamb
-  lib/analysis-auto.generated
-  lib/index-library.generated
-
-rules // Adjust lookup
-
-  // Add primitive types to type lookup.
diff --git a/javasources/K3Disamb/trans/k3disamb.str b/javasources/K3Disamb/trans/k3disamb.str
index 654ba4c..fcc8cb4 100644
--- a/javasources/K3Disamb/trans/k3disamb.str
+++ b/javasources/K3Disamb/trans/k3disamb.str
@@ -11 +10,0 @@
-  analysis-manual
diff --git a/javasources/K3Java/src/k3/basic/Definition.java b/javasources/K3Java/src/k3/basic/Definition.java
index 7796c76..ba0bfca 100644
--- a/javasources/K3Java/src/k3/basic/Definition.java
+++ b/javasources/K3Java/src/k3/basic/Definition.java
@@ -1161 +1161 @@
-			GlobalSettings.kem.register(new KException(ExceptionType.ERROR, KExceptionGroup.COMPILER, KMessages.ERR1002 + mainModule + ". Use --lang <arg> to specify another.", this.mainFile.getName(), "definition", 0));
+			GlobalSettings.kem.register(new KException(ExceptionType.ERROR, KExceptionGroup.CRITICAL, KMessages.ERR1002 + mainModule + ". Use --lang <arg> to specify another.", this.mainFile.getName(), "definition", 0));
diff --git a/javasources/K3Syntax/syntax/K3Syntax.generated.pp b/javasources/K3Syntax/syntax/K3Syntax.generated.pp
deleted file mode 100644
index 32b08c7..0000000
--- a/javasources/K3Syntax/syntax/K3Syntax.generated.pp
+++ /dev/null
@@ -1,40 +0,0 @@
-[
-   KModuleList               -- _1 _2,
-   KModuleList.1:iter-star   -- _1,
-   KModuleList.2:iter-star   -- _1,
-   Require                   -- KW["require"] _1,
-   KModule                   -- KW["module"] _1 _2 _3 KW["endmodule"],
-   KModule.2:iter-star       -- _1,
-   KModule.3:iter-star       -- _1,
-   KInterface                -- KW["interface"] _1 _2 _3 KW["endinterface"],
-   KInterface.2:iter-star    -- _1,
-   KInterface.3:iter-star    -- _1,
-   Imports                   -- KW["imports"] _1,
-   Config                    -- V  [H  [KW["configuration"]] _1],
-   Config.1:iter             -- _1,
-   Rule                      -- V  [H  [KW["rule"]] _1],
-   Rule.1:iter               -- _1,
-   Context                   -- V  [H  [KW["context"]] _1],
-   Context.1:iter            -- _1,
-   Syntax                    -- KW["syntax"] _1 KW["::="] _2,
-   Syntax.2:iter-sep         -- _1 KW[">"],
-   LeftOrList                -- V  [H  [KW["left:"]] _1],
-   LeftOrList.1:iter-sep     -- _1 KW["|"],
-   RightOrList               -- V  [H  [KW["right:"]] _1],
-   RightOrList.1:iter-sep    -- _1 KW["|"],
-   NonAssocOrList            -- V  [H  [KW["non-assoc:"]] _1],
-   NonAssocOrList.1:iter-sep -- _1 KW["|"],
-   OrList                    -- _1,
-   OrList.1:iter-sep         -- _1 KW["|"],
-   Prod                      -- _1,
-   Prod.1:iter               -- _1,
-   AnnoProd                  -- _1 KW["["] _2 KW["]"],
-   AnnoProd.1:iter           -- _1,
-   AnnoProd.2:iter-sep       -- _1 KW[","],
-   Terminal                  -- _1,
-   Sort                      -- _1,
-   List                      -- KW["List{"] _1 KW[","] _2 KW["}"],
-   Tag                       -- _1,
-   TagParam                  -- _1 KW["("] _2 KW[")"],
-   TagParam                  -- _1 KW["("] _2 KW[")"]
-]
\ No newline at end of file
diff --git a/javasources/LatexComments/editor/LatexComments-Completions.esv b/javasources/LatexComments/editor/LatexComments-Completions.esv
index edf7a04..49f16cf 100644
--- a/javasources/LatexComments/editor/LatexComments-Completions.esv
+++ b/javasources/LatexComments/editor/LatexComments-Completions.esv
@@ -14,18 +13,0 @@
-  // Syntax completion:                      
-                                             
-  completion template Start :
-    "module " <m> (blank)  
-                                             
-  completion template Definition :
-    "entity " <e> " {" (cursor) "}" (blank)  
-                                             
-  completion template Property : "property : Type" =
-    <x> " : " <T> (blank)  
-                                             
-
-completions
-  // Semantic (identifier) completion:   
-                                         
-  completion proposer                  : editor-complete
-                                         
-  completion trigger                   : ":"
\ No newline at end of file

